<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
                    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
                                    <title>BrandZ Design Doc (Community Group zones.brandz_design_doc) - XWiki</title>
                <meta http-equiv="Content-Script-Type" content="text/javascript" />
                        <meta http-equiv="imagetoolbar" content="no"/>
                      <link rel="alternate" type="application/x-wiki" title="Edit" href="/bin/edit/Community+Group+zones/brandz_design_doc" />
                    <link rel="canonical" href="/bin/view/Community+Group+zones/brandz_design_doc" />
                            <meta name="document" content="Community Group zones.brandz_design_doc"/>
    <meta name="wiki" content="xwiki"/>
    <meta name="space" content="Community Group zones"/>
    <meta name="page" content="brandz_design_doc"/>
    <meta name="version" content="1.1"/>
    <meta name="restURL" content="/rest/wikis/xwiki/spaces/Community+Group+zones/pages/brandz_design_doc"/>
                <meta name="gwt:property" content="locale=en" />
                <meta name="revisit-after" content="7 days" />
<meta name="description" content="BrandZ Design Doc" />
<meta name="keywords" content="wiki " />
<meta name="distribution" content="GLOBAL" />
<meta name="rating" content="General" />
<meta name="author" content="admin" />
<meta http-equiv="reply-to" content="" />
<meta name="language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="alternate" type="application/rss+xml" title="Wiki Feed RSS" href="/bin/view/Main/WebRss?xpage=rdf" />
<link rel="alternate" type="application/rss+xml" title="Blog RSS Feed" href="/bin/view/Blog/GlobalBlogRss?xpage=plain" />
<link rel="shortcut icon" href="/resources/icons/oso/icon.png">
                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
<link href="https://markebrooks.github.io/static/css/stylesheet.css" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/style.css?colorTheme=ColorThemes.Oso" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/print.css" rel="stylesheet" type="text/css" media="print" />
        <!--[if IE]>
  <link href="/bin/skin/skins/colibri/ie%2Dall.css" rel="stylesheet" type="text/css" />
<![endif]-->
<!--[if IE 6]>
  <link href="/bin/skin/skins/colibri/ie%2D6.css" rel="stylesheet" type="text/css" />
<![endif]-->
<link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Settings?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Style?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/XWiki/SharePage?language=en'/>
<link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/modalPopup.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/jumpToPage.css?language=en'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/confirmationBox.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/notification.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/skins/colibri/resources/uicomponents/viewers/tags.css'/>

    
    <link href="/bin/skin/resources/js/xwiki/suggest/ajaxSuggest.css" rel="stylesheet" type="text/css" />
<link href="/bin/skin/resources/js/xwiki/lightbox/lightbox.css" rel="stylesheet" type="text/css" />
<!--[if IE]>
  <link href="/bin/skin/resources/js/xwiki/lightbox/lightboxIE.css" rel="stylesheet" type="text/css" />
<![endif]-->












<script type="text/javascript" src="/resources/js/prototype/prototype.js"></script>
<script type="text/javascript" src="/bin/skin/resources/js/xwiki/xwiki.js"></script>
<script type="text/javascript">
// <![CDATA[
XWiki.webapppath = "";
XWiki.servletpath = "bin/";
XWiki.contextPath = "";
XWiki.mainWiki = "xwiki";
XWiki.currentWiki = "xwiki";
XWiki.currentSpace = "Community Group zones";
XWiki.currentPage = "brandz_design_doc";
XWiki.editor = "";
XWiki.viewer = "";
XWiki.contextaction = "view";
XWiki.docisnew = false;
XWiki.docsyntax = "xwiki/2.0";
XWiki.blacklistedSpaces = [ "Import","Panels","Scheduler","Stats","XAppClasses","XAppSheets","XAppTemplates","XWiki","WatchCode","WatchSheets","XApp","WatchAdmin","Watch","ColorThemes","AnnotationCode" ];
XWiki.hasEdit = false;
XWiki.hasProgramming = false;
XWiki.hasBackupPackImportRights = false;
window.docviewurl = "/bin/view/Community+Group+zones/brandz_design_doc";
window.docediturl = "/bin/edit/Community+Group+zones/brandz_design_doc";
window.docsaveurl = "/bin/save/Community+Group+zones/brandz_design_doc";
window.docgeturl = "/bin/get/Community+Group+zones/brandz_design_doc";
// ]]>
</script>
<script type='text/javascript' src='/bin/skin/resources/js/scriptaculous/effects.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/modalPopup.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/jumpToPage.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmationBox.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmedAjaxRequest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/notification.js' defer='defer'></script>
<script type='text/javascript' src='/resources/uicomponents/widgets/list/xlist.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/suggest/ajaxSuggest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/skins/colibri/resources/uicomponents/viewers/tags.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/scriptaculous/scriptaculous.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/accordion/accordion.js' defer='defer'></script>

<script type='text/javascript' src='/bin/jsx/XWiki/WebDAV?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Settings?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Script?language=en' defer='defer'></script>

<script type="text/javascript" src="/resources/js/xwiki/compatibility.js" defer="defer"></script>

  </head>
  <body id="body" class="wiki-xwiki space-Community_Group_zones viewbody hideright">
<div id="xwikimaincontainer">
<div id="xwikimaincontainerinner">

  <div id="menuview">
    <div id="mainmenu" class="layoutsubsection actionmenu">
<strong id="xwikimenutitle" class="hidden">General Actions:</strong>
<div class="rightmenu">
      <div id="tmLogin" class="tmLogin topmenuentry ">
   <a class="tme" href="https://auth.opensolaris.org/login.action?targetUrl=http%3A%2F%2Fmarkebrooks.github.io%2Fbin%2Fview%2FCommunity%2BGroup%2Bzones%2Fbrandz_design_doc"><strong>Log-in</strong></a>
  </div>
  </div>
<div class="leftmenu">
  <div id="tmWiki" class="tmWiki topmenuentry hasIcon">
   <a class="tme" href="/bin/view/Main/"><strong>Wiki</strong></a>
  </div>
  <div id="tmSpace" class="tmSpace topmenuentry dropdownmenuentry  hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Community+Group+zones/"><strong>Community Group zones</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
                <span class="submenuitem "><a href="/bin/view/Main/SpaceIndex?space=Community+Group+zones" id="tmSpaceDocumentIndex" class="tmSpaceDocumentIndex">Document Index</a></span>
    </span></div>

<div id="tmSubSites" class="tmSubSites topmenuentry dropdownmenuentry dropdownnolink hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Subsites</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem hasIcon"><a href="https://cr.opensolaris.org/" id="tmCR" class="tmCR">Code Reviews</a></span>
<span class="submenuitem hasIcon"><a href="http://repo.opensolaris.org/" id="tmRepo" class="tmRepo">SCM Management</a></span>
<span class="submenuitem hasIcon"><a href="http://pkg.opensolaris.org/" id="tmPkg" class="tmPkg">Package Search</a></span>
<span class="submenuitem hasIcon"><a href="http://bugs.opensolaris.org/" id="tmBugs" class="tmBugs">Bugster</a></span>
<span class="submenuitem hasIcon"><a href="http://defect.opensolaris.org/" id="tmDefect" class="tmDefect">Bugzilla</a></span>
<span class="submenuitem hasIcon"><a href="http://test.opensolaris.org/" id="tmTest" class="tmTest">Test Machines</a></span>
<span class="submenuitem hasIcon"><a href="http://planet.opensolaris.org/" id="tmPlanet" class="tmPlanet">Planet</a></span>
<span class="submenuitem hasIcon"><a href="http://mail.opensolaris.org/" id="tmMail" class="tmMail">Mailing Lists</a></span>
<span class="submenuitem hasIcon"><a href="http://poll.opensolaris.org/" id="tmPoll" class="tmPoll">Elections &amp; Polls</a></span>
<span class="submenuitem hasIcon"><a href="http://arc.opensolaris.org/" id="tmArc" class="tmArc">ARC Case Logs</a></span>
<span class="submenuitem hasIcon"><a href="http://jucr.opensolaris.org/" id="tmJucr" class="tmJucr">Source Juicer</a></span>
<span class="submenuitem hasIcon"><a href="http://pkgfactory.opensolaris.org/" id="tmPkgfactory" class="tmPkgfactory">Package Factory</a></span>
<span class="submenuitem hasIcon"><a href="http://auth.opensolaris.org/" id="tmAuth" class="tmAuth">Auth</a></span>
</span></div>

</div>
</div>

  </div>
 <div id="header" class="layoutsection">
<div class="minwidthb"></div>

  <div id="header">
    <table style="width: 100%;">
        <tr>
            <td style="width: 1%;">
                 <a href="https://markebrooks.github.io/bin/view/Main/"><div id="logo"></div></a>  
            </td>
            <td id="logo-text" style="width: 1%;">
                Solaris
            </td>         
            <td style="width: 98%;">
                <table id="loading-indicator">
                    <tr>
                        <td><img src="https://markebrooks.github.io:443/static/images/busy.gif"
                                 alt="Loading" title="Loading"/></td>
                        <td>Loading...</td>
                    </tr>
                </table>
            </td>
            <td style="width: 1%;">
                <table id="iconbar">
                    <tr>
                    <td><a id="collectives-icon" href="https://markebrooks.github.io/bin/view/Main/collectives">
                        Collectives</a></td>
                    <td><a id="discussions-icon" href="https://markebrooks.github.io/bin/view/Main/discussions">
                            Discussions</a></td>
                    <td><a id="documentation-icon" href="https://markebrooks.github.io/bin/view/Main/documentation">
                            Documentation</a></td>
                    <td><a id="download-icon" href="https://markebrooks.github.io/bin/view/Main/downloads">
                            Download</a></td>
                    <td><a id="source-browser-icon" href="http://src.opensolaris.org/source">
                            Source Browser</a></td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</div>

 </div> 
  <div id="globallinks">
    <form action="/bin/view/Main/Search">
      <div class="globalsearch">
        <label class="hidden" for="headerglobalsearchinput">Search</label><input class="globalsearchinput withTip" id="headerglobalsearchinput" type="text" name="text" value="search..." size="15"/><input class="button" type="image" value="Go" alt="Go" src="/resources/icons/xwiki/search.png"/>
      </div>
    </form>
  </div> <div style="float:left;">

                

   <div id="hierarchy">
                              <a href='/bin/view/Community+Group+zones/brandz'>BrandZ</a> <span class='separator'>&#187;</span> <span class='current'>BrandZ Design Doc</span>
                </div>

</div>
  <span class="glink" id="headerlanguages" style="float:right">
        <a href="/bin/view/Community+Group+zones/brandz_design_doc?language=en" class="language-default language-current">en</a>
    </span>


<div class="contenthideright" id="contentcontainer">
<div id="contentcontainerinner">
<div class="leftsidecolumns">
  <div id="contentcolumn"> 
          <div class="main layoutsubsection">
      <div id="contentmenu" class="actionmenu">
    <strong id="xwikicontentmenutitle" class="hidden">Page Actions:</strong>
<div class="rightmenu">
</div>
<div class="leftmenu">
  <div id="tmExport" class="tmExport topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Export</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/export/Community+Group+zones/brandz_design_doc?format=pdf&amp;language=en" id="tmExportPdf" class="tmExportPdf">Export as PDF</a></span>
  <span class="submenuitem "><a href="/bin/export/Community+Group+zones/brandz_design_doc?format=rtf&amp;language=en" id="tmExportRtf" class="tmExportRtf">Export as RTF</a></span>
  <span class="submenuitem "><a href="/bin/export/Community+Group+zones/brandz_design_doc?format=html&amp;language=en" id="tmExportHtml" class="tmExportHtml">Export as HTML</a></span>
    </span></div>

<div id="tmShow" class="tmShow topmenuentry dropdownmenuentry  " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Community+Group+zones/brandz_design_doc?viewer=code&amp;language=en"><strong>View</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem "><a href="/bin/view/Community+Group+zones/brandz_design_doc?viewer=comments&amp;language=en" id="tmViewComments" class="tmViewComments">Comments</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+zones/brandz_design_doc?viewer=attachments&amp;language=en" id="tmViewAttachments" class="tmViewAttachments">Attachments</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+zones/brandz_design_doc?viewer=history&amp;language=en" id="tmViewHistory" class="tmViewHistory">History</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+zones/brandz_design_doc?viewer=information&amp;language=en" id="tmViewInformation" class="tmViewInformation">Information</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+zones/brandz_design_doc?viewer=code&amp;language=en" id="tmViewSource" class="tmViewSource">View Source</a></span>
</span></div>

  <div id="tmMoreActions" class="tmMoreActions topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>More actions</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/view/Community+Group+zones/brandz_design_doc?xpage=print&amp;language=en" id="tmPrintPreview" class="tmPrintPreview">Print preview</a></span>
          <span class="submenuitem "><a href="/bin/view/Community+Group+zones/brandz_design_doc?xpage=copy" id="tmActionCopy" class="tmActionCopy">Copy</a></span>
      </span></div>
</div>

    </div>
    <div id="mainContentArea">
      








    
<div id="document-title"><h1>BrandZ Design Doc</h1></div>





              <div id="document-info">
    <div>
          </div>
    <div class="clearfloats"></div>
  </div>

<div id="xwikicontent">
<h3 id="H1.Introduction"><span>1. Introduction</span></h3><p>&nbsp;This project is delivering two sets of functionality:</p><ul><li>The BrandZ infrastructure, which enables the creation of zones that provide alternate operating environment personalities, or <em>brands</em> on a Solaris(tm) 10 system.</li><li><em>lx</em>, a brand that supports the execution of Linux applications</li></ul><p>&nbsp;This document describes the design and implementations of both BrandZ and the <em>lx</em> brand.</p><h3 id="H2.BrandZInfrastructure"><span>2. BrandZ Infrastructure</span></h3><h4 id="H2.1.ZonesIntegration"><span>2.1. Zones Integration</span></h4><p>&nbsp;It is a goal of this project that all brand management should be performed as simple extensions to the current zones infrastructure:</p><ul><li>The zones configuration utility will be extended to configure zones of particular brands.</li><li>The zone administration tools will be extended to display the brand of any created zone, as well as to list the brand types available.</li></ul><p>&nbsp;BrandZ adds functionality to the zones infrastructure by allowing zones to be assigned a brand type. This type is used to determine which scripts are executed when a zone is installed and booted. In addition, a zone's brand is used to properly identify the correct application type at application launch time. All zones have an associated brand for configuration purposes; the default is the 'native' brand.</p><h5 id="H2.1.1Configuration"><span>2.1.1 Configuration</span></h5><p>&nbsp;The <span class="box code">zonecfg(1M)</span> utility (as well as <span class="box code">libzonecfg</span>) is modified to be brand-aware. There is a new option to the 'create' command that allows a zone to be created with a specific brand:</p><pre>

   zonecfg:myzone&gt; create -B lx

</pre><p>&nbsp;Once a zone has been assigned a brand, that brand cannot be changed or removed.</p><p>&nbsp;The rest of the user interface for the zone configuration process remains the same. To support this, each brand delivers a configuration file at <span class="box code"><span style="color: #666666; ">/</span>usr<span style="color: #666666; ">/</span>lib<span style="color: #666666; ">/</span>brand<span style="color: #666666; ">/&lt;</span>name<span style="color: #666666; ">&gt;/</span>config.xml</span>. The file describes how to install, configure, and boot the zone. It also identifies the name of the kernel module (if any) that provides kernel-level functionality for the brand. A sample of the file follows:</p><pre>

&lt;!DOCTYPE brand PUBLIC "-//Sun Microsystems Inc//DTD Brands//EN"
    "file:///usr/share/lib/xml/dtd/brand.dtd.1"&gt;

&lt;brand name="lx"&gt;
        &lt;install&gt;/usr/lib/brand/lx/lx_install %z %R %*&lt;/install&gt;
        &lt;boot&gt;/usr/lib/brand/lx/lx_boot %R %z&lt;/boot&gt;
        &lt;halt&gt;/usr/lib/brand/lx/lx_halt %z&lt;/halt&gt;
        &lt;postclone&gt;/usr/bin/true&lt;/postclone&gt;
        &lt;modname&gt;lx_brand&lt;/modname&gt;
        &lt;initname&gt;/sbin/init&lt;/initname&gt;
        &lt;platform name="platform.xml" /&gt;
&lt;/brand&gt;

</pre><h5 id="H2.1.2Installation"><span>2.1.2 Installation</span></h5><p>&nbsp;The current zone install mechanism is hardwired to execute <span class="box code">lucreatezone</span> to install a zone. To support arbitrary installation methods, the <span class="box code">config.xml</span> file contains a line of the form:</p><pre>

    &lt;install&gt;/usr/lib/lu/lucreatezone -z %z&lt;/install&gt;

</pre><p>&nbsp;For the <em>lx</em> brand, this line will refer to <span class="box code"><span style="color: #666666; ">/</span>usr<span style="color: #666666; ">/</span>lib<span style="color: #666666; ">/</span>brand<span style="color: #666666; ">/</span>lx<span style="color: #666666; ">/</span>lx_install</span> instead of <span class="box code">lucreatezone</span>. All of the command tags support the following substitutions '%z' (for zonename) and '%R' (for zone root path). In addition, the zoneadm(1M) command will pass additional arguments to the program as specified on the command line. This will allow runtime installation arguments, such as the location of source media:</p><pre>

   # zoneadm -z linux install -d /net/installsrv/redhat30

</pre><h5 id="H2.1.3VirtualPlatform"><span>2.1.3 Virtual Platform</span></h5><p>&nbsp;The virtual platform consists of internal mounted filesystems, as well as the device tree and any network devices. The virtual platform is controlled by an XML file that is separate from the main brand config file, <span class="box code">config.xml</span>. The properties it controls are outlined below.</p><h6 id="H2.1.3.1MountedFilesystems"><span>2.1.3.1 Mounted Filesystems</span></h6><p>&nbsp;Before handing off control to the virtual platform, <span class="box code">zoneadmd</span> does some work of its own to set up well-known mounts and do some basic verification. It performs Solaris-specific mounts (<span class="box code"><span style="color: #666666; ">/</span>proc</span>, <span class="box code"><span style="color: #666666; ">/</span>system<span style="color: #666666; ">/</span>contract</span>, etc.), which need to be defined for each brand. We also need to mount native versions of some files in order to support the interpretation layer (for native access to <span class="box code"><span style="color: #666666; ">/</span>proc</span>, for example).</p><p>&nbsp;The set of filesystems mounted by <span class="box code">zoneadmd</span> are specified in the virtual platform configuration file:</p><pre>

    &lt;filesystem spec="/proc" dir="/native/proc" fstype="proc" /&gt;
    &lt;filesystem spec="/usr" dir="/native/usr" fstype="lofs" /&gt;

</pre><h6 id="H2.1.3.2DeviceConfiguration"><span>2.1.3.2 Device Configuration</span></h6><p>&nbsp;To create device nodes within a zone, <span class="box code">zoneadmd</span> calls <span class="box code">devfsadm</span>. The devfsadm process walks the current list of devices in <span class="box code"><span style="color: #666666; ">/</span>dev</span>, and calls into <span class="box code">libzonecfg</span> to determine if the device should be exported.</p><p>&nbsp;libzonecfg will consult a brand-specific platform configuration file that describes how to apply the following semantics:</p><ul><li><strong>Policy restrictions</strong>: Control which devices appear in the non-global zone. This is the only aspect currently implemented. This is currently hardcoded in <span class="box code">libzonecfg</span>.</li><li><strong>Device inheritance</strong>: Describes a device which matches exactly a device in the global zone. Currently this is assumed behavior, but it needs to be configurable.</li><li><strong>Device renaming</strong>: Allows devices to appear in diffent locations within the zone. This is needed to support devices that are emulated via layered drivers.</li></ul><p>&nbsp;The platform configuration file will have elements to perform all the above tasks. A sample scheme could be:</p><pre>

        &lt;!~-- Devices to create under /dev ~--&gt;

        &lt;device match="pts/*" /&gt;
        &lt;device match="ptmx" /&gt;
        &lt;device match="random" /&gt;
        &lt;device match="urandom" /&gt;

        &lt;device match="zero" /&gt;
        &lt;device match="null" /&gt;

        &lt;device match="tty" /&gt;
        &lt;device match="tcp" /&gt;
        &lt;device match="tcp6" /&gt;
        &lt;device match="udp" /&gt;

        &lt;device match="udp6" /&gt;

        &lt;!~-- Symlinks to create under /dev ~--&gt;

        &lt;symlink source="stderr" target="./fd/2" /&gt;
        &lt;symlink source="stdin" target="./fd/0" /&gt;
        &lt;symlink source="stdout" target="./fd/1" /&gt;

        &lt;symlink source="systty" target="zconsole" /&gt;
        &lt;symlink source="log" target="/var/run/syslog" /&gt;

        &lt;!~-- Renamed devices to create under /dev ~--&gt;

        &lt;device match="brand/lx/ptmx_linux" name="ptmx" /&gt;

        &lt;!~--
                /dev/console can't be a symlink because this breaks
                login security checks via /dev/securetty
        ~--&gt;

        &lt;device match="zconsole" name="console" /&gt;

</pre><h5 id="H2.1.4BootingaBrandedZone"><span>2.1.4 Booting a Branded Zone</span></h5><p>&nbsp;In addition to the install-time command attribute, the configuration file can also provide an optional 'boot' script. This script will be run after the zone has been brought to the 'Ready' state - immediately before the zone is booted. This allows a brand to perform any needed setup tasks after the virtual platform has been established, but before the first branded process has been launched, giving the brand complete flexibility in how the zone is brought online.</p><h5 id="H2.1.5Spawninginit"><span>2.1.5 Spawning init</span></h5><p>&nbsp;The <span class="box code">init(1M)</span> binary is spawned by the kernel, allowing the kernel to control its restart. The name and path of a zone's init(1M) binary is a per-zone attribute, which is stored in the brand configuration file and passed to the kernel by zoneadm immediately prior to booting the zone.</p><p>Linux does not allow kill(2) to send any signals to init(1M) for which a signal handler has not been registered (including SIGSTOP and SIGKILL, as by definition handlers <strong>cannot</strong> be registered for those signals.) We solve this by having lx_kill() make the same check and only allow a signal to be sent to the Linux init process if a handler for the signal has already been registered. The Linux man pages are silent on whether the Linux <em>kernel</em> can send init an unhandled signal, so we do not perform any particular checks to prevent the Solaris kernel from doing so.</p><h5 id="H2.1.6Shutdown"><span>2.1.6 Shutdown</span></h5><p>&nbsp;The standard <span class="box code">sysvinit</span> Linux init package operates in much the same way as our <span class="box code">init</span> did prior to the introduction of <span class="box code">smf(5)</span>. The 'init N' form of the command writes to the init FIFO, which happens to be <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>initctl</span>. The 'lx' brand's boot-time script creates this link from the global zone before the zone boots up.</p><p>&nbsp;The <span class="box code">init</span> command then does a <span class="box code">kill(1, SIGHUP)</span> to notify the running init process that there has been a change of runlevel. We interpose on the <span class="box code">kill(2)</span> syscall and translate PID 1 into whatever the zone-local PID is.</p><p>To actually power off or reboot the system, <span class="box code">init</span> calls the <span class="box code">reboot()</span> function with 'magic numbers' defined in <span class="box code">sys<span style="color: #666666; ">/</span>reboot.h</span>. This function translates directly to the <span class="box code">reboot</span> system call. This call, and the associated magic numbers, will be translated into an appropriate <span class="box code">uadmin()</span> call.</p><p>&nbsp;The Linux <span class="box code">simpleinit</span> program works in a nearly identical fashion. The main differences are in how it processes <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>rc</span> scripts.</p><h4 id="H2.2.KernelIntegration"><span>2.2. Kernel Integration</span></h4><h5 id="H2.2.1BrandFramework"><span>2.2.1 Brand Framework</span></h5><p>&nbsp;Brands are loaded into the system in the form of brand modules. A brand module is defined through a new linkage type:</p><pre>

struct modlbrand {
        struct mod_ops          *brand_modops;
        char                    *brand_linkinfo;
        struct brand            *brand_branddef;
};

</pre><p>&nbsp;Each brand must declare <span class="box code">struct brand</span> as part of the registration process.</p><pre>

typedef struct brand {
        int                     b_version;
        char                    *b_name;
        struct brand_ops        *b_ops;
        struct brand_mach_ops   *b_machops;
} brand_t;

</pre><p>&nbsp;This structure declares the name of the brand, the version of the brand interface against which it was compiled, and ops vectors containing both common and platform-dependent functionality. The <span class="box code">b_version</span> field is currently used to determine whether a brand is eligible to be loaded into the system. If the version number does not match the one compiled into the kernel, then we simply refuse to load the brand module. In theory, this version number could also be used to interpret the contents of the two ops vectors, allowing us to continue supporting older brand modules.</p><p>&nbsp;It is important to note that even though we have defined a linkage type for brands and have implemented a versioning mechanism, we are not defining a formal ABI for brands. The relationship between brands and the kernel is so intimate that we cannot hope to properly support the development of brands outside the ON consolidation. This does not mean that we will do anything to prevent the development of brands outside of ON, but we must minimize the possibility of an out-of-date brand accidentally damaging something within the kernel.</p><h5 id="H2.2.2SystemCallInterposition"><span>2.2.2 System Call Interposition</span></h5><p>&nbsp;The system call invocation mechanism is an implementation detail of both the operating system and the hardware architecture. On SPARC machines, a system call is initiated via a trap (Solaris chooses to use trap numbers 8 and 9.) On x86 machines, there are a variety of different methods available to enter the kernel: <span class="box code">sysenter</span> and <span class="box code">syscall</span> instructions, <span class="box code">lcalls</span>, and software-triggered interrupts. Solaris has used all of these mechanisms at various points, and maintaining binary compatibility requires that we continue to support them all.</p><p>Supporting a different version of Solaris requires interposing on each of these mechanisms. Before we begin executing the system call support code for the native version of Solaris, we must ensure that the process does not belong to a brand that has a different implementation of those calls. To do that, we must check the proc structure of the initiating process to determine whether it belongs to a foreign brand, and if so, whether that brand has chosen to interpose on that entry point. This check is carried out by a <span class="box code">BRAND_CALLBACK()</span> macro placed at the top of the handling routine for each of the existing entry points. If the brand wishes to interpose on the entry point, control is passed to that brand's kernel module. If not, control returns to the handler and the standard Solaris system call code is executed.</p><p>&nbsp;Linux has a single means of entering the kernel: executing an 'int 80' instruction. Since this mechanism is not used by any version of Solaris, there is no existing mechanism on which we can interpose. Therefore the creation of a Linux brand requires that we provide a new entry point into the kernel specifically for this brand. As with the existing entry points, the <span class="box code">BRAND_CALLBACK()</span> macro is executed by this handler. In this case, there is no standard system call code to execute if the handler returns. Instead the program is killed with a General Protection Fault.</p><p>&nbsp;While introducing a new entry point is a trivial task within the Solaris engineering organization, it again demonstrates that the ability for third parties to distribute radically new brands will be limited. A third party may certainly distribute a modified version OpenSolaris that includes the changes they need, but any brands that depend on those changes would not work properly with our Solaris until/unless those changes were adopted by Sun.</p><p>&nbsp;For performance reasons, the <span class="box code">BRAND_CALLBACK()</span> macro is only invoked for branded processes. Each system call mechanism actually has two different entry points defined: one for branded processes and one for non-branded processes. A context handler is used to modify the appropriate CPU registers or structures to switch to the appropriate set of entry points during a context switch operation. The callback macro is only a dozen or so instructions long, but this switching mechanism ensures that non-branded processes are not subject to even that minimal overhead.</p><p>This interposition mechanism is executed before any other code in the system call path. Specifically, it is executed before the standard system call prologue. In a sense, this means that we are executing in kernel mode, but don't consider ourselves to have entered the kernel. This may sound esoteric, but it has concrete implications for the brand-specific code. The brand code cannot take any locks, cannot do any I/O, or do anything else that might cause the thread to block. This means that the brand code can only do the simplest computations or transformations before returning to userspace or to the standard system call flow.</p><p>As described below, the 'lx' brand returns immediately to userspace, where the bulk of the emulation takes place. To implement a brand in the kernel, the interposition routine could transform the incoming system call into a brand() system call and return to the normal system call path. After executing the standard system call prologue, control would be vectored to the brand's xxx_brandsys() routine, where the emulation could be carried out.</p><h5 id="H2.2.3OtherInterpositionPoints"><span>2.2.3 Other Interposition Points</span></h5><p>&nbsp;Other interposition points will be placed in the code paths for process creation/exit, thread creation/teardown, signal delivery, and so on.</p><p>&nbsp;The interposition points are identified by means of a pair of ops vectors (one generic and one platform-specific), similar to those used by VFS for filesystems and the VM subsystem for segments. The generic ops vector used by BrandZ is shown below:</p><pre>

struct brand_ops {
        int     (*b_brandsys)(int, int64_t *, uintptr_t, uintptr_t,
                uintptr_t, uintptr_t, uintptr_t, uintptr_t);
        void    (*b_setbrand)(struct proc *);
        void    (*b_copy_procdata)(struct proc *, struct proc *);
        void    (*b_proc_exit)(struct proc *, klwp_t *);
        void    (*b_exec)();
        void    (*b_lwp_setrval)(klwp_t *, int, int);
        void    (*b_shmexit)(struct proc *);
        int     (*b_initlwp)(klwp_t *);
        void    (*b_forklwp)(klwp_t *, klwp_t *);
        void    (*b_freelwp)(klwp_t *);
        void    (*b_lwpexit)(klwp_t *);
        int     (*b_elfexec)(struct vnode *vp, struct execa *uap,
            struct uarg *args, struct intpdata *idata, int level,
            long *execsz, int setid, caddr_t exec_file,
            struct cred *cred);
};

</pre><p>&nbsp;A brief description of each entry follows:</p><ul><li><span class="box code">b_brandsys</span>: Routine that implements a per-brand 'brandsys' system call that can be used for any brand-specific functionality.</li><li><span class="box code">b_setbrand</span>: Used to associate a new brand type with a process. This is called when the zone's init process is hand-crafted, or when a process uses zone_enter() to enter a branded zone.</li><li><span class="box code">b_copy_procdata</span>: Copies per-process brand data at fork time.</li><li><span class="box code">b_proc_exit</span>: Called at process exit time to free any brand-specific process state.</li><li><span class="box code">b_exec</span>: Called at process exec time to initialize any brand-specific process state.</li><li><span class="box code">b_lwp_setrval</span>: set the syscall() return value for the newly created lwp before the creating fork() system call returns.</li><li><span class="box code">b_shmexit</span>: Called when a shared memory segment is detached from an exiting branded process.</li><li><span class="box code">b_initlwp</span>: Called by <span class="box code">lwp_create()</span> to initialize any brand-specific per-lwp data.</li><li><span class="box code">b_forklwp</span>: Called by <span class="box code">forklwp()</span> to copy any brand-specific per-lwp data from the parent to child lwps.</li><li><span class="box code">b_freelwp</span>: Called by <span class="box code">lwp_create()</span> on error to do any brand-specific cleanup.</li><li><span class="box code">b_lwpexit</span>: Called by <span class="box code">lwp_exit()</span> to do any brand-specific cleanup.</li><li><span class="box code">b_elfexec</span>: Called to load a branded executable.</li></ul><p>&nbsp;The x86-specific ops vector is:</p><pre>

struct brand_mach_ops {
        void    (*b_sysenter)(void);
        void    (*b_int80)(void);
        void    (*b_int91)(void);
        void    (*b_syscall)(void);
        void    (*b_syscall32)(void);
        greg_t  (*b_fixsegreg)(greg_t, model_t);
};

</pre><p>&nbsp;The first 5 entries of this vector allow a brand to override the standard system call paths with their own interpretations. The final entry protects Solaris from brands that make different use of the segment registers in userspace, and vice-versa.</p><p>&nbsp;The SPARC-specific ops vector is:</p><pre>

struct brand_mach_ops {
        void    (*b_syscall)(void);
        void    (*b_fasttrap)(void);
};

</pre><p>Of these routines, only the <span class="box code">int80</span> entry of the x86 vector is needed for the initial <em>lx</em> brand. The other entries are included for completeness and are only used by a trivial 'Solaris 10' brand used for basic testing on SPARC platforms.</p><p>These ops vectors are sufficient for the initial Linux brand. Adding support for a new Linux distribution based on the 2.4 kernel can probably also be done without modifying this interface. However, it is likely that adding any new brand that is substantially different from the initial Linux brand will require additional interposition points. For example, adding support for a 2.6-based Linux distribution could require modifications. Supporting a whole new operating system such as FreeBSD or Apple's OS X would almost certainly require modifying this interface.</p><h3 id="H3.ThelxBrand"><span>3. The <em>lx</em> Brand</span></h3><h4 id="H3.1BrandsandDistributions"><span>3.1 Brands and Distributions</span></h4><p>The <em>lx</em> Brand is intended to emulate the kernel interfaces expected by the Red Hat Enterprise Linux 3 userspace. The freely available CentOS 3 distribution is built from the same SRPMs as RHEL, so it is expected to work as well.</p><p>The interface between the kernel and userspace is largely encapsulated by the version of <em>glibc</em> that ships with the distribution. As such, the interface we emulate will likely support other distributions that make use of glibc 2.3.2. Debian 3.1 also uses this version of glibc, so adding support for that distro to <em>lx</em> should be straightforward.</p><p>The further removed one gets from that version of <em>glibc</em>, the less likely it is that the current <em>lx</em> brand will be able to support that distro. For example, RHEL 4 is based on glibc 2.4.7, which represents a significant change to glibc. While adding support for RHEL 4 would likely require additional development work, we expect that the work could be done within the scope of the <em>lx</em> brand. In the unlikely event that the <em>lx</em> brand could not be extended to support RHEL 4, we would introduce a new <em>lx4</em> brand.</p><p>Finally, it should be noted that supporting a new distribution will always require a new install script. For RPM-based distributions, it might be sufficient to update the existing scripts with new package lists. Adding support for distributions such as Debian, which do not use the RPM packaging format, will require entirely new install scripts to be created. It is relatively simple to have a variety of different install scripts within a single brand, so simply changing the packaging format does not require the creation of a new brand.</p><h4 id="H3.2InstallationofaLinuxzone"><span>3.2 Installation of a Linux zone</span></h4><p>&nbsp;Most Linux distributions' native installation procedures start by probing and configuring the hardware on the system and partitioning the hard drives. The user then selects which packages to install and sets configuration variables such as the hostname and IP address. Finally the installer lays out the filesystems, installs the packages, modifies some configuration files, and reboots.</p><p>&nbsp;When installing a Linux zone, we can obviously skip the device probing and disk partitioning. For the remainder of the installation procedure, there are several different approaches we could take.</p><ul><li>One approach is to execute a distribution's installation tool directly. Most of them are based on shell scripts, Python, or some other interpreted language, so we could theoretically run the tools before having a Linux environment running. This approach relies on the existing install tools being fairly robust and would be hard to sustain between releases if the tools change.</li><li>Another option is to develop our own package installation tool, which extracts the desired software from a standard set of distribution media and copies it into the zone.</li><li>A third option would be to adopt a flasharchive-like approach, in which we would simply unpack a prebuilt tarball or cpio image into the target filesystem. This image could be built by us, or by a customer that already had an installed Linux system. If we were to build this image ourselves, this approach would give us complete control over the final image and and allow us to manually handle any particularly ugly early-stage installation issues. This would also make it trivial for a customer to "just try it out," an approach that has been successful for VMware, Usermode Linux, and QEMU.</li></ul><p>It is our intention to support the last two options.</p><p>We will provide an installation script that will extract a known set of RPMs from a known set of Red Hat or CentOS installation media. We will also allow a zone to be installed from a user-specified tarball. We will document how a user can construct an installable tarball that can be used for flasharchive-like installations.</p><h4 id="H3.3.ExecutionofLinuxBinaries"><span>3.3. Execution of Linux Binaries</span></h4><p>&nbsp;When executing Linux binaries, we follow the same architectural approach taken by the SunOS(tm) Binary Compatibility Project (SBCP), which provides support for pre-Solaris 2.0 binaries.</p><h5 id="H3.3.1.LoadingLinuxBinaries"><span>3.3.1. Loading Linux Binaries</span></h5><p>&nbsp;When a non-native ELF binary is execed inside a branded zone, the brand's exec handler is given control. The <span class="box code">lx</span> brand-specific exec handler execs the brand's Solaris support library (akin to the 'sbcp' command) and maps the non-native ELF executable and its interpreter into the address space.</p><p>&nbsp;The handler also places all the extra information needed to exec the Linux binary on the stack in the form of aux vector entries. Specifically, the handler passes the following values to the support library via the aux vector:</p><pre>

AT_SUN_BRAND_BASE:      Base address of non-native interpeter
AT_SUN_BRAND_LDDATA:    Address of non-native interpreter's debug data
AT_SUN_BRAND_LDENTRY:   Non-native interpreter's entry point
AT_SUN_BRAND_PHDR:      Non-native executable ELF information needed by
AT_SUN_BRAND_PHENT:     non-native interpreter
AT_SUN_BRAND_PHNUM:
AT_SUN_BRAND_ENTRY:     Entry point of non-native executable

</pre><h5 id="H3.3.2.RunningLinuxBinaries"><span>3.3.2. Running Linux Binaries</span></h5><p>Rather than executing the Linux application directly, the exec handler starts the program execution in the brand support library. The library then runs whatever initialization code it needs before starting the Linux application.</p><p>&nbsp;For its initialzation, the <span class="box code">lx</span> brand library uses the <span class="box code">brandsys(2)</span> system call to pass the following data structure to the kernel:</p><pre>

typedef struct lx_brand_registration {
        uint_t lxbr_version;            /* version number */
        void *lxbr_handler;             /* base address of handler */
        void *lxbr_traceflag;           /* address of trace flag */
} lx_brand_registration_t;

</pre><p>&nbsp;This structure contains a version number, ensuring that the brand library and the brand kernel module are compatibile with one another. It also contains two addresses in the application's address space: the starting address of the system call emulation code and the address of a flag indicating whether the process is being traced. The use of these two addresses are discussed in sections 3.4 and 3.9 respectively.</p><p>&nbsp;Once the support library has finished initialization, it fixes up the aux vector for the Linux interpreter to run, and jumps to the interpreter's entry point. The brand's exec handler replaces the standard aux vector entries with the corresponding values above, clears the above vectors (by setting their type to AT_IGNORE), resets the stack to its pre-Solaris-linker state, and then jumps to the non-native interpreter which then runs the executable as it would on its own native system.</p><p>&nbsp;The advantages of this design are:</p><ul><li>No modifications to the Solaris runtime linker are necessary.</li><li>Virtually all knowledge of branding is isolated to the kernel brand module and userland brand support library.</li><li>It keeps us aligned with the de-facto standard for non-native emulation established with SunOS 4 BCP.</li></ul><h4 id="H3.4.SystemCallEmulation"><span>3.4. System Call Emulation</span></h4><p>&nbsp;The most common method for applications to interact with the operating system is through system calls. Therefore, the bulk of the work required to support the execution of foreign binaries is to emulate the system call interface to which those binaries have been written.</p><p>&nbsp;Linux applications do not use the <span class="box code">syscall<span style="color: #666666; ">/</span>sysenter</span> instructions. Instead, they use interrupt #80 to initiate a system call. Because Solaris has no current handler for that interrupt, one had to be added as part of this project. As noted above, the handler in the core Solaris code does nothing but pass control to the int80_handler routine in the brand module. It is then up to that brand to interpret and execute the system call.</p><p>&nbsp;As with executable launching, the approach we have chosen to take is the one originally implemented by the SBCP. In this model, the trap handler in the kernel is nothing more than a trampoline, redirecting the execution of the system call to a library in userspace. The library performs any necessary data mangling and then calls the proper native system call. Ideally, this method would require almost no code in the kernel and would have no impact whatsoever on the behavior of a system with no SunOS binaries running.</p><p>&nbsp;In practice, the user-space approach turns out to be less clean and self-contained for Linux than for the original SunOS project. In that case, the binary model being emulated was simpler than Solaris, less fully featured, and still closely related. In the Linux case, there are system calls that must be supported that do not have obvious equivalents in Solaris (e.g., futex()) and there are differences in fundamental OS abstractions (Linux 'threads' are almost full blown processes, each with its own PID).</p><p>&nbsp;The steps involved in emulating a fairly straightforward Linux system call are as follows:</p><ol><li>The Linux application marshalls parameters into registers and issues an <span class="box code">int80</span></li><li>The Solaris int80 handler checks to see if the process is branded. An unbranded process will continue along the standard code path. For <span class="box code">int80</span>, there is no standard behavior so the process would die with a General Protection fault. Thus, a Solaris application cannot successfully execute any Linux system calls.</li><li>Solaris passes control to the brand-specific routine indicated in the brandops structure.</li><li>The <em>lx</em> brand module immediately trampolines into the user-space emulation library.</li><li>The emulation library does any necessary argument manipulation and calls the appropriate Solaris system call(s).</li><li>Solaris carries out the system call and returns to the brand library.</li><li>The brand library performs any necessary manipulation of the return values and error code.</li><li>The brand library returns directly to the Linux application; it does not return through the kernel.</li></ol><p>The diagram below illustrates these steps:</p><p> <img src="https://markebrooks.github.io/bin/download/Community+Group+brandz/design/syscallprocess.gif?width=693&amp;height=382" alt="syscall_process.gif" width="693" height="382"/></p><p>&nbsp;Each Linux system call can be divided into one of three types: pass-through, simple emulation, and complex emulation.</p><h5 id="H3.4.1Pass-Through"><span>3.4.1 Pass-Through</span></h5><p>&nbsp;A pass-through call is one that requires no data transformation and for which the Solaris 10 semantics match those of the Linux system call. These can be implemented in userland by immediately calling the equivalent system call.</p><p>&nbsp;For example:</p><pre>

int
lx_read(int fd, void *buf, size_t bytes)
{
        int rval;

        rval = read(fd, buf, bytes);

        return (rval &lt; 0 ? -errno : rval);
}

</pre><p>&nbsp;Other examples of pass-through calls are close(), write(), mkdir(), and munmap().</p><p>&nbsp;Although the arguments to the system call are identical, the method for returning an error to the caller differs between Solaris and Linux. In Solaris, the system call returns -1 and the error number is stored in the thread-specific variable <span class="box code">errno</span>. In Linux, the error number is returned as part of the <span class="box code">rval</span>.</p><p>&nbsp;There are also differences in the error numbers between Solaris and Linux. The <span class="box code">lx_read()</span> routine is called by <span class="box code">lx_emulate()</span>, which handles the translation between Linux and Solaris error codes for all system calls.</p><h5 id="H3.4.2SimpleEmulation"><span>3.4.2 Simple Emulation</span></h5><p>&nbsp;One step up in complexity is a simple emulated system call. This is a call where either the original arguments and/or return value require some degree of simple transformation from the Solaris equivalent. Simple transformations include changing data types or the moving of values into a structure. These calls can be built entirely from standard Solaris system calls and userland transformations.</p><p>&nbsp;For example:</p><pre>

int
lx_uname(uintptr_t p1)
{
        struct lx_utsname *un = (struct lx_utsname *)p1;
        char buf[LX_SYS_UTS_LN + 1];

        strlcpy(un-&gt;sysname, LX_SYSNAME, LX_SYS_UTS_LN);
        strlcpy(un-&gt;release, lx_release, LX_SYS_UTS_LN);
        strlcpy(un-&gt;version, LX_VERSION, LX_SYS_UTS_LN);
        strlcpy(un-&gt;machine, LX_MACHINE, LX_SYS_UTS_LN);
        gethostname(un-&gt;nodename, sizeof (un-&gt;nodename));
        if ((sysinfo(SI_SRPC_DOMAIN, buf, LX_SYS_UTS_LN) &lt; 0))
                un-&gt;domainname[0] = '\0';
        else
                strlcpy(un-&gt;domainname, buf, LX_SYS_UTS_LN);
        return (0);
}

</pre><p>&nbsp;Other examples of simple emulated calls are stat(), mlock(), and getdents().</p><h5 id="H3.4.3ComplexEmulation"><span>3.4.3 Complex Emulation</span></h5><p>&nbsp;The calls requiring the most in-kernel support are the complex emulated system calls. These are calls that:</p><ul><li>Require significant transformation to input arguments or return values</li><li>Are partially or wholly unique within the <em>lx</em> brand implementation</li><li>Possibly require a new system call that has no underlying Solaris counterpart</li></ul><p>&nbsp;Some examples of complex emulated calls are <span class="box code">clone()</span>, <span class="box code">sigaction()</span>, and <span class="box code">futex()</span>. The implementation of the <span class="box code">clone()</span> system call is described below.</p><h4 id="H3.5OtherIssues"><span>3.5 Other Issues</span></h4><h5 id="H3.5.1LinuxThreading"><span>3.5.1 Linux Threading</span></h5><p>&nbsp;Linux implements threads via the <span class="box code">clone()</span> system call. Among the arguments to the call is a set of flags, four of which determine the level of sharing within the address space: CLONE_VM, CLONE_FS, CLONE_FILES, and CLONE_SIGHAND. When all four flags are clear, the clone is equivalent to a fork; when they are all set, it is the equivalent to creating another lwp in the address space. Any other combination of flags reflects a thread/process construct that does not match any existing Solaris model. Since these other combinations are rarely, if ever, encountered on a system, this project will not be adding the abstractions necessary to support them.</p><p>The following table lists all of the flags for the <span class="box code">clone(2)</span> system call, and whether the 'lx' brand supports them. If an applications uses an unsupported flag, or combination of flags, a detailed error message is emitted and ENOTSUP is returned.</p><table><tr><th scope="col">Flag</th><th scope="col">Supported?</th></tr><tr><td>&nbsp;CLONE_VM&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_FS&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_FILES&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_SIGHAND&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_PID&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_PTRACE&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_PARENT&nbsp;</td><td>&nbsp;Partial. Not supported for fork()-style clone() operations.</td></tr><tr><td>&nbsp;CLONE_THREAD&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_SYSVSEM&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_SETTLS&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_PARENT_SETTID&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_CHILD_CLEARTID&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_DETACH&nbsp;</td><td>&nbsp;Yes</td></tr><tr><td>&nbsp;CLONE_CHILD_SETTID&nbsp;</td><td>&nbsp;Yes</td></tr></table><p>When an application uses <span class="box code">clone(2)</span> to fork a new process, the <span class="box code">lx_clone()</span> routine simply calls <span class="box code">fork1(2)</span>. When an application uses <span class="box code">clone(2)</span> to create a new thread, we call the <span class="box code">thr_create(3C)</span> routine in the Solaris <span class="box code">libc</span>.</p><p>&nbsp;The Linux application provides the address of a function at which the new thread should begin executing as an argument to the system call. However, the Linux kernel does not actually start execution at that address. Instead, the kernel essentially does a <span class="box code">fork(2)</span> of a new thread which, like a forked process, starts with exactly the same state as the parent thread. As a result, the new thread starts executing in the middle of the <span class="box code">clone(2)</span> system call, and it is the <span class="box code">glibc</span> wrapper that causes it to jump to the user-specified address.</p><p>&nbsp;This Linux implementation detail means that when we call <span class="box code">thr_create(3C)</span> to create our new thread, we cannot provide the user's start address to that routine. Instead, all new Linux threads begin by executing a routine that we provide, called <span class="box code">clone_start()</span>. This routine does some final initialization, notifies the brand's kernel module that we have created a new Linux thread, and then returns to <span class="box code">glibc</span>.</p><p>&nbsp;A by-product of threads implementation in Linux is that every thread has a unique PID. To mimic this behavior in the <em>lx</em> brand, every thread created by a Linux binary reserves a PID from the PID list. This reservation is performed as part of the <span class="box code">clone_start()</span> routine.</p><p>&nbsp;This reserved PID is never seen by Solaris processes, but it is used by Linux processes. When a Linux thread calls <span class="box code">getpid(2)</span>, it is returned the standard Solaris PID of process. When it calls <span class="box code">gettid(2)</span>, it is returned the PID that was reserved at thread creation time. Similarly, <span class="box code">kill(2)</span> sends a signal to the entire process represented by the supplied PID, while <span class="box code">tkill(2)</span> sends a signal to the specific thread represented by the supplied PID.</p><p>The Linux thread model supported by modern RedHat systems is provided by the Native Posix Threads Library (NPTL). NPTL uses three consecutive descriptor entries in the Global Descriptor Table (GDT) to manage thread local storage. One of the arguments to the <span class="box code">clone()</span> is an optional descriptor entry for TLS. More commonly used is the <span class="box code">set_thread_area()</span> system call, which takes a descriptor as an argument and returns the entry number in the GDT in which it has been stored. The NPTL then uses this to initialize the <span class="box code"><span style="font-weight: italic; color: #408080; ">%gs</span></span> register. The descriptors are per thread, so they have to be stored in per thread storage and the GDT entries must be re-initialized on context switch. This is done via a <span class="box code">restore</span> ctx operation.</p><p>&nbsp;Since both NPTL and the Solaris <span class="box code">libc</span> rely on <span class="box code"><span style="font-weight: italic; color: #408080; ">%gs</span></span> to access per-thread data, we have added code to virtualize its usage. The first thing our user-space emulation library does is:</p><pre>

        /*
         * Save the Linux libc's %gs and switch to the Solaris libc's %gs
         * segment so we have access to the Solaris errno, etc.
         */
        pushl   %gs
        pushl   $LWPGS_SEL
        popl    %gs

</pre><p>&nbsp;This sequence ensures that we always enter our Solaris code using the well-known value used for our <span class="box code"><span style="font-weight: italic; color: #408080; ">%gs</span></span>. We also stash the current value of <span class="box code"><span style="font-weight: italic; color: #408080; ">%gs</span></span> on the stack, so we can restore it prior to returning to Linux code.</p><h5 id="H3.5.2EFAULT2FSIGSEGV"><span>3.5.2 EFAULT/SIGSEGV</span></h5><p>&nbsp;If the user-space emulation library were to access an argument from a system call which had an invalid address, a SIGSEGV signal would be generated. For proper Linux emulation, the desired result in this situation is to generate an error return from the system call with an EFAULT errno.</p><p>&nbsp;To deliver the expected behavior, we will introduce a new system call (<span class="box code">uucopy()</span>), which copies data from one user address to another. Any attempt to use an illegal address will cause the call to return an error. Otherwise, the data will be copied as if we had performed a standard <span class="box code">bcopy()</span> operation.</p><p>&nbsp;For example:</p><pre>

  int
  lx_system_call(int *arg)
  {
        int     local_arg;
        int     rval;

        /*
         * catch EFAULT
         */
        if ((rval = uucopy(arg, &amp;arg, sizeof (int))) &lt; 0)
                return (rval);          /* errno is set to EFAULT */

        /*
         * transform the arg, now in local_arg, to Solaris format
         */
        return (solaris_system_call(&amp;local_arg));
  }

</pre><p>&nbsp;This functionality seems to be generically useful, so the <span class="box code">uucopy()</span> call will be implemented in <span class="box code">libc</span>, where it will be available to any application.</p><p>&nbsp;If the overhead imposed by this system call dramatically limits performance, we may include an environment variable that causes the brand library to perform a standard userspace copy rather than the kernel-based copy. Setting this variable would lead to higher performance, but some system calls would segfault rather than returning EFAULT.</p><h4 id="H3.6SignalHandling"><span>3.6 Signal Handling</span></h4><p>&nbsp;Delivering signals to a Linux process is complicated by differences in signal numbering, stack structure and contents, and the action taken when a signal handler exits. In addition, many signal-related structures, such as sigset_ts, vary between Solaris and Linux.</p><p>&nbsp;The simplest transformation that must be done when sending signals is to translate between Linux and Solaris signal numbers.</p><p>Major signal number differences between Linux and Solaris|=Number|=Linux|=Solaris</p><table><tr><td>&nbsp;10&nbsp;</td><td>&nbsp;SIGUSR1&nbsp;</td><td>&nbsp;SIGBUS</td></tr><tr><td>&nbsp;12&nbsp;</td><td>&nbsp;SIGUSR2&nbsp;</td><td>&nbsp;SIGSYS</td></tr><tr><td>&nbsp;16&nbsp;</td><td>&nbsp;SIGSTKFLT&nbsp;</td><td>&nbsp;SIGUSR1</td></tr><tr><td>&nbsp;17&nbsp;</td><td>&nbsp;SIGCHLD&nbsp;</td><td>&nbsp;SIGUSR2</td></tr><tr><td>&nbsp;18&nbsp;</td><td>&nbsp;SIGCONT&nbsp;</td><td>&nbsp;SIGCHLD</td></tr><tr><td>&nbsp;19&nbsp;</td><td>&nbsp;SIGSTOP&nbsp;</td><td>&nbsp;SIGPWR</td></tr><tr><td>&nbsp;20&nbsp;</td><td>&nbsp;SIGTSTP&nbsp;</td><td>&nbsp;SIGWINCH</td></tr><tr><td>&nbsp;21&nbsp;</td><td>&nbsp;SIGTTIN&nbsp;</td><td>&nbsp;SIGURG</td></tr><tr><td>&nbsp;22&nbsp;</td><td>&nbsp;SIGTTOU&nbsp;</td><td>&nbsp;SIGPOLL</td></tr><tr><td>&nbsp;23&nbsp;</td><td>&nbsp;SIGURG&nbsp;</td><td>&nbsp;SIGSTOP</td></tr><tr><td>&nbsp;24&nbsp;</td><td>&nbsp;SIGXCPU&nbsp;</td><td>&nbsp;SIGTSTP</td></tr><tr><td>&nbsp;25&nbsp;</td><td>&nbsp;SIGXFSZ&nbsp;</td><td>&nbsp;SIGCONT</td></tr><tr><td>&nbsp;26&nbsp;</td><td>&nbsp;SIGVTALARM&nbsp;</td><td>&nbsp;SIGTTIN</td></tr><tr><td>&nbsp;27&nbsp;</td><td>&nbsp;SIGPROF&nbsp;</td><td>&nbsp;SIGTTOU</td></tr><tr><td>&nbsp;28&nbsp;</td><td>&nbsp;SIGWINCH&nbsp;</td><td>&nbsp;SIGVTALARM</td></tr><tr><td>&nbsp;29&nbsp;</td><td>&nbsp;SIGPOLL&nbsp;</td><td>&nbsp;SIGPROF</td></tr><tr><td>&nbsp;30&nbsp;</td><td>&nbsp;SIGPWR&nbsp;</td><td>&nbsp;SIGXCPU</td></tr><tr><td>&nbsp;31&nbsp;</td><td>&nbsp;SIGSYS&nbsp;</td><td>&nbsp;SIGXFSZ</td></tr></table><p>&nbsp;When a Linux process sends a signal using the <span class="box code">kill(2)</span> system call, we translate the signal into the Solaris equivalent before handing control off to the standard signalling mechanism. When a signal is delivered to a Linux process, we translate the signal number from Solaris back to Linux. Translating signals both at generation and at delivery time ensures both that Solaris signals are sent properly to Linux applications and that signals' default behavior works as expected.</p><p>&nbsp;One issue is that Linux supports 32 real time signals, with <span class="box code">SIGRTMIN</span> typically starting at or near 32 (<span class="box code">SIGRTMIN</span>) and proceeding to 63 (<span class="box code">SIGRTMAX</span>) (<span class="box code">SIGRTMIN</span>) is "at or near" 32 because glibc usually "steals" one ore more of these signals for its own internal use, adjusting <span class="box code">SIGRTMIN</span> and <span class="box code">SIGRTMAX</span> as needed.) Conversely, Solaris actively uses signals 32-40 for other purposes and and only supports 7 realtime signals, in the range 41 (<span class="box code">SIGRTMIN</span>) to 48 (<span class="box code">SIGRTMAX</span>).</p><p>&nbsp;At present, attempting to translate a Linux signal greater than 39 (corresponding to the maximum real time signal number Solaris can support) will generate an error. We have not yet found an application that attempts to send such a signal.</p><p>&nbsp;Branded processes are set up to ignore any Solaris signal for which there is no direct Linux analog, preventing the delivery of untranslatable signals from the global zone.</p><h5 id="H3.6.1SignalDelivery"><span>3.6.1 Signal Delivery</span></h5><p>&nbsp;To support user-level signal handlers, BrandZ uses a double layer of indirection to process and deliver signals to branded threads.</p><p>&nbsp;In a normal Solaris process, signal delivery is interposed on for any thread registering a signal handler by libc. Libc needs to do various bits of magic to provide thread-safe critical regions, so it registers its own handler, named <span class="box code">sigacthandler</span>, using the <span class="box code">sigaction(2)</span> system call. When a signal is received, <span class="box code">sigacthandler()</span> is called, and after some processing, libc calls the user's signal handler via a routine named <span class="box code">call_user_handler()</span>.</p><p>&nbsp;Adding a Linux branded thread to the mix complicates things somewhat. First, when a thread receives a signal, it could be running with a Linux value in the x86 %gs segment register as opposed to the value Solaris threads expect; if control were passed directly to Solaris code, such as libc's <span class="box code">sigacthandler()</span>, that code would experience a segmentation fault the first time it tried to dereference a memory location using %gs.</p><p>&nbsp;Second, the signal number translation referenced above must take place. (As an example, <span class="box code">SIGCONT</span> is equivalent in function in Linux and Solaris, but Linux' <span class="box code">SIGCONT</span> is signal 18 while Solaris' is signal <em>25</em>.) Further, as was the case with Solaris libc, before the Linux signal handler is called, the value of the %gs segment register must be restored to the value Linux code expects.</p><p>&nbsp;This need to translate signal numbers and manipulate the %gs register means that while with standard Solaris libc, following a signal from generation to delivery looks something like:</p><pre>

    kernel -&gt;
        sigacthandler() -&gt;
            call_user_handler() -&gt;
                user signal handler

</pre><p>&nbsp;for BrandZ Linux threads, this instead would look like this:</p><pre>

    kernel -&gt;
        lx_sigacthandler() -&gt;
            sigacthandler() -&gt;
                call_user_handler() -&gt;

                        lx_call_user_handler() -&gt;
                            Linux user signal handler

</pre><p>&nbsp;The new addtions are:</p><ul><li><strong>lx_sigacthandler()</strong><br/>&nbsp;This routine is responsible for setting the %gs segment register to the value Solaris expects, and for jumping to Solaris' libc signal interposition handler, sigacthandler().</li><li><strong>lx_call_user_handler()</strong><br/>&nbsp;This routine is responsible for translating Solaris signal numbers to their Linux equivalents, building a Linux signal stack based on the information Solaris has provided, and passing the stack to the registered Linux signal handler. It is, in effect, the Linux thread equivalent to libc's <span class="box code">call_user_handler</span>.</li></ul><p>&nbsp;Installing <span class="box code">lx_sigacthandler()</span> is a bit tricky, as normally libc's <span class="box code">sigacthandler()</span> routine is hidden from user programs. To facilitate this, a new private function was added to libc, <span class="box code">setsigaction()</span>:</p><pre>

    void setsigacthandler(void (*new_handler)(int, siginfo_t *, void *), void (**old_handler)(int, siginfo_t *, void *))

</pre><p>&nbsp;The routine works by modifying the per-thread data structure that libc already maintains that keeps track of the address of its own interposition handler with the address passed in; the old handler's address is set in the pointer pointed to by the second argument, if it is non-NULL, mimicking the behavior of <span class="box code">sigaction()</span> itself. Once <span class="box code">setsigacthandler()</span> has been executed, all future branded threads this thread may create will automatically have the proper interposition handler installed as the result of a normal <span class="box code">sigaction()</span> call.</p><p>&nbsp;Note that none of this interposition is necessary unless a Linux thread registers a user signal handler, because the default action for all signals is the same between Solaris and Linux save for one signal, <span class="box code">SIGPWR</span>. For this reason, BrandZ always installs its own internal signal handler for <span class="box code">SIGPWR</span> that translates the action to the Linux default, to terminate the process. (Solaris' default action is to ignore <span class="box code">SIGPWR</span>.)</p><p>&nbsp;It is also important to note that when signals are not translated, BrandZ relies upon code interposing upon the <span class="box code">wait(2)</span> system call to translate signals to their proper values for any Linux threads retrieving the status of others. So, while the Solaris signal number for a particular signal is set in the data structures for a process (and would be returned as the result of, for example, <span class="box code">WTERMSIG()</span>), the BrandZ interposition upon <span class="box code">wait(2)</span> is responsible for translating the value <span class="box code">WTERMSIG()</span>, and would return from a Solaris signal number to the appropriate Linux value.</p><h5 id="H3.6.2ReturningFromSignals"><span>3.6.2 Returning From Signals</span></h5><p>The process of returning to an interrupted thread of execution from a user signal handler is entirely different between Solaris and Linux. While Solaris generally expects to set the context to the interrupted one on a normal return from a signal handler, in the normal case Linux instead sets the return address from the signal handler to point to code that calls one of two specific Linux system calls, <span class="box code">sigreturn(2)</span> or <span class="box code">rt_sigreturn(2)</span>. Thus, when a Linux signal handler completes execution, instead of returning through what would, in Solaris' libc be a call to <span class="box code">setcontext(2)</span>, the <span class="box code">sigreturn(2)</span> or <span class="box code">rt_sigreturn(2)</span> Linux system calls are responsible for accomplishing much the same thing.</p><p>&nbsp;This trampoline code (for a call to <span class="box code">sigreturn(2)</span>) looks like this:</p><pre>

pop   %eax
mov   LX_SYS_sigreturn, %eax
int   $0x80

</pre><p>&nbsp;such that when the Linux user signal handler is eventually called, the stack looks like this:</p><table><tr><td>&nbsp;Pointer to <em>sigreturn</em> trampoline code</td></tr><tr><td>&nbsp;Linux signal number</td></tr><tr><td>&nbsp;Pointer to Linux siginfo_t</td></tr><tr><td>&nbsp;Pointer to Linux ucontext_t</td></tr><tr><td>&nbsp;Linux ucontext_t</td></tr><tr><td>&nbsp;Linux fpstate</td></tr><tr><td>&nbsp;Linux siginfo_t</td></tr></table><p>&nbsp;BrandZ takes the approach of intercepting the Linux <span class="box code">sigreturn(2)</span> (or <span class="box code">rt_sigreturn(2)</span>) system call in order to turn it into a return through the libc call stack that Solaris expects. This is done by the <span class="box code">lx_sigreturn()</span> or <span class="box code">lx_rt_sigreturn()</span> routines, which remove the Linux signal frame from the stack and pass the resulting stack pointer to another routine, <span class="box code">lx_sigreturn_tolibc()</span>, which makes libc believe the user signal handler it had called returned.</p><p>&nbsp;When control then returns to libc's <span class="box code">call_user_handler()</span> routine, a <span class="box code">setcontext(2)</span> will be done that (in most cases) returns the thread executing the code back to the location originally interrupted by receipt of the signal.</p><p>&nbsp;One final complication in this process is the restoration of the %gs segment register when returning from a user signal handler. Prior to BrandZ, Solaris' libc forced the value of %gs to a known value when calling <span class="box code">setcontext()</span> to return to an interrupted thread from a user signal handler (as libc uses %gs internally as a pointer to curthread, it is a way of ensuring a good "known value" for curthread.)</p><p>&nbsp;Since BrandZ requires that setcontext() restore a Linux value for %gs when returning from a Linux signal handler, we made this forced restoration optional on a per-process basis. This was accomplished by means of a new private routine to libc:</p><pre>

    void set_setcontext_enforcement(int on)

</pre><p>&nbsp;By default, the "curthread pointer" value enforcement is enabled. When this routine is called with an argument of '0', the mechanism is disabled for this process.</p><p>&nbsp;Shutting off this mechanism will not have any correctness or security implications. Writing to the %gs segment register is not a privileged operation and as such %gs can be set to any value at any time by user code. The only drawback to disabling the mechanism is that if a bad value is set for %gs, the broken application will likely segmentation fault deep within libc.</p><h3 id="H3.7.Deviceandsupport"><span>3.7. Device and <span class="box code">ioctl()</span> support</span></h3><h4 id="H3.7.1DeterminingWhichDevicestoSupport"><span>3.7.1 Determining Which Devices to Support</span></h4><p>&nbsp;Our investigation showed that he following devices are the minimum set required to support Linux branded zones:</p><pre>

        /dev/null
        /dev/zero
        /dev/ptmx
        /dev/pts/*
        /dev/tty
        /dev/console
        /dev/random
        /dev/urandom
        /dev/fd/*

</pre><p>&nbsp;The following devices were considered, but aren't actually necessary for Linux branded zones.</p><p><span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>ttyd?</span> - These are serial port devices.</p><p><span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>pty[pqr]?</span> and <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>tty[pqr]?</span> - These are old style terminal devices provided for compatibility purposes. They currently do not exist in native non-global zones. The Unix98 specification replaced these devices with <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>ptmx</span> and <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>pts<span style="color: #666666; ">/*</span></span>, which have been used as the standard terminal devices for Solaris and Linux for a long time. While these devices do still exist on Red Hat 2.4 systems, they have officially been unsupported since Linux 2.1.115. An inspection of a Linux 2.4 system didn't reveal any applications that were actually using these devices.</p><h5 id="H3.7.1.1NetworkingDevices"><span>3.7.1.1 Networking Devices</span></h5><p>&nbsp;Native Solaris non-global zones have a network interface that is visible (reported via ifconfig), but there are no actual network device nodes accessible via <span class="box code"><span style="color: #666666; ">/</span>dev</span>. Certain higher level network protocol devices are accessible in native zones:</p><pre>

        /dev/arp, /dev/icmp, /dev/tcp, /dev/tcp6, /dev/udp, /dev/udp6
        /dev/ticlts, /dev/ticots, /dev/ticotsord

</pre><p>Notably missing from the list above is:</p><pre>

        /dev/ip

</pre><p>&nbsp;Looking at a native Linux 2.4 system, we see that the following network devices exist:</p><pre>

        /dev/inet/egp, /dev/inet/ggp, /dev/inet/icmp, /dev/inet/idp
        /dev/inet/ip, /dev/inet/ipip, /dev/inet/pup, /dev/inet/rawip
        /dev/inet/tcp, /dev/inet/udp

</pre><p><span class="box code">Documentation<span style="color: #666666; ">/</span>devices.txt</span> describes all of these as 'iBCS-2 compatibility devices', so we will not be supporting them.</p><p>&nbsp;Additionally, Linux does not create <span class="box code"><span style="color: #666666; ">/</span>dev</span> entries for networking devices. Network interface names are mapped to kernel modules via aliases defined in <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>modules.conf</span>. Interface plumbing (via ifconfig) is all done via ioctls to sockets. Reporting status of interfaces (via ifconfig) is done either by socket ioctls or by accessing files in /proc/net/. Finally, network accesses (telnet and ping) are all done via socket calls.</p><p>&nbsp;This indicates that initial Linux zones networking support has no actual device requirements, but it does require ioctl translations. (This issue is addressed later in this document.) Given the lack of device-specific configuration, the current native zones network interface can be leveraged in Linux branded zones.</p><h4 id="H3.7.2Major2FMinorDeviceNumberMapping"><span>3.7.2 Major/Minor Device Number Mapping</span></h4><p>&nbsp;Linux has explicitly hardcoded knowledge about how major and minor device numbers map to drivers and paths. (See <span class="box code">Documentation<span style="color: #666666; ">/</span>devices.txt</span> in the Linux source.) But on Solaris, major device number to driver mapping is dynamically defined via <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>name_to_major</span>. Minor device number name space is managed by individual drivers.</p><p>&nbsp;Also, there is not a 1:1 major/minor device number mapping between Linux and Solaris devices nodes and emulation of the functionality provided by a given Linux driver might involve using multiple Solaris drivers. For example, in Linux, both <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>null</span> and <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>random</span> are implemented using the same driver, so both of these devices have the same major number. In Solaris, these devices are implemented with separate drivers, each with its own major number.</p><p>&nbsp;Major/minor device numbers are exposed to Linux applications in multiple places. Some examples are:</p><ul><li>the <span class="box code">stat(2)</span> / <span class="box code">statvfs(2)</span> family of system calls</li><li>the filesystem name space via <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>pts<span style="color: #666666; ">/*</span></span></li><li><span class="box code"><span style="color: #666666; ">/</span>proc<span style="color: #666666; ">/&lt;</span>pid<span style="color: #666666; ">&gt;/</span>stat</span></li><li>certain ioctls (specifically <span class="box code">LX_TIOCGPTN</span> )</li></ul><p>&nbsp;One important question to answer is, is this device number translation actually necessary? Are major and minor device numbers actually consumed by Linux applications, and if so, how? As it turns out, the answer to this question is unfortunately yes. <span class="box code">glibc<span style="color: #666666; ">'</span>s</span> <span class="box code">ptsname()</span> does "sanity checks" of pts paths to makes sure they have expected dev_t values. These "sanity checks" make assumptions about expected major <em>and</em> minor device values.</p><p>&nbsp;Therefore, we will be required to provide a device number mapping mechanism. For the required devices listed earlier, this gives us:</p><pre>

        Device          Solaris Driver  Linux Major/Minor
        ~------          ~--------------  ~-----------------
        /dev/null       mm              1 / 3
        /dev/zero       mm              1 / 5
        /dev/random     random          1 / 8
        /dev/urandom    random          1 / 9

        /dev/tty        sy              5 / 0
        /dev/console    zcons           5 / 1
        /dev/ptmx       ptm             5 / 2 [1]
        /dev/pts/*      pts             136 / * [2]

        Notes:
        [1] ptm is a clone device, so this translation is tricky.
            Basically, the /dev/ptmx node in a native zone actually
            points to the clone device.  But when an open is done
            on this device, the vnode that is returned actually corresponds
            to a ptm node (and not a clone node).This means that
            on a Solaris system, a stat of /dev/ptmx will return different
            dev_t values than an fstat(2) of an fd that was created by
            opening /dev/ptmx.  On Linux, both of these operations need to
            return the same result.  So once again, we are mapping
            multiple major/minor Solaris device numbers to a single
            Linux device number.

        [2] For pts devices, there should probably be no translation done
            for device minor node numbers.

</pre><h4 id="H3.7.3IoctlTranslationSupport"><span>3.7.3 Ioctl Translation Support</span></h4><h5 id="H3.7.3.1IoctlSupport-GeneralIssues"><span>3.7.3.1 Ioctl Support - General Issues</span></h5><p>&nbsp;A quick investigation shows that most of the required ioctl support isn't actually for devices at all. Most the necessary ioctls are for non-device filesystem nodes. Here's a list of the most obviously needed ioctls, broken up into categories of files that support these ioctls:</p><pre>

    1) All file ioctls (regular files, streams devices, sockets, fifos):
        FIONREAD, FIONBIO

    2) Streams file ioctls (Streams device, sockets, fifos):
        TCSBRK, TCXONC, TCFLSH, TIOCEXCL, TIOCNXCL, TIOCSPGRP,
        TIOCSTI, TIOCSWINSZ, TIOCMBIS, TIOCMBIC, TIOCMSET,
        TIOCSETD, FIOASYNC, FIOSETOWN, TCSETS, TCSETSW,
        TCSETSF, TCSETA, TCSETAW, TCSETAF, TIOCGPGRP, TCSBRKP

    3) Socket ioctls:
        FIOGETOWN, SIOCSPGRP, SIOCGPGRP, SIOCATMARK,
        SIOCGIFFLAGS, SIOCGIFADDR, SIOCGIFDSTADDR,
        SIOCGIFBRDADDR, SIOCGIFNETMASK, SIOCGIFMETRIC,
        SIOCGIFMTU, SIOCGIFCONF, SIOCGIFNUM

    4) Streams device - ptm
        TIOCGWINSZ, UNLKPT, LX_TIOCGPTN

    5) Streams /w ttcompat module - pts
        TIOCGETD

    6) Streams /w ldterm, ptem or ttcompat module - pts
        TCGETS

    7) Streams /w ldterm or ptem module - pts
        TCGETA

    8) Streams device - pts
        LX_TIOCSCTTY, LX_TIOCNOTTY

</pre><p>&nbsp;Most of these ioctls are streams ioctls, and since FIFOs and sockets are implemented via streams in Solaris, any FIFO or socket supports most of these ioctls. Of the 45 ioctls listed above, only 8 are actually device-specific ioctls.</p><p>&nbsp;This indicates that doing ioctl translations via layered drivers is not the best approach, since this would only address a minor subset of the total ioctls that need to be supported. Because supporting non-device ioctls will require the creation of a non-layered driver ioctl translation mechanism, it seems more appropriate to handle device ioctls via this same mechanism as well.</p><p>&nbsp;With this in mind, it's more interesting if the categories above are renamed based in terms of their vnode v_type and v_rdev values. If we do this, we get:</p><pre>

    1) VREG, VFIFO, VSOCK, VCHR[ptm, pts, sy, zcons]
    2) VFIFO, VSOCK, VCHR[ptm, pts, sy, zcons]
    3) VSOCK
    4) VCHR[ptm]
    5, 6, 7, 8) VCHR[pts]

</pre><p>&nbsp;Supporting ioctls on these vnodes will require a switch table. In addition to the ioctl number, the translation mechanism must look at the type of the file descriptor an ioctl is targeting to determine what translation needs to be done. Hence, the translation layer will need to looking at the v_type and the major portion of v_dev associated with the target file descriptor. These fields are easily accessible from the kernel and are also available via st_mode and st_rdev from fstat(2). So this translation could occur either in the kernel or in userland.</p><p>&nbsp;The only tricky part about this determination is that we don't want to hard code the the major Solaris driver number into any translation code since these number are allocated dynamically via <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>name_to_major</span> in the global zone. Therefor device ioctl translators should be bound to specific Solaris drivers by their driver name, and when an application attempts to perform an ioctl to a driver the translation code will need to be able to resolve the driver name to driver major number mapping. This translation code should have not have any impact on how devices are managed in the global zone.</p><h5 id="H3.7.3.2Ioctlsupport-nits"><span>3.7.3.2 Ioctl support - nits</span></h5><p>&nbsp;There are other more minor issues surrounding ioctl support that are worth mentioning.</p><p>&nbsp;Ioctl cmd symbols that represent the same ioctl command on Solaris and Linux can have different underlying symbol values. For example, TCSBRK on Solaris is 0x5405, while on Linux it's 0x5409. Any translation layers will have to be aware of the Linux ioctl values and translate them into Solaris ioctl values.</p><p>&nbsp;One final note: BrandZ will take an "opt-in" approach to ioctls. Only those ioctls that we have explicitly added support for will be executed. All others will return EINVAL. The alternative approach, simply passing the unrecognized ioctls through to Solaris proper, is risky for the following reasons:</p><ul><li>Nondeterministic behavior: Since ioctl cmd values can be different from Solaris, and devices on Solaris and Linux can support different behaviors, simply passing on unknown ioctls could result in nondeterministic device and/or application behavior.</li></ul><ul><li>Inadvertent breakage and maintainability issues: If an application depends on certain ioctls that are not explicitly listed as supported in brand-specific code, then there is an increased chance that a developer might attempt to change the implementation of one of those ioctls without knowing that the ioctl is also being consumed by a brand, and thereby inadvertently break the brand. If all ioctls supported by a brand are explicitly listed in the brand support code, then when developers search for consumers of a given ioctl, they will see that the ioctl is exported for application consumption in a brand environment.</li></ul><h4 id="H3.7.4DeviceMinorNodesandPathManagement"><span>3.7.4 Device Minor Nodes and Path Management</span></h4><p>&nbsp;Multiple zones (both native and non-native) will be sharing devices with the global zone and with each other. Therefor, we must ensure that this device sharing doesn't generate any security problems where one zone could affect another because of device sharing. Here's a look at the device nodes that will be present in zones and what types of risks/issues these devices present.</p><pre>

        Device          Notes
        ~------          ~-----
        /dev/null       read-write, doesn't have any consumer state
        /dev/zero       read-write, doesn't have any consumer state

        /dev/random     Writable only by root, protected from root
                        zone writes via the 'sys_devices' privilege.
        /dev/urandom    Writable only by root, protected from root
                        zone writes via the 'sys_devices' privilege.

        /dev/tty        Pass through device,
                        doesn't have any consumer state

        /dev/ptmx       Cloning device. Each open results in a unique
                        minor node, so a minor node can only exist
                        in one zone at any given time.

        /dev/pts/*      All minor nodes are visible in all zones.
                        Currently, this driver has been made zone
                        aware to prevent multiple zones from
                        accessing the same minor nodes concurrently.

        /dev/console    Minor nodes of this device should not be
                        shared across different zones.  Each
                        instance of this device in a zone should
                        have a unique minor number.  This is the
                        current behavior for native zones.

</pre><p>&nbsp;The other important aspect of device paths is how brand/zone-specific device paths are seen from the global zone. Currently, the only brand/zone-specific device that exists is the zcons console device. Here are examples of zcons device paths that could exist in the global zone (with two native zones booted):</p><pre>

        /dev/zcons/&lt;zone1_name&gt;/masterconsole -&gt;

                /devices/pseudo/zconsnex@1/zcons@0:masterconsole

        /dev/zcons/&lt;zone1_name&gt;/zoneconsole -&gt;

                /devices/pseudo/zconsnex@1/zcons@0:zoneconsole

        /dev/zcons/&lt;zone2_name&gt;/masterconsole -&gt;
                /devices/pseudo/zconsnex@1/zcons@1:masterconsole

        /dev/zcons/&lt;zone2_name&gt;/zoneconsole -&gt;
                /devices/pseudo/zconsnex@1/zcons@1:zoneconsole

</pre><p>&nbsp;These device paths are very zcons centric and don't really extend well if we attempt to introduce any new brand-specific devices. If we decide to add any new brand-specific devices, then these paths should probably be changed. For instance, if we add a Linux brand-specific driver that layers on top of <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>ptmx</span>, then the following device paths might make more sense:</p><pre>

        /dev/zones/&lt;brand&gt;/&lt;zone_name&gt;/masterconsole -&gt;
                /devices/pseudo/zonesnex@1/zcons@0:masterconsole

        /dev/zones/&lt;brand&gt;/&lt;zone_name&gt;/zoneconsole -&gt;

                /devices/pseudo/zonesnex@1/zcons@0:zoneconsole

        /dev/zones/&lt;brand&gt;/ptmx -&gt;

                /devices/pseudo/ptm_linux@0:ptmx

</pre><h4 id="H3.7.5Device-SpecificIssues"><span>3.7.5 Device-Specific Issues</span></h4><h5 id="H3.7.5.12Fdev2Fconsole"><span>3.7.5.1 /dev/console</span></h5><p>&nbsp;Each branded zone will need its own console device, just like native zones today. Whenever possible, a brand should leverage the zcons driver and use it as the <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>console</span> device in a non-native zones. We have done this in the <em>lx</em> brand.</p><h5 id="H3.7.5.22Fdev2Fptmxand2Fdev2Fpts"><span>3.7.5.2 /dev/ptmx and /dev/pts</span></h5><p>&nbsp;These devices need special management. When Linux applications access these devices, we need to do two things.</p><ol><li>After an open of <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>ptmx</span>, we need to ensure that the associated <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>pts<span style="color: #666666; ">/*</span></span> device link exists (since it can be created asynchronously to ptmx opens), and that it has its ownership changed to match that of the process that opened this instance of <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>ptmx</span>.</li><li>We need to ensure that after any pts device is opened by a Linux application, the following modules get pushed onto its stream: <span class="box code">ptem, ldterm, ttcompat, and ldlinux</span></li></ol><p>&nbsp;In Solaris, issue 1 above is done by libc`ptsname() with the help of an su binary. Issue 2 above is done by client applications that are allocating terminals (for example, this is done in xterm`spawn().)</p><p>&nbsp;For BrandZ, there two possible approaches for solving these problems.</p><p>&nbsp;The first is to continue with the initially prototyped approach and do both of these things post open in an interception layer. For the ptm device (issue 1 above), this interception layer would have to be in the kernel since it involves changing the ownership of a device and <span class="box code"><span style="color: #666666; ">/</span>dev</span> is mounted as read only in zones. The post open pts device processing (issue 2 above) could be done in the kernel or in userland. This approach doesn't seem that great since its implementation is spread across both userland and the kernel. It also involves post-processing all opens to determine if additional work is necessary.</p><p>We will adopt an alternate approach, and replace the ptm driver with a layered driver in Linux branded zones. The current ptmx driver will be replaced with a self-cloning layered driver in the Linux zones. Upon open, this layered driver will:</p><ul><li>Open an instance of the real <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>ptmx</span>.</li><li>Wait for the corresponding <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>pts<span style="color: #666666; ">/*</span></span> node to be created.</li><li>Set the permissions on the corresponding <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>pts<span style="color: #666666; ">/*</span></span> node.</li><li>Set up the auto push mechanism (via kstr_autopush() to automatically push the required strmods onto the corresponding <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>pts<span style="color: #666666; ">/*</span></span> node when it is actually opened by a Linux application.</li></ul><p>&nbsp;Upon final close of a Linux ptm node, this driver will remove the auto push configuration it created and close the underlying <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>ptmx</span> node that it opened.</p><h5 id="H3.7.5.32Fdev2Ffd2F2A"><span>3.7.5.3 /dev/fd/*</span></h5><p>&nbsp;The entries in <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd</span> are not actually devices. The entries in <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd<span style="color: #666666; ">/</span></span> allow a process access to its own file descriptors via another namespace. Thus, opens of entries in this directory map to re-opens of the corresponding file descriptor in the current process.</p><p>&nbsp;In Solaris <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd</span> is implemented via a filesystem. readdir(3C)s of <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd</span> might not return an accurate reflection of the current file descriptor state of a process, but opens of specific entries in the directory will succeed if that file descriptor is valid for the process performing the open.</p><p>&nbsp;In Linux, <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd</span> is implemented as a symbolic link to <span class="box code"><span style="color: #666666; ">/</span>proc<span style="color: #666666; ">/</span>self<span style="color: #666666; ">/</span>fd</span>. This <span class="box code"><span style="color: #666666; ">/</span>proc</span> filesystem directory is similar to the Solaris <span class="box code"><span style="color: #666666; ">/</span>proc<span style="color: #666666; ">/&lt;</span>pid<span style="color: #666666; ">&gt;/</span>fd</span> directory in that it contains an accurate representation of a processes current file descriptor state. But aside from just providing access to the processes current file descriptors, on Linux the files in this directory are actually symbolic links to the underlying files referenced by the processes file descriptors. This is similar to the functionality in Solaris provided by <span class="box code"><span style="color: #666666; ">/</span>proc<span style="color: #666666; ">/&lt;</span>pid<span style="color: #666666; ">&gt;/</span>paths</span>.</p><p>&nbsp;The most common uses for <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd</span> entries are for suid shell script and as parameters to commands that don't natively support I/O to <span class="box code">stdin<span style="color: #666666; ">/</span>stdout</span>. Given these use cases it seems that a simple mount of the existing Solaris <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd</span> filesystem in the Linux zone should be sufficient for compatibility purposes. Of course, it is possible that other Linux applications exist that utilize some of the additional functionality of the Linux <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd</span> implementation that isn't available in Solaris. (For example, <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>fd</span> on Linux provides an accurate reflection of the current fd state of the process and allows applications to determine file descriptor to file path mappings.) If such applications are discovered, then we might need to revisit this strategy.</p><h5 id="H3.7.5.4audiodevices"><span>3.7.5.4 audio devices</span></h5><p>&nbsp;Linux has two different audio subsystems OSS and ALSA. To determine which audio subsystem to support we identified some common/popular applications that utilize audio and checked which subsystem they use. We found:</p><pre>

OSS only:
        skype, real/helix media player, flash, quake, sox

OSS or ALSA:
        xmms (selectable via plugins)

</pre><p>Our survey identified no popular applications that require ALSA, so we will only be supporting OSS audio.</p><p>&nbsp;Audio device access on Linux and Solaris is done via reads, writes, and ioctls to different devices.</p><pre>

OSS devices:
        /dev/dsp, /dev/mixer
        /dev/dsp[0-9]+, /dev/mixer[0-9]+

Solaris devices:
        /dev/audio, /dev/audioctl
        /dev/sound/[0-9]+, /dev/sound/[0-9]+ctl

</pre><p>&nbsp;Unfortunately, we can't simply map the Solaris <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>audio</span> and <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>audioctl</span> devices to <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>dsp</span> and <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>mixer</span> devices in a Linux and expect the ioctl translator to handle everything else for us. Some of the reason for this are:</p><ul><li>The admin/user may not always want a Linux branded zone to have access to system audio devices.</li><li>There may be multiple audio devices on a system each of which may support only input, only output, or both input and output. In Solaris a user can specify which audio device an application should access by providing a <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>sound<span style="color: #666666; ">/*</span></span> path to the desired device. But in the Linux zone the admin might want the Linux audio device to map to separate Solaris audio devices for input and/or output.</li><li>Linux ioctl translation is done using dev_t major values. On Solaris opening <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>audio</span> will result in accessubg different device drivers based of what the underlying audio hardware is, and these different drivers may have different dev_t values. Hence, if audio devices were directly imported the dev_t translator would need to have knowledge of every potential audio device driver on the system, and as new audio drivers are added to the system this translator would need to be made aware of them as well.</li><li>In Linux audio devices are character devices and support mmap operations. On Solaris audio devices are streams based and do not support mmap operations.</li></ul><p>To deal with these problems the following components are provided:</p><ul><li>A way for the user to enable audio support in a zone via zonecfg. The user enables audio via zonecfg boolean attribute called "audio". (The absence of this attribute implies a value of false.) Adding this resource to a zone via zonecfg looks like this:</li></ul><pre>
        ~--
        zonecfg:centos&gt; add attr
        zonecfg:centos:attr&gt; set name="audio"
        zonecfg:centos:attr&gt; set type=boolean
        zonecfg:centos:attr&gt; set value=true
        zonecfg:centos:attr&gt; end
        zonecfg:centos&gt; commit
        zonecfg:centos&gt; exit
        ~--
</pre><p>&nbsp;By default when a Linux audio applications attempts to open <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>dsp</span> this access is mapped to <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>audio</span> under Solaris. (Linux application access to <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>mixer</span> are mapped to <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>audioctl</span>.)<br/>&nbsp;To allow an admin to control which Solaris devices a Linux zone can send input/output to we provide two additional attributes that have string values:</p><pre>
        audio_inputdev = none | [0-9]+
        audio_outputdev = none | [0-9]+
</pre><p>&nbsp;If audio_inputdev is set to none, then audio input is disabled. If audio_inputdev is set to an integer, then when a Linux application attempts to open <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>dsp</span> for input this access is mapped to <span class="box code"><span style="color: #666666; ">/</span>dev<span style="color: #666666; ">/</span>sound<span style="color: #666666; ">/&lt;</span>audio_inputdev attribute value<span style="color: #666666; ">&gt;</span></span>. The same behavior applies to audio_outputdev for Linux audio output accesses.<br/>&nbsp;If audio_inputdev or audio_outputdev exist but the audio attribute is missing (or set to false) audio will not be enabled for the zone.<br/>&nbsp;Currently there is no mechanism outside of zonecfg itself for verifying zone attributes. So if a user specifies invalid types or values for these attributes there is no way to alert them during the zone configuration stage. (Later when attempting to boot the zone we will have an opportunity to verify these attributes and can fail to boot the zone if they are invalid.)</p><ul><li>Create a new layered driver to act as a Linux audio device.<br/>&nbsp;This device will always be mapped into the zone. Linux can change the ownership of this device nodes as it sees fit.<br/>&nbsp;Since this layered driver will be accessing Solaris devices from within the kernel there will be no problems with device ownership. The Solaris audio devices will continue to be owned by whoever is logged in on the console but a Linux zone will also be able to access the device whenever necessary.<br/>&nbsp;Luckily, the Solaris audio architecture includes an integrated audio output stream mixer so that multiple programs can open the audio device and output data at the same time. Unfortunately it's not possible to virtualize all audio features in this same manner. For instance there can only be one active audio recording stream on a given audio device at a time. Also it would be difficult to virtualize global mixer controls. Hence, by allowing a zone shared access to audio devices owned by the console user, it would be possible for zone users and the console user to compete for any non-virtualized audio resources. These limitations seem acceptable if it's assumed that the user who owns the console is the same user who is running Linux audio applications. We assume that this will probably be the common case for most audio enabled Linux zones. If these limitations are not acceptable then an admin always has the option of updating <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>logindevperm</span> to deny console users access to audio devices. (thereby giving a zone exclusive access to the device.)<br/>&nbsp;This device is implemented as a character driver (instead of as a streams driver.) This allows it to more easily support Linux memory mapped audio device access. Theoretically, mmap device access could be simulated in the ioctl translation layer but this would add quite a bit of extra complexity to the translation system. It would require that the ioctl translation layer start to maintain state across multiple ioctl operations, something it currently does not do. It would also require user land helper threads and support for handling and redirecting signals that might get delivered to those threads.</li><li>Provide hooks into the zone state transition brand callback mechanism to propagate zone audio device configuration to the Linux layered audio device.<br/>&nbsp;This is done via a program that opens the layered Linux audio device when the zone is booted, and uses ioctls to configure the device. When a zone is halted this same program is used to notify the driver that any previous configuration for a given zone is no longer valid.</li></ul><p>This model provides each Linux zone with one audio device. There are no inherent limits in this approach that would prevent future support for multiple virtual audio devices in a linux zone. The <span class="box code">zonecfg</span> attribute configuration mechanism could be extended to allow the the administrator to specify what the mappings for additional audio devices should be. The audio layered driver could also be enhanced to export multiple audio and mixer minor nodes which would all be imported into any linux zone on the system. Lastly, the zone boot configuration callbacks could be enhanced to parse the additional <span class="box code">zonecfg</span>audio configuration attributes and pass the additional configuration information down to the audio layered driver.</p><h3 id="H3.8NFS"><span>3.8 NFS</span></h3><p>The BrandZ <em>lx</em> brand will have NFSv3/2 client support. NFSv4 is not supported since the version of RedHat/CentOS that the <em>lx</em> brand currently supports does not support NFSv4 itself. Having an NFSv3/2 server in a branded zone is also not supported since this is an existing limitation on native zones systems and BrandZ is not removing this limitation.</p><h4 id="H3.8.1NFSv32F2ClientSupport"><span>3.8.1 NFSv3/2 Client Support</span></h4><p>NFS client support consists of two major components:</p><ul><li>A kernel filesystem module that can "mount" nfs shares from a server and service accesses to that filesystem via VOP_ interfaces</li><li><span class="box code">lockd</span> and <span class="box code">statd</span> rpc services to handle nfs locking requests.</li></ul><p>Due to licensing issues we can't port the Linux NFS kernel filesystem module to Solaris.</p><p>On Solaris <span class="box code">lockd</span> is a userland daemon with a significant kernel component: <span class="box code">klmmod</span>. Most of the <span class="box code">lockd</span> functionality is actually implemented in the kernel in <span class="box code">klmmod</span>. The kernel <span class="box code">lockd</span> component also uses private undocumented interface (NSM_ADDR_PROGRAM) to communicate with <span class="box code">statd</span>.</p><p>On Linux <span class="box code">lockd</span> is actually entirely contained within the kernel. When the kernel starts up the <span class="box code">lockd</span> services, it creates a fake process that is visible via the <span class="box code">ps</span> command but lacks most normal /proc style entries.</p><p>Given the how closely integrated the separate components of the NFS client are on Solaris, and given that that most of the NFS client on Linux is in the kernel and there for not usable by the <em>lx</em> brand, the approach taken to support the NFS client in the <em>lx</em> brand was to simply run the Solaris NFS client within the <em>lx</em> zone.</p><p>Adding support for using the all Solaris NFS client components in a zone involved modifications in BrandZ, the <em>lx</em> brand, and base Solaris. Some of these areas and the modifications that were required are described below.</p><h5 id="H3.8.1.1support"><span>3.8.1.1 <span class="box code">mount(2)</span> support</span></h5><p>The first component of support NFS client operations in an <em>lx</em> branded zone is translating Linux NFS mount system call requests into Solaris mount system call requests. This requires translating the arguments and options strings normally passed to the Linux into formats that the Solaris kernel is expecting.</p><h5 id="H3.8.1.2Startingandstoppingoftheanddaemons."><span>3.8.1.2 Starting and stopping of the <span class="box code">lockd</span> and <span class="box code">statd</span> daemons.</span></h5><p>The version of RedHat/CentOS Linux that the <em>lx</em> brand support has a <span class="box code">rc.d</span> startup script that is used to start, stop, and check the status of <span class="box code">statd</span> and <span class="box code">lockd</span>. To support the execution of the Solaris versions of <span class="box code">lockd</span> and <span class="box code">statd</span> in a zone, after install we replace the Linux <span class="box code">lockd</span> and <span class="box code">statd</span> binaries with symlinks to scripts in <span class="box code"><span style="color: #666666; ">/</span>native<span style="color: #666666; ">/</span>usr<span style="color: #666666; ">/</span>lib<span style="color: #666666; ">/</span>lx<span style="color: #666666; ">/</span>brand</span> that start the Solaris versions of the two daemons. The startup script has also been modified to successfully allow for the startup, stopping, and querying of status for <span class="box code">lockd</span> and <span class="box code">statd</span>. This approach preserves the existing techniques for administering NFS locking under RedHat/CentOS in the <em>lx</em> brand.</p><p><span class="box code">lockd</span> and <span class="box code">statd</span> are also run under different user and group ids under Linux than Solaris. The startup wrapper scripts pass command line options to <span class="box code">lockd</span> and <span class="box code">statd</span> to indicate what user and group should be used during normal operations.</p><h5 id="H3.8.1.3RunningnativeSolarisprocessesinazone"><span>3.8.1.3 Running native Solaris processes in a zone</span></h5><p>Normally all processes in a non-native zone are branded non-native process. NFS client support is the only exception to this rule since it introduces the execution of two native Solaris processes into a non-native zone. To support the basic execution of a native Solaris process in the following steps were taken.</p><h5 id="H3.8.1.3.1Brandawareexecpath"><span>3.8.1.3.1 Brand aware exec path</span></h5><p>The internal kernel exec path path (starting at <span class="box code">exec_common()</span>) was updated to have a new brand operation flag. The possible values for this flag are: clear (no special brand operation), brand-exec (indicates that the current process should become branded if the exec operation succeeds), and native-exec (indicates that the current process should become a native process if the exec operation succeeds.)</p><p>Note, these extended exec flags are not accessible through the normal exec() system call path. The normal exec() system call path always defaults to this flag being clear. To change the branding of a process via exec, a special brand operation (invoked via the <span class="box code">brandsys(2)</span> system call) is used.</p><h5 id="H3.8.1.3.2Chroot"><span>3.8.1.3.2 Chroot</span></h5><p>One Problem with running native Solaris binaries in a branded zone is that both the native binary and native libraries that they use expect to be able to access native Solaris paths and files that may not exist inside a branded. Rather than implementing a path mapping mechanism to re-direct filesystem accesses for native binaries to paths into /native, during the startup of these daemons we do a chroot("/native"). We've also ensured that there is enough of the native Solaris environment created in /native to allow <span class="box code">lockd</span> and <span class="box code">statd</span> run properly.</p><h5 id="H3.8.1.4AllowingandtocommunicatewithLinuxservices2Finterfaceswithinthezone."><span>3.8.1.4 Allowing <span class="box code">lockd</span> and <span class="box code">statd</span> to communicate with Linux services/interfaces within the zone.</span></h5><p><span class="box code">lockd</span> and <span class="box code">statd</span> are fairly self contained but they do require access to certain services for which the native Solaris versions won't be available in a zone. An audit of <span class="box code">lockd</span> and <span class="box code">statd</span> reveal that these daemons depend on access to the following services:</p><ul><li>naming services (via libnsl.so)</li><li>syslog (via libc.so)</li></ul><p>Normally, these daemons simply access these services via local libraries. These libraries in turn use local files, other libraries, and various network based resources to resolve requests. In a branded zone most of these resources will not be available. For example, we can't expect the Solaris libnsl.so library to know how to parse Linux NIS configuration files.</p><p>To handle these requests we need to be able to leverage existing Linux services and interfaces. This requires translating certain Solaris <span class="box code">lockd</span> and <span class="box code">statd</span> services requests into Linux service requests, and then translating any results back into a format that Solaris libraries and utilities are expecting. In the <em>lx</em> brand we've decided to call this process of translating service requests <em>thunking</em>. (akin to a 32-bit OS calling into 16-bit BIOS code.) To service these requests we have created a thunking layer which translates Solaris calls into Linux calls.</p><p>This thunking layer works as follows:</p><ol><li>When <span class="box code">lockd</span> or <span class="box code">statd</span> make a request that requires thunking, this request ends up getting directed into a library in the process called lx_thunk.so (the mechanism used to direct requests into this library varies based of the type of request being serviced and is discussed further below).</li><li>The lx_thunk.so library packs up this request and sends it via a door to child Linux process called lx_thunk.</li><li>If the lx_thunk process does not exist then the lx_thunk.so library will <span class="box code">fork(2)<span style="color: #666666; ">/</span>exec(2)</span> it.</li><li>The lx_thunk process is a one line /bin/sh script that attempts to execute itself and is executed in a Linux shell. When the brand emulation library (lx_brand.so) detects that it is executing as the lx_thunk process and it is attempting to re-exec itself, the library takes over the process and sets itself up as a doors server.</li><li>When the lx_thunk process receives a door request from lx_thunk.so library in a native process, it unpacks the request and uses a Linux thread to call invoke Linux interfaces to service the request.</li><li>Once it is done servicing the request it packs up any results and returns them via the same door call that it received the request on.</li></ol><p>This thunking layer means that now the <em>lx</em> brand is dependent upon Linux interfaces so we need to worry about Linux interfaces changing and breaking the lx_thunk server process. To help avoid this possibility, most the Linux interfaces that we've chosen to use are extremely well known and listed in the glibc ABI. All of the interfaces are used by many applications outside of glibc. Here are the Linux interfaces currently used by the lx_thunk process:</p><ul><li><span class="box code">gethostbyname_r</span></li><li><span class="box code">gethostbyaddr_r</span></li><li><span class="box code">getservbyname_r</span></li><li><span class="box code">getservbyport_r</span></li><li><span class="box code">openlog</span></li><li><span class="box code">syslog</span></li><li><span class="box code">closelog</span></li><li><span class="box code">__progname</span></li></ul><p>Also worth mentioning is the means by which service requests that require thunking are directed to lx_thunk.so. To intercept name service requests the <em>lx</em> brand is introducing a new libnsl.so plugin name-to-address translation library. Libnsl already supports name-to-address translation plugin libraries that can be specified via netconfig(4). For <em>lx</em> branded zones there will be a custom netconfig file installed into /native/etc/netconfig that will instruct libnsl.so to redirect name service lookup requests to a new library called lx_nametoaddr.so. This library will in turn resolve name service requests using private interfaces exported from the thunking library, lx_thunk.so.</p><h5 id="H3.8.1.5rpcbindvsportmap"><span>3.8.1.5 rpcbind vs portmap</span></h5><p><span class="box code">lockd</span> and <span class="box code">statd</span> are both rpc based services. There for when they start up they must register with an rpc portmapper. This registration is done via a standardized rpc protocol. The difficulty with this registration is that there are multiple versions of the protocol.</p><p>Initially the protocol was called the portmapper protocol and only supported IP based transports. This is the version of the protocol that RedHat/CentOS support. Solaris long ago upgraded the version of the protocol it supports to be rpcbind. rpcbind supports registrations on non-ip based transports. The problems faced by BrandZ are that all the libnsl.so interfaces designed for talking to a local portmapper assume that the local portmapper supports the rpcbind protocol. In the case of an <em>lx</em> branded zone we're actually running the Linux portmapper which doesn't support the rpcbind protocol. To work around this a new command line flag has been added to <span class="box code">lockd</span> and <span class="box code">statd</span> to indicate that they should attempt to to use the portmapper protocol instead of the rpcbind protocol for registering rpc services. Also, new private interfaces have been added into libnsl.so to allow it to support communication via the portmapper protocol instead of the rpcbind protocol.</p><h5 id="H3.8.1.6Privilegeretentionforand"><span>3.8.1.6 Privilege retention for <span class="box code">lockd</span> and <span class="box code">statd</span></span></h5><p>On Solaris, <span class="box code">lockd</span> and <span class="box code">statd</span> and privilege aware daemons and upon startup they drop all privilege they won't need for normal execution. When running in a Linux zone, these daemons need additional privileges so that they can <span class="box code">chroot(2)</span>, <span class="box code">fork(2)</span>, <span class="box code">exec(2)</span>, and run the lx_thunk processes. So the lx_thunk.so library which is preloaded into these processes also prevents them from dropping the following privileges:</p><ul><li><span class="box code">proc_exec</span></li><li><span class="box code">proc_fork</span></li><li><span class="box code">proc_chroot</span></li><li><span class="box code">file_dac_read</span></li><li><span class="box code">file_dac_write</span></li><li><span class="box code">file_dac_search</span></li></ul><h4 id="H3.8.2Automounters"><span>3.8.2 Automounters</span></h4><p>Linux supports two automounters: "amd" and "automount".</p><p>amd is implemented as a userland NFS server. It mounts NFS filesystems on directories where it will provide automount services, and specified itself as the server for these NFS filesystems. To support amd only required adding translation support for all the Linux system call mount options it expects to work.</p><p>automount, the more common (and often default) automounter, is substantially more complex than amd. automount relies on a filesystem module called autofs. Upon startup, automount mounts the autofs filesystem onto all automount controlled directories. As an option to the mount command it passes a file descriptor that indicates a pipe will be used to send requests to the automount process. automount listens for requests on this pipe. When it gets a request, it looks up shares via whatever name services are configured, executes <span class="box code">mount(2)</span> system calls as necessary, and notifies the autofs filesystem that a request has been serviced. The exact semantics of the interfaces between automount and autofs are versioned and appear to differ based of the Linux kernel version. To support automount the <em>lx</em> brand will introduce a new filesystem module called lx_autofs. When the automount process attempts to mount the autofs filesystem we will instead mount the lx_autofs filesystem which will emulate the behavior one specific version of the autofs filesystem.</p><h3 id="H3.9DebuggingandObservability"><span>3.9 Debugging and Observability</span></h3><h4 id="H3.9.1Ptrace"><span>3.9.1 Ptrace</span></h4><p>&nbsp;In order to support Linux <span class="box code">strace</span>, it will be necessary to duplicate almost the full functionality of the <span class="box code">ptrace</span> system call. Rather than trying to implement this giant wad in the kernel, we will implement it in userland on top of a native <span class="box code"><span style="color: #666666; ">/</span>proc</span>, which will be mounted at <span class="box code"><span style="color: #666666; ">/</span>native<span style="color: #666666; ">/</span>proc</span>. It is worth noting that the Solaris <span class="box code"><span style="color: #666666; ">/</span>proc</span> already has a ptrace compatibility flag, which provides much of the semantics we want (e.g., interaction through wait(2)).</p><p>Two difficult parts about ptrace are tracing Linux system calls and attaching to existing processes.</p><p>To implement system call tracing, we want to stop the program in userland before the interposition library has done any work. To do this, we introduce a per-brand scratch space in the ulwp_t structure, similar to that used by the DTrace PID provider. When we want to trace a system call enter or exit, we set this flag from within the kernel via a brand-specific system call. In the trampoline code, we check the status of this flag and issue another brand-specific system call that will stop us with an appropriately formed stack. Note that it's generally not possible to "hide" the interpositioning library when it comes to signals. Besides trying to figure where we are in the brand library (if we're in it at all), we will probably do more harm than good when trying to hide this behavior.</p><p>When a debugger attaches to another process using PTRACE_ATTACH under Linux, it actually becomes the parent for the target process in all ways - except that getppid() still returns the original value. Since this is an implementation detail and an undesirable pollution of the Solaris process model, we will instead add a per-brand child list that the wait(2) system call will also check. When we attach to a process, we add it to the debugger's brand list.</p><p>Finally, there are also significant issues around multithreaded apps. Trying to reconcile the differences between the Linux and Solaris threading models as well as the differences between <span class="box code">ptrace(2)</span> and <span class="box code"><span style="color: #666666; ">/</span>proc</span> appears to be a nearly intractable problem. For at least the initial BrandZ release, we do not expect to be able to support <span class="box code">ptrace(2)</span> for multithreaded applications.</p><h4 id="H3.9.2librtld_db:MDBandSolarisptoolsSupport"><span>3.9.2 librtld_db: MDB and Solaris ptools Support</span></h4><p>&nbsp;Since the Linux binaries and applications are standard ELF objects, Solaris tools are able to process them in essentially the same way that Solaris binaries are processed. The main objective in doing so is to retrieve symbols and thereby aid debugging and observability.</p><p>&nbsp;mdb and the ptools (pstack, pmap, etc) use interfaces provided by <span class="box code">librtld_db</span> to debug live processes and core files. <span class="box code">librtld_db</span> discovers ELF objects which have been mapped into the target's (a target can be either a live process or a core file) address space and reports these back to the <span class="box code">librtld_db</span> client. <span class="box code">librtld_db</span> library understands enough of the internals of the Solaris runtime linker to iterate over the linker's private link maps and process the objects it finds. <span class="box code">librtld_db</span> allows our tools to debug the Solaris portions of a branded process (such as the brand library, libc, etc.), but they cannot understand any Linux objects that are mapped into our address space, because the Solaris linker only has Solaris objects on its link maps.</p><p>&nbsp;In order to give Solaris tools visibility into Linux binaries, a brand helper-library framework is implemented in <span class="box code">librtld_db</span>. When <span class="box code">librtld_db</span> is asked to examine a branded target process or core file, it uses the AT_SUN_BRANDNAME aux vector to get the brand name of the process. Once it has the brand name, it <span class="box code">dlopen(3C)</span>s a shared object from: <span class="box code"> <span style="color: #666666; ">/</span>usr<span style="color: #666666; ">/</span>lib<span style="color: #666666; ">/</span>brand<span style="color: #666666; ">///</span>brandname<span style="color: #666666; ">/////</span>brandname<span style="color: #666666; ">//</span>_librtld_db.so.1&nbsp;</span></p><p>&nbsp;Brand helpers must have a vector of operations called from critical <span class="box code">librtld_db</span> hooks (e.g. helper initialization, loaded object iteration, etc).</p><p>&nbsp;Once loaded, the helper library is responsible for finding any brand-specific information it needs, such as the brand equivalent of <span class="box code">AT_SUN_LDDATA</span> (used by <span class="box code">librtld_db</span> to find the Solaris link maps), and preparing to return details about the objects loaded into the address space by the brand's linker.</p><p>&nbsp;When a client of <span class="box code">librtld_db</span> operating on a branded process, asks to know what objects are loaded in the target, <span class="box code">librtld_db</span> walks the Solaris link maps and iterates over each object it finds there, handing information about each to the caller. It then calls down into the helper library, which does the same for the brand-specific objects used by the target. In this manner, the client of <span class="box code">librtld_db</span> does not need any modification to operate on branded processes, nor does it need any special knowledge of brands; all data is passed via established <span class="box code">librtld_db</span> APIs.</p><p>&nbsp;Because <span class="box code">mdb</span> and the other ptools are Solaris binaries, they may not run inside a non-Solaris branded zone. They must therefore run from the global zone and may operate on individual processes within the branded zone.</p><h4 id="H3.9.3CoreFiles"><span>3.9.3 Core Files</span></h4><p>&nbsp;Since dumping core is handled by the kernel, it will produce Solaris core files that cannot be understood by the native Linux tools. While it would be possible to provide a brand-specific tool to convert between Solaris core files and Linux core files, it will not be provided as part of the initial release. Unless there is significant customer demand for this tool, it will not likely be included in subsequent releases either. Our preferred method for examining Linux core files is through <span class="box code">mdb</span>.</p><h4 id="H3.9.4DTrace"><span>3.9.4 DTrace</span></h4><p>With the addition of brand support in <span class="box code">librtld_db.so</span>, the DTrace PID provider is able to instrument Linux processes correctly with no additional work.</p><p>&nbsp;We have also added an <span class="box code">lx<span style="color: #666666; ">-</span>syscall</span> provider, which allows DTrace to trace the Linux system calls issued by the application.</p><h3 id="H3.10.2Fproc"><span>3.10. /proc</span></h3><p>&nbsp;The <em>lx</em> brand will deliver a lx_proc kernel module that provides the necessary semantics of a Linux /proc filesystem.</p><p>&nbsp;Linux tends to use /proc as a dumping ground for all things system-related, although this is reduced by the introduction of sysfs in the 2.6 kernel. Thus, we will not be able to emulate a large number of elements from within a zone. Examples of unsupported functionality include physical device characteristics, the USB device tree, acccess to kernel memory, etc. Because various commands expect these files to be present, but do not actually act on their contents, a number of these files will exist but otherwise be empty.</p><p>&nbsp;We are able to emulate the per-process directories completely. The following table shows the support status of other /proc system files.</p><table><tr><th scope="col">File</th><th scope="col">Supported</th><th scope="col">Description</th></tr><tr><td>&nbsp;cmdline&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Kernel command line options</td></tr><tr><td>&nbsp;cpuinfo&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Physical chip characteristics</td></tr><tr><td>&nbsp;crypto&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;Kernel crypto module info</td></tr><tr><td>&nbsp;devices&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Major number mappings</td></tr><tr><td>&nbsp;dma&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;driver/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;Per-driver configuration settings</td></tr><tr><td>&nbsp;execdomains&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;fb&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;Framebuffer device</td></tr><tr><td>&nbsp;filesystems&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Available kernel filesystems</td></tr><tr><td>&nbsp;fs/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;ide/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;Kernel IDE driver info</td></tr><tr><td>&nbsp;interrupts&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Kernel interrupt table</td></tr><tr><td>&nbsp;iomem&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;I/O memory regions</td></tr><tr><td>&nbsp;ioports&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;I/O port bindings</td></tr><tr><td>&nbsp;irq/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;kcore&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Kernel core image</td></tr><tr><td>&nbsp;kmsg&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Kernel message queue</td></tr><tr><td>&nbsp;ksyms&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;Kernel symbols</td></tr><tr><td>&nbsp;loadavg&nbsp;</td><td>&nbsp;yes&nbsp;</td><td>&nbsp;System load average</td></tr><tr><td>&nbsp;locks&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;mdstat&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;meminfo&nbsp;</td><td>&nbsp;yes&nbsp;</td><td>&nbsp;Virtual memory information</td></tr><tr><td>&nbsp;misc&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;modules&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;Random module information</td></tr><tr><td>&nbsp;mounts&nbsp;</td><td>&nbsp;yes&nbsp;</td><td>&nbsp;System mount table</td></tr><tr><td>&nbsp;mpt/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;mtrr&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;net/*&nbsp;</td><td>&nbsp;no*&nbsp;</td><td>&nbsp;Various network configuration</td></tr><tr><td>&nbsp;partitions&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Parition table</td></tr><tr><td>&nbsp;pci&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;PCI device info</td></tr><tr><td>&nbsp;scsi/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;SCSI device info</td></tr><tr><td>&nbsp;slabinfo&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;Kernel Slab allocator stats</td></tr><tr><td>&nbsp;stat&nbsp;</td><td>&nbsp;yes&nbsp;</td><td>&nbsp;General system wide statistics</td></tr><tr><td>&nbsp;swaps&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;Swap device information</td></tr><tr><td>&nbsp;sys/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;sysrq-trigger&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;sysvipc/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;System V IPC statistcis</td></tr><tr><td>&nbsp;tty/*&nbsp;</td><td>&nbsp;no&nbsp;</td><td>&nbsp;???</td></tr><tr><td>&nbsp;uptime&nbsp;</td><td>&nbsp;yes&nbsp;</td><td>&nbsp;System uptime</td></tr><tr><td>&nbsp;version&nbsp;</td><td>&nbsp;empty&nbsp;</td><td>&nbsp;Kernel version</td></tr></table><h3 id="H4.Deliverables"><span>4. Deliverables</span></h3><h4 id="H4.1SourcedeliveredintoON"><span>4.1 Source delivered into ON</span></h4><p>Below is a summary of the new sources being added to ON.</p><h5 id="HNewcodeforbrandsupport:"><span>New code for brand support:</span></h5><table><tr><td>&nbsp;usr/src/lib/libbrand&nbsp;</td><td>&nbsp;support for reading the new XML files defining brands and virtual platforms</td></tr><tr><td>&nbsp;usr/src/lib/brand/native/&nbsp;</td><td>&nbsp;virtual platform and template files for non-branded zones</td></tr><tr><td>&nbsp;usr/src/uts/common/os/brand.c&nbsp;</td><td>&nbsp;manages the brandx framework, tracks loaded brands, and so on.</td></tr><tr><td>&nbsp;usr/src/uts/common/syscall/brandsys.c&nbsp;</td><td>&nbsp;the brandsys() system call</td></tr></table><h5 id="HNewdirectoriescreatedasholdingareasforper-brandcode:"><span>New directories created as holding areas for per-brand code:</span></h5><table><tr><td>&nbsp;usr/src/lib/brand&nbsp;</td><td>&nbsp;for the userspace components of brands</td></tr><tr><td>&nbsp;usr/src/uts/common/brand&nbsp;</td><td>&nbsp;for platform-independent brand code</td></tr><tr><td>&nbsp;usr/src/uts/intel/brand&nbsp;</td><td>&nbsp;for Intel-specific brand code</td></tr><tr><td>&nbsp;usr/src/uts/sparc/brand&nbsp;</td><td>&nbsp;for SPARC-specific brand code</td></tr></table><h5 id="HFortheSolaris1027test27brand:"><span>For the Solaris 10 'test' brand:</span></h5><table><tr><td>&nbsp;usr/src/pkgdefs/SUNWs10r&nbsp;</td><td>&nbsp;The package containing all the kernel-space pieces of the <em>s10</em> brand</td></tr><tr><td>&nbsp;usr/src/pkgdefs/SUNWs10u&nbsp;</td><td>&nbsp;The package containing all the user-space pieces of the <em>s10</em> brand</td></tr><tr><td>&nbsp;usr/src/lib/brand/s10/s10_brand&nbsp;</td><td>&nbsp;contains the emulation code and the zones integration support.</td></tr><tr><td>&nbsp;usr/src/uts/common/brand/s10&nbsp;</td><td>&nbsp;source for kernel-level <em>s10</em> support</td></tr><tr><td>&nbsp;usr/src/uts/intel/s10_brand&nbsp;</td><td>&nbsp;where the <em>s10</em> Intel brand module is built</td></tr><tr><td>&nbsp;usr/src/uts/sparc/s10_brand&nbsp;</td><td>&nbsp;where the <em>s10</em> SPARC brand module is built</td></tr></table><h5 id="HForthelxbrand:"><span>For the <em>lx</em> brand:</span></h5><table><tr><td>&nbsp;usr/src/pkgdefs/SUNWlxr&nbsp;</td><td>&nbsp;The package containing the kernel-space components of the <em>lx</em> brand</td></tr><tr><td>&nbsp;usr/src/pkgdefs/SUNWlxu&nbsp;</td><td>&nbsp;The package containing the user-space components of the <em>lx</em> brand</td></tr><tr><td>&nbsp;usr/src/lib/brand/lx/lx_brand&nbsp;</td><td>&nbsp;contains the emulation code, as well as the zones integration support. (install scripts and so on)</td></tr><tr><td>&nbsp;usr/src/lib/brand/lx/librtld_db&nbsp;</td><td>&nbsp;the rtld_db plugin for the <em>lx</em> brand</td></tr><tr><td>&nbsp;usr/src/uts/common/brand/lx&nbsp;</td><td>&nbsp;source for kernel-level <em>lx</em> support</td></tr><tr><td>&nbsp;usr/src/uts/common/brand/lx/procfs&nbsp;</td><td>&nbsp;source for the <em>lx</em> /proc</td></tr><tr><td>&nbsp;usr/src/uts/common/brand/lx/dtrace&nbsp;</td><td>&nbsp;source for the <em>lx</em> syscall provider</td></tr><tr><td>&nbsp;usr/src/uts/intel/lx_brand&nbsp;</td><td>&nbsp;where the <em>lx</em> brand module is built</td></tr><tr><td>&nbsp;usr/src/uts/intel/lx_syscall&nbsp;</td><td>&nbsp;where the <em>lx</em> syscall provider is built</td></tr><tr><td>&nbsp;usr/src/uts/intel/lx_proc&nbsp;</td><td>&nbsp;where the <em>lx</em> /proc filesystem is built</td></tr></table><h4 id="H4.2Componentsinstalledwiththelxbrand"><span>4.2 Components installed with the <em>lx</em> brand</span></h4><h5 id="HUserspacecomponents:"><span>Userspace components:</span></h5><table><tr><td>&nbsp;usr/lib/brand/lx/lx_brand.so.1&nbsp;</td><td><em>lx</em> emulation library</td></tr><tr><td>&nbsp;usr/lib/brand/lx/[amd64]/lx_librtld_db.so.1&nbsp;</td><td><em>lx</em> rtld_db plugin</td></tr><tr><td>&nbsp;usr/lib/brand/lx/[amd64]/lx_thunk.so&nbsp;</td><td><em>lx</em> thunking support</td></tr><tr><td>&nbsp;usr/lib/brand/lx/[amd64]/lx_nametoaddr.so.1&nbsp;</td><td>&nbsp;Wrapper for Solaris name services</td></tr><tr><td>&nbsp;usr/lib/brand/lx/config.xml&nbsp;</td><td>&nbsp;Definition of the <em>lx</em> brand</td></tr><tr><td>&nbsp;usr/lib/brand/lx/platform.xml&nbsp;</td><td>&nbsp;Definition of the <em>lx</em> virtual platform</td></tr><tr><td>&nbsp;usr/lib/brand/lx/SUNWblank.xml&nbsp;</td><td>&nbsp;Values for a blank zone configuration</td></tr><tr><td>&nbsp;usr/lib/brand/lx/SUNWdefault.xml&nbsp;</td><td>&nbsp;Values for a default zone configuration</td></tr><tr><td>&nbsp;usr/lib/brand/lx/install&nbsp;</td><td>&nbsp;The scripts needed to install supported distros</td></tr><tr><td>&nbsp;usr/lib/brand/lx/lx_audio_config&nbsp;</td><td>&nbsp;Audio device configuration</td></tr><tr><td>&nbsp;usr/lib/brand/lx/lx_lockd&nbsp;</td><td>&nbsp;Wrapper for Solaris lockd</td></tr><tr><td>&nbsp;usr/lib/brand/lx/lx_statd&nbsp;</td><td>&nbsp;Wrapper for Solaris statd</td></tr><tr><td>&nbsp;usr/lib/brand/lx/lx_native&nbsp;</td><td>&nbsp;Wrapper for native Solaris processes</td></tr><tr><td>&nbsp;usr/lib/brand/lx/lx_boot&nbsp;</td><td>&nbsp;Boot-time script</td></tr><tr><td>&nbsp;usr/lib/brand/lx/lx_halt&nbsp;</td><td>&nbsp;Halt-time script</td></tr><tr><td>&nbsp;usr/lib/brand/lx/lx_install&nbsp;</td><td>&nbsp;Main <em>lx</em> install script</td></tr><tr><td>&nbsp;usr/lib/devfsadm/linkmod/SUNW_lx_link_i386.so&nbsp;</td><td>&nbsp;Brand-aware devfsadm link module</td></tr></table><h5 id="HKernelcomponents:"><span>Kernel components:</span></h5><table><tr><td>&nbsp;kernel/brand/[amd64]/lx_brand&nbsp;</td><td><em>lx</em> brand kernel module</td></tr><tr><td>&nbsp;kernel/drv/[amd64]/lx_audio&nbsp;</td><td><em>lx</em> Linux-compatible audio driver</td></tr><tr><td>&nbsp;kernel/drv/[amd64]/lx_systrace&nbsp;</td><td><em>lx</em> syscall provider</td></tr><tr><td>&nbsp;kernel/drv/[amd64]/lx_ptm&nbsp;</td><td><em>lx</em> Linux-compatible ptm driver</td></tr><tr><td>&nbsp;kernel/fs/[amd64]/lx_afs&nbsp;</td><td><em>lx</em> automounter support</td></tr><tr><td>&nbsp;kernel/fs/[amd64]/lx_proc&nbsp;</td><td><em>lx</em> /proc filesystem</td></tr><tr><td>&nbsp;kernel/strmod/[amd64]/ldlinux&nbsp;</td><td><em>lx</em> Linux-compatible ldterm module</td></tr></table>
</div>


    <div class="clearfloats"></div>
  </div>      <div id="xdocFooter">
  
                

       <div class="doc-tags" id="xdocTags">
        Tags:
        </div>
  
  <div id="xdocAuthors">
    <div class="xdocCreation">       Created by admin on 2009/10/26 12:11<br/>
          </div>
    <div class="xdocLastModification">       Last modified by admin on 2009/10/26 12:11
    </div>
  </div>
</div>
<div id="xwikidata" class="layoutsubsection">
        </div>  
    </div>      </div><div id="leftPanels" class="panels left">
                  <div class="panel expanded OSNav">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSNav');">Collectives</h1>
<div class="xwikipanelcontents">
<div id="xwikinavcontainer">
<span class="wikilink"><a href="/bin/view/Main/communities">Community Groups</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/projects">Projects</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/usergroups">User Groups</a></span>
</div><p/>
<script type="text/javascript">
document.observe('xwiki:dom:loaded', function() {
var obj = {div:'xwikinav',no:$count,height:250};
var acc = createAccordion(obj);
});
</script>
</div>
</div>
                        <div class="panel expanded OSDocs">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSDocs');">Community Group zones Pages</h1>
<div class="xwikipanelcontents">
<ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz">BrandZ</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz_bugfixes">BrandZ Bugfixes</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz_contribute">Contribute Code to BrandZ</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz_design_doc">BrandZ Design Doc</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz_downloads">BrandZ Downloads</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz_install">BrandZ Installation</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz_on_dev">BrandZ Impact on ON Development</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz_project_list">BrandZ Project List</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/brandz_scla_faq">BrandZ/SCLA FAQ</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/linux_applications">Linux Applications</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/faq">Zones and Containers FAQ</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/flar_zones">Flash Archives & Zones</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/files">Files</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/roadmap">Zones Roadmap</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/s10brand_dev_guide">Solaris10&#45;Branded Zone Developer Guide</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/zones_design_docs">Zones Project Documents</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/rm_enhancements">Enhanced Resource Management Project</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+zones/zoss">zones on shared storage proposal</a></span></li>
</ul></li>
</ul>
                              </div>
</div>
      </div>

  </div>
<div class="clearfloats"></div>
  </div></div><div id="footerglobal" class="layoutsection">
<div class="minwidth"></div>
<hr/>
        <div id="xwikiplatformversion">XWiki Enterprise 2.7.1.34853 - <a onclick="openURL('http://enterprise.xwiki.org/xwiki/bin/view/Main/Documentation', '_blank'); return false;" href="http://www.xwiki.org/xwiki/bin/view/Main/Documentation">Documentation</a></div>
<br/>
  
      <div id="footer">
    <p>
                <a href="https://markebrooks.github.io/bin/view/Main/tou/">Terms of Use</a>
                |
                <a href="http://www.oracle.com/html/privacy.html">Privacy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/trademark/">Trademarks</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/copyrights/">Copyright Policy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site_guidelines/">Site Guidelines</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site-map/">Site Map</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/help/">Help</a>
                <br/>Your use of this web site or any of its content or software indicates your agreement to be bound by these Terms of Use.<br/>
                &copy; 2013, Oracle Corporation and/or its affiliates.<br/><img src="https://markebrooks.github.io:443/static/images/logo_oracle_footer.gif" alt="Oracle Logo"/>
            </p>
        </div>

  
</div>

</div></div></body>
</html>
