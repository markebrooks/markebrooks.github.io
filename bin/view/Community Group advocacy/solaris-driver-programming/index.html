<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
                    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
                                    <title>Driver Programming (Community Group advocacy.solaris-driver-programming) - XWiki</title>
                <meta http-equiv="Content-Script-Type" content="text/javascript" />
                        <meta http-equiv="imagetoolbar" content="no"/>
                      <link rel="alternate" type="application/x-wiki" title="Edit" href="/bin/edit/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming" />
                    <link rel="canonical" href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming" />
                            <meta name="document" content="Community Group advocacy.solaris-driver-programming"/>
    <meta name="wiki" content="xwiki"/>
    <meta name="space" content="Community Group advocacy"/>
    <meta name="page" content="solaris-driver-programming"/>
    <meta name="version" content="1.1"/>
    <meta name="restURL" content="/rest/wikis/xwiki/spaces/Community+Group+advocacy/pages/solaris-driver-programming"/>
                <meta name="gwt:property" content="locale=en" />
                <meta name="revisit-after" content="7 days" />
<meta name="description" content="Driver Programming" />
<meta name="keywords" content="wiki " />
<meta name="distribution" content="GLOBAL" />
<meta name="rating" content="General" />
<meta name="author" content="admin" />
<meta http-equiv="reply-to" content="" />
<meta name="language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="alternate" type="application/rss+xml" title="Wiki Feed RSS" href="/bin/view/Main/WebRss?xpage=rdf" />
<link rel="alternate" type="application/rss+xml" title="Blog RSS Feed" href="/bin/view/Blog/GlobalBlogRss?xpage=plain" />
<link rel="shortcut icon" href="/resources/icons/oso/icon.png">
                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
<link href="https://markebrooks.github.io/static/css/stylesheet.css" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/style.css?colorTheme=ColorThemes.Oso" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/print.css" rel="stylesheet" type="text/css" media="print" />
        <!--[if IE]>
  <link href="/bin/skin/skins/colibri/ie%2Dall.css" rel="stylesheet" type="text/css" />
<![endif]-->
<!--[if IE 6]>
  <link href="/bin/skin/skins/colibri/ie%2D6.css" rel="stylesheet" type="text/css" />
<![endif]-->
<link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Settings?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Style?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/XWiki/SharePage?language=en'/>
<link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/modalPopup.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/jumpToPage.css?language=en'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/confirmationBox.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/notification.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/skins/colibri/resources/uicomponents/viewers/tags.css'/>

    
    <link href="/bin/skin/resources/js/xwiki/suggest/ajaxSuggest.css" rel="stylesheet" type="text/css" />
<link href="/bin/skin/resources/js/xwiki/lightbox/lightbox.css" rel="stylesheet" type="text/css" />
<!--[if IE]>
  <link href="/bin/skin/resources/js/xwiki/lightbox/lightboxIE.css" rel="stylesheet" type="text/css" />
<![endif]-->












<script type="text/javascript" src="/resources/js/prototype/prototype.js"></script>
<script type="text/javascript" src="/bin/skin/resources/js/xwiki/xwiki.js"></script>
<script type="text/javascript">
// <![CDATA[
XWiki.webapppath = "";
XWiki.servletpath = "bin/";
XWiki.contextPath = "";
XWiki.mainWiki = "xwiki";
XWiki.currentWiki = "xwiki";
XWiki.currentSpace = "Community Group advocacy";
XWiki.currentPage = "solaris-driver-programming";
XWiki.editor = "";
XWiki.viewer = "";
XWiki.contextaction = "view";
XWiki.docisnew = false;
XWiki.docsyntax = "xwiki/2.0";
XWiki.blacklistedSpaces = [ "Import","Panels","Scheduler","Stats","XAppClasses","XAppSheets","XAppTemplates","XWiki","WatchCode","WatchSheets","XApp","WatchAdmin","Watch","ColorThemes","AnnotationCode" ];
XWiki.hasEdit = false;
XWiki.hasProgramming = false;
XWiki.hasBackupPackImportRights = false;
window.docviewurl = "/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming";
window.docediturl = "/bin/edit/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming";
window.docsaveurl = "/bin/save/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming";
window.docgeturl = "/bin/get/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming";
// ]]>
</script>
<script type='text/javascript' src='/bin/skin/resources/js/scriptaculous/effects.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/modalPopup.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/jumpToPage.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmationBox.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmedAjaxRequest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/notification.js' defer='defer'></script>
<script type='text/javascript' src='/resources/uicomponents/widgets/list/xlist.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/suggest/ajaxSuggest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/skins/colibri/resources/uicomponents/viewers/tags.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/scriptaculous/scriptaculous.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/accordion/accordion.js' defer='defer'></script>

<script type='text/javascript' src='/bin/jsx/XWiki/WebDAV?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Settings?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Script?language=en' defer='defer'></script>

<script type="text/javascript" src="/resources/js/xwiki/compatibility.js" defer="defer"></script>

  </head>
  <body id="body" class="wiki-xwiki space-Community_Group_advocacy viewbody hideright">
<div id="xwikimaincontainer">
<div id="xwikimaincontainerinner">

  <div id="menuview">
    <div id="mainmenu" class="layoutsubsection actionmenu">
<strong id="xwikimenutitle" class="hidden">General Actions:</strong>
<div class="rightmenu">
      <div id="tmLogin" class="tmLogin topmenuentry ">
   <a class="tme" href="https://auth.opensolaris.org/login.action?targetUrl=http%3A%2F%2Fmarkebrooks.github.io%2Fbin%2Fview%2FCommunity%2BGroup%2Badvocacy%2Fsolaris%252Ddriver%252Dprogramming"><strong>Log-in</strong></a>
  </div>
  </div>
<div class="leftmenu">
  <div id="tmWiki" class="tmWiki topmenuentry hasIcon">
   <a class="tme" href="/bin/view/Main/"><strong>Wiki</strong></a>
  </div>
  <div id="tmSpace" class="tmSpace topmenuentry dropdownmenuentry  hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Community+Group+advocacy/"><strong>Community Group advocacy</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
                <span class="submenuitem "><a href="/bin/view/Main/SpaceIndex?space=Community+Group+advocacy" id="tmSpaceDocumentIndex" class="tmSpaceDocumentIndex">Document Index</a></span>
    </span></div>

<div id="tmSubSites" class="tmSubSites topmenuentry dropdownmenuentry dropdownnolink hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Subsites</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem hasIcon"><a href="https://cr.opensolaris.org/" id="tmCR" class="tmCR">Code Reviews</a></span>
<span class="submenuitem hasIcon"><a href="http://repo.opensolaris.org/" id="tmRepo" class="tmRepo">SCM Management</a></span>
<span class="submenuitem hasIcon"><a href="http://pkg.opensolaris.org/" id="tmPkg" class="tmPkg">Package Search</a></span>
<span class="submenuitem hasIcon"><a href="http://bugs.opensolaris.org/" id="tmBugs" class="tmBugs">Bugster</a></span>
<span class="submenuitem hasIcon"><a href="http://defect.opensolaris.org/" id="tmDefect" class="tmDefect">Bugzilla</a></span>
<span class="submenuitem hasIcon"><a href="http://test.opensolaris.org/" id="tmTest" class="tmTest">Test Machines</a></span>
<span class="submenuitem hasIcon"><a href="http://planet.opensolaris.org/" id="tmPlanet" class="tmPlanet">Planet</a></span>
<span class="submenuitem hasIcon"><a href="http://mail.opensolaris.org/" id="tmMail" class="tmMail">Mailing Lists</a></span>
<span class="submenuitem hasIcon"><a href="http://poll.opensolaris.org/" id="tmPoll" class="tmPoll">Elections &amp; Polls</a></span>
<span class="submenuitem hasIcon"><a href="http://arc.opensolaris.org/" id="tmArc" class="tmArc">ARC Case Logs</a></span>
<span class="submenuitem hasIcon"><a href="http://jucr.opensolaris.org/" id="tmJucr" class="tmJucr">Source Juicer</a></span>
<span class="submenuitem hasIcon"><a href="http://pkgfactory.opensolaris.org/" id="tmPkgfactory" class="tmPkgfactory">Package Factory</a></span>
<span class="submenuitem hasIcon"><a href="http://auth.opensolaris.org/" id="tmAuth" class="tmAuth">Auth</a></span>
</span></div>

</div>
</div>

  </div>
 <div id="header" class="layoutsection">
<div class="minwidthb"></div>

  <div id="header">
    <table style="width: 100%;">
        <tr>
            <td style="width: 1%;">
                 <a href="https://markebrooks.github.io/bin/view/Main/"><div id="logo"></div></a>  
            </td>
            <td id="logo-text" style="width: 1%;">
                Solaris
            </td>         
            <td style="width: 98%;">
                <table id="loading-indicator">
                    <tr>
                        <td><img src="https://markebrooks.github.io:443/static/images/busy.gif"
                                 alt="Loading" title="Loading"/></td>
                        <td>Loading...</td>
                    </tr>
                </table>
            </td>
            <td style="width: 1%;">
                <table id="iconbar">
                    <tr>
                    <td><a id="collectives-icon" href="https://markebrooks.github.io/bin/view/Main/collectives">
                        Collectives</a></td>
                    <td><a id="discussions-icon" href="https://markebrooks.github.io/bin/view/Main/discussions">
                            Discussions</a></td>
                    <td><a id="documentation-icon" href="https://markebrooks.github.io/bin/view/Main/documentation">
                            Documentation</a></td>
                    <td><a id="download-icon" href="https://markebrooks.github.io/bin/view/Main/downloads">
                            Download</a></td>
                    <td><a id="source-browser-icon" href="http://src.opensolaris.org/source">
                            Source Browser</a></td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</div>

 </div> 
  <div id="globallinks">
    <form action="/bin/view/Main/Search">
      <div class="globalsearch">
        <label class="hidden" for="headerglobalsearchinput">Search</label><input class="globalsearchinput withTip" id="headerglobalsearchinput" type="text" name="text" value="search..." size="15"/><input class="button" type="image" value="Go" alt="Go" src="/resources/icons/xwiki/search.png"/>
      </div>
    </form>
  </div> <div style="float:left;">

                

   <div id="hierarchy">
                              <a href='/bin/view/Community+Group+advocacy/articles'>Articles</a> <span class='separator'>&#187;</span> <span class='current'>Driver Programming</span>
                </div>

</div>
  <span class="glink" id="headerlanguages" style="float:right">
        <a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?language=en" class="language-default language-current">en</a>
    </span>


<div class="contenthideright" id="contentcontainer">
<div id="contentcontainerinner">
<div class="leftsidecolumns">
  <div id="contentcolumn"> 
          <div class="main layoutsubsection">
      <div id="contentmenu" class="actionmenu">
    <strong id="xwikicontentmenutitle" class="hidden">Page Actions:</strong>
<div class="rightmenu">
</div>
<div class="leftmenu">
  <div id="tmExport" class="tmExport topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Export</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/export/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?format=pdf&amp;language=en" id="tmExportPdf" class="tmExportPdf">Export as PDF</a></span>
  <span class="submenuitem "><a href="/bin/export/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?format=rtf&amp;language=en" id="tmExportRtf" class="tmExportRtf">Export as RTF</a></span>
  <span class="submenuitem "><a href="/bin/export/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?format=html&amp;language=en" id="tmExportHtml" class="tmExportHtml">Export as HTML</a></span>
    </span></div>

<div id="tmShow" class="tmShow topmenuentry dropdownmenuentry  " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?viewer=code&amp;language=en"><strong>View</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem "><a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?viewer=comments&amp;language=en" id="tmViewComments" class="tmViewComments">Comments</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?viewer=attachments&amp;language=en" id="tmViewAttachments" class="tmViewAttachments">Attachments</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?viewer=history&amp;language=en" id="tmViewHistory" class="tmViewHistory">History</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?viewer=information&amp;language=en" id="tmViewInformation" class="tmViewInformation">Information</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?viewer=code&amp;language=en" id="tmViewSource" class="tmViewSource">View Source</a></span>
</span></div>

  <div id="tmMoreActions" class="tmMoreActions topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>More actions</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?xpage=print&amp;language=en" id="tmPrintPreview" class="tmPrintPreview">Print preview</a></span>
          <span class="submenuitem "><a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming?xpage=copy" id="tmActionCopy" class="tmActionCopy">Copy</a></span>
      </span></div>
</div>

    </div>
    <div id="mainContentArea">
      








    
<div id="document-title"><h1>Driver Programming</h1></div>





              <div id="document-info">
    <div>
          </div>
    <div class="clearfloats"></div>
  </div>

<div id="xwikicontent">
<h1 id="HInsideOpenSolaris:SolarisDriverProgramming"><span>Inside OpenSolaris: Solaris Driver Programming</span></h1><h3 id="HbyMaxBruning"><span>by Max Bruning</span></h3><p>April 15, 2005</p><p>This article describes Solaris device drivers programming in terms that a developer of Linux device drivers will understand. Basically, the article attempts to answer the question, "A Linux driver does <em>xxx</em>, how does one do this in Solaris?" A previous article, Introduction to Solaris Drivers, explained the system architecture and driver visibility on Solaris. This article explains basic driver programming. We assume some familiarity with device drivers and devices and in general discuss Solaris 10 and Linux 2.6. Most of the article should hold for earlier releases of either system.</p><p>The topics covered are:</p><ul><li>Overview of Solaris Device Drivers<ul><li>DDI/DKI</li><li>Data Structures</li><li>Loading/Unloading</li><li>Autoconfiguration</li><li>Open, Close, Read, Write</li></ul></li><li>Driver/Kernel Support Utilities<ul><li>Managing Driver State</li><li>Synchronization Mechanisms</li><li>Dynamic Memory Allocation</li><li>Device Register Access</li><li>Interrupt Handling</li><li>DMA</li><li>Timing and Timers</li><li>Stacks</li><li>Error Handling</li><li>Table of Linux/Solaris Differences/Compatibilities</li></ul></li></ul><p>Overview of Solaris Device Drivers</p><p>This section gives an overview of drivers on Solaris. It is not a complete description of all driver routines, but gives some idea of the overall structure of a Solaris driver and examines many of the routines that a driver implementer must provide.</p><p>DDI/DKI</p><p>On Solaris, the Device Driver Interface (DDI) and Driver/Kernel Interface (DKI) define the entry points to a driver and the kernel routines and data structures that a driver may use. The DDI defines the routines that a driver needs to supply in order to work with Solaris. The DKI (Driver/Kernel Interface) defines the data structures and kernel routines that a driver may use. By using the documented DDI/DKI interfaces, device driver writers receive source and binary compatibility across different releases of the OS. On Linux, because driver writers have had full access to the kernel source code, a driver writer could make use of any kernel routine or data structure. Now that all of the Solaris kernel source will be available, a programmer could use any kernel routine or data structure. However, it's still a good idea to adhere to the DDI/DKI. If there is a routine or data structure missing from the DDI/DKI that you need, then you should present an argument for including it in the DDI/DKI. Having said that, the DDI/DKI does not preclude you from using undocumented routines. In other words, don't let the DDI/DKI stand in the way of making your device work. On the other hand, don't assume that your driver will continue to work in future releases, as undocumented routines and data structures may change.</p><p>Where is the DDI/DKI? In the manual! Section 9 of the manual documents all driver entry points, kernel routines, and kernel data structures in the DDI/DKI. Driver entry points are in Section 9e, kernel functions in Section 9f, data structures in Section 9s, and device properties in Section 9p. For instance, suppose you need to schedule a function to run at some time in the future, possibly to set a timer or to check the status of a device. One approach is to search the source code. A better approach is to use <span class="box code">apropos time</span> or <span class="box code">man <span style="color: #666666; ">-</span>k time</span> (though you may need to use <span class="box code">catman <span style="color: #666666; ">-</span>w</span> for these commands to work). These commands will probably give you more information than you want, as they show all manual pages with <span class="box code">time</span> in the <span class="box code">NAME</span> section of the manual page. I prefer a quicker method:</p><pre>
bash-2.05b# cd /usr/man/sman9f
bash-2.05b# ls *time*
cv_timedwait.9f qtimeout.9f
cv_timedwait_sig.9f quntimeout.9f
ddi_get_time.9f timeout.9f
devmap_set_ctx_timeout.9f untimeout.9f
gethrtime.9f
bash-2.05b#
</pre><p>A brief examination of the pages shows that <span class="box code">timeout(9f)</span> is probably the routine to use. Possibly the best method is to look it up in the <span class="wikiexternallink"><a href="http://docs.sun.com/app/docs/doc/816-4854">Writing Device Drivers</a></span> guide.</p><p>It's possible that you won't find the function you need, or that the function you find is not quite right. <span class="box code">timeout(9f)</span>, for instance, gives you <em>clock tick granularity</em>. Clock ticks are usually ten milliseconds. If you need a function with finer timing, you might find it in the source code, but if it's not documented, it is not in the DDI/DKI. You can use the function, but it may not work the same way, take the same parameters, or even return the same value in a future release.</p><p><em>Solaris Driver Data Structures</em></p><p>Minimally, Solaris drivers must have the following data structures:</p><ul><li><strong><span class="box code">modlinkage(9s)</span></strong>: Used to install, remove, and retrieve information about the driver.</li><li><strong><span class="box code">modldrv(9s)</span></strong>: Used for linking the driver into the kernel.</li><li><strong><span class="box code">dev_ops(9s)</span></strong>: Device operations common to nexus and leaf node drivers.</li><li><strong><span class="box code">cb_ops(9s)</span></strong>: Entry points for character and block drivers.</li></ul><p>Note that some types of devices (including STREAMS, GLD, SCSA and USB) may need additional structures. The following shows the structures as defined in <em>/usr/include/sys/devops.h</em> or <em>/usr/include/sys/modctl.h</em>.</p><pre>
struct modlinkage { /* from sys/modctl.h */
 int ml_rev; /* rev of loadable modules system */
#ifdef _LP64
 void *ml_linkage[7]; /* more space in 64-bit OS */
#else
 void *ml_linkage[4]; /* NULL terminated list of */
 /* linkage structures */
#endif
};

struct modldrv { /* also in sys/modctl.h */
 struct mod_ops *drv_modops; /* must be &amp;mod_driverops */
 char *drv_linkinfo; /* typically, "name version #" */
 struct dev_ops *drv_dev_ops;
};

struct dev_ops { /* in sys/devops.h */
 int devo_rev; /* Driver build version */
 int devo_refcnt; /* device reference count */

 int (*devo_getinfo)(dev_info_t *dip,
 ddi_info_cmd_t infocmd, void *arg, void **result);
 int (*devo_identify)(dev_info_t *dip);
 int (*devo_probe)(dev_info_t *dip);
 int (*devo_attach)(dev_info_t *dip, ddi_attach_cmd_t cmd);
 int (*devo_detach)(dev_info_t *dip, ddi_detach_cmd_t cmd);
 int (*devo_reset)(dev_info_t *dip, ddi_reset_cmd_t cmd);

 struct cb_ops *devo_cb_ops; /* cb_ops pointer for leaf drivers */
 struct bus_ops *devo_bus_ops; /* bus_ops pointer for nexus drivers */
 int (*devo_power)(dev_info_t *dip, int component,
 int level);
};

struct cb_ops {
 int (*cb_open)(dev_t *devp, int flag, int otyp, cred_t *credp);
 int (*cb_close)(dev_t dev, int flag, int otyp, cred_t *credp);
 int (*cb_strategy)(struct buf *bp);
 int (*cb_print)(dev_t dev, char *str);
 int (*cb_dump)(dev_t dev, caddr_t addr, daddr_t blkno, int nblk);
 int (*cb_read)(dev_t dev, struct uio *uiop, cred_t *credp);
 int (*cb_write)(dev_t dev, struct uio *uiop, cred_t *credp);
 int (*cb_ioctl)(dev_t dev, int cmd, intptr_t arg, int mode,
 cred_t *credp, int *rvalp);
 int (*cb_devmap)(dev_t dev, devmap_cookie_t dhp, offset_t off,
 size_t len, size_t *maplen, uint_t model);
 int (*cb_mmap)(dev_t dev, off_t off, int prot);
 int (*cb_segmap)(dev_t dev, off_t off, struct as *asp,
 caddr_t *addrp, off_t len, unsigned int prot,
 unsigned int maxprot, unsigned int flags, cred_t *credp);
 int (*cb_chpoll)(dev_t dev, short events, int anyyet,
 short *reventsp, struct pollhead **phpp);
 int (*cb_prop_op)(dev_t dev, dev_info_t *dip,
 ddi_prop_op_t prop_op, int mod_flags,
 char *name, caddr_t valuep, int *length);

 struct streamtab *cb_str; /* streams information */

 /*
 * The cb_flag fields are here to tell the system a
 * bit about the device. The bit definitions are
 * in &lt;sys&gt;.
 */
 int cb_flag; /* driver compatibility flag */
 int cb_rev; /* cb_ops version number */
 int (*cb_aread)(dev_t dev, struct aio_req *aio, cred_t *credp);
 int (*cb_awrite)(dev_t dev, struct aio_req *aio, cred_t *credp);
};
</pre><p><strong>Note</strong>: Many data structures in Linux do their initialization via a <span class="box code"><span style="color: #666666; ">.//</span>tag<span style="color: #666666; ">//</span></span> field. Solaris currently does not do this (perhaps due to a compiler issue). For example, Linux may initialize the following structure:</p><pre>
struct foo {
 int a;
 int b;
};
</pre><p>with code such as:</p><pre>
struct foo foobar = {
 .a = 10,
 .b = 20
};
</pre><p>where the Solaris initialization is typically:</p><pre>
struct foo foobar = {
 10, /* a */

 20 /* b */
};
</pre><p>In other words, Solaris uses comments instead of the <span class="box code"><span style="color: #666666; ">.//</span>tag<span style="color: #666666; ">//</span></span> idiom.</p><p>The following shows an example using the structures for a simple character device, the <span class="box code">foo</span> device.</p><pre>
static struct cb_ops foo_cb_ops = {
 foo_open,
 foo_close,
 nodev, /* strategy only for block devices */
 nodev, /* print only for block devs */
 nodev, /* " " " " " */
 foo_read,
 foo_write,
 foo_ioctl,
 nodev, /* no devmap (no mmap support) */
 nodev, /* no mmap */
 nodev, /* no segmap (for mmap) */
 nochpoll, /* no poll support */
 ddi_prop_op, /* let nexus node above driver handle property requests */
 NULL, /* no streamtab (not a STREAMS device) */
 D_MP, /* cb_flag, (other flags for STREAMS driver) */
 CB_REV, /* revision number of cb_ops */
 nodev, /* no async read */
 nodev /* no async write */
};

static struct dev_ops foo_dev_ops = {
 DEVO_REV, /* revision number of this struct (compatibility) */
 0, /* devo_refcnt, set by driver framework */
 foo_getinfo,
 nulldev, /* identify, obsolete since solaris 2.6 */
 nulldev, /* probe, must return success for driver to attach */
 foo_attach,
 foo_detach,
 nodev, /* no reset */

 &amp;foo_cb_ops,
 NULL, /* no bus_ops (needed for nexus devices) */
 nodev /* no power(9e) */
};

static struct modldrv foo_modldrv = {
 &amp;mod_driverops, /* must be this value, identifies module as a driver */
 "foo driver version 0.1",
 &amp;foo_dev_ops
};

static struct modlinkage foo_ml = {
 MODREV_1, /* revision number of structure (compatibility) */
 &amp;foo_modldrv,
 0
};
</pre><p>Loading/Unloading</p><p>A Solaris driver has three routines involved in loading and unloading a driver. These are <span class="box code">_init(9e)</span>, <span class="box code">_info(9e)</span>, and <span class="box code">_fini(9e)</span>. Not only does every driver in Solaris have these routines, but, in fact, almost every other type of kernel module includes them. The kernel runtime linker, <span class="box code">krtld</span>, expects to find these routines. If it doesn't, your driver won't be (dynamically) linked into the system.</p><p><strong>Note</strong>: All drivers on Solaris are dynamically linked into the system, typically at boot or at the first access of the device. Your driver must be dynamically loadable.</p><p><strong>Note</strong>: Most Solaris driver functions return <span class="box code">0 (DDI_SUCCESS)</span> on success and a positive <span class="box code">errno</span> on failure, unlike Linux, which returns a negative <span class="box code">errno</span> on failure. Any returned values typically go into a passed-in argument.</p><p>The following shows an example of using these routines.</p><pre>
int
_init(void)
{
 int error;
 /*
 * allocate and initialize any data needed for all
 * instances of the device, (per device instance data
 * is allocated and initialized in attach(9e)
 */

 error = mod_install(&amp;foo_ml);
 return (error);
}

int
_fini(void)
{
 int error;

 error = mod_remove(&amp;foo_ml);
 if (error == 0)
 /*
 * de-initialize and free data allocated in _init()
 */
 ;
 return (error);
}

int
_info(struct modinfo *modinfop)
{
 return (mod_info(&amp;foo_ml, modinfop));
}
</pre><p>Autoconfiguration</p><p>Each instance of a device is automatically configured during boot or driver installation. This is done by the <span class="box code">attach(9e)</span> entry point, which the kernel calls for each instance of the device. Instances are either recognized by the hardware/boot system, or configured by entries in a <span class="box code">driver.conf(4)</span> file. An optional <span class="box code">probe(9e)</span> routine is called to determine if a configured instance actually exists on the system. The <span class="box code">probe(9e)</span> entry point need not exist for "self-identifying" devices. Any device plugged into a PCI-type bus is self-identifying. SCSI targets and pseudo devices must have a probe entry to see if the device actually exists. Drivers also have a <span class="box code">detach(9e)</span> entry to un-configure an instance or all instances.</p><p>The <span class="box code">attach(9e)</span> and <span class="box code">detach(9e)</span> routines are also called for dynamic reconfiguration support and for the hot-plugging of devices.</p><p>The <span class="box code">driver.conf(4)</span> file is optional. PCI devices don't need it, but it works with such devices to set different properties. The following shows an example <em>driver.conf</em> file for a pseudo device.</p><pre>
# foo.conf (typically in /usr/kernel/drv/foo.conf)
name="foo" parent="pseudo" instance=0;
name="foo" parent="pseudo" instance=100;
</pre><p>The <span class="box code">instance</span> number is passed to various driver routines. It is the driver's responsibility to maintain a mapping of instance numbers to minor device numbers. The simplest mapping is one to one, where the instance number and minor number are the same, but there may be other mappings. For example, a driver for an RS-232C controller with eight serial ports might store the port number in the low order three bits, and the instance number in the high order 29 bits of the minor number. The OS (or <em>driver.conf</em>) chooses the instance number for a given controller, passing it to the driver as a field in a <span class="box code">dev_info_t</span> structure. The <span class="box code">dev_info_t</span> is meant to be opaque, but DDI routines can retrieve various fields, including the instance number.</p><p>The <span class="box code">probe(9e)</span> routine should clean up any device state info before returning, making it stateless. If you don't need a <span class="box code">probe(9e)</span> routine, you can just return <span class="box code">DDI_PROBE_SUCCESS</span> or use <span class="box code">nulldev(9f)</span> in the <span class="box code">dev_ops(9s)</span> structure for the probe entry. The following shows a pseudo-code example <span class="box code">probe(9e)</span> entry point.</p><pre>
static int
foo_probe(dev_info_t *dip)
{
 int instance;
 int rval;

 instance = ddi_get_instance(dip);
 ddi_regs_map_setup(...); /* get a handle for accessing device registers */
 rval = ddi_peek8(dip, ...); /* try to read an 8bit register on the device */
 ddi_regs_map_free(...); /* unmap the handle returned from ddi_regs_map_setup */

 if (rval == DDI_FAILURE)
 return DDI_PROBE_FAILURE; /* device does not currently exist */

 else
 return DDI_PROBE_SUCCESS;
}
</pre><p>The <span class="box code">attach(9e)</span> entry point is called following a successful <span class="box code">probe(9e)</span> to make the device "visible" on the system. It typically allocates state, acquires handle(s) for the device's registers, registers an interrupt handler, does any device-specific hardware initialization, and creates minor device nodes so as to make the device(s) accessible via user <span class="box code">open(2)</span> calls. Once <span class="box code">attach(9e)</span> has run for a given device instance, files will appear in the <em>/devices</em> tree for each new minor node.</p><p>The following shows a pseudo-code example of <span class="box code">attach(9e)</span>.</p><pre>
static int
foo_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
 int instance;

 instance = ddi_get_instance(dip);
 allocate and initialize any needed state for this instance;
 ddi_regs_map_setup(...); /* get a handle for registers */
 ddi_dma_alloc_handle(...); /* if device does DMA */
 initialize hardware;
 ddi_add_intr(...); /* register the interrupt handler */
 ddi_create_minor_node(...); /* create minor device node */
 return DDI_SUCCESS;
}
</pre><p>Note that the kernel may call <span class="box code">ddi_regs_map_setup(9f)</span>, <span class="box code">ddi_add_intr(9f)</span>, and <span class="box code">ddi_create_minor_node(9f)</span> multiple times if there are multiple sets of registers, there is more than one interrupt handler, or you need multiple minor devices for the instance. Also note that the <span class="box code">cmd</span> argument is either <span class="box code">DDI_ATTACH</span> or <span class="box code">DDI_RESUME</span>. The example above is basic handling for <span class="box code">DDI_ATTACH</span>. <span class="box code">DDI_RESUME</span> handles dynamic reconfiguration and power management.</p><p>The <span class="box code">detach(9e)</span> entry undoes the setup done by <span class="box code">attach(9e)</span> when the device falls out of use. Here is a pseudo-code example:</p><pre>
static int
foo_detach(dev_info_t *dip, ddi_detach_cmd_t cmd) /* cmd = DDI_DETACH or DDI_SUSPEND */
{
 int instance;
 instance = ddi_get_instance(dip);
 ddi_remove_minor_node(...);
 de-initialize hardware; /* disable interrupts, etc. */
 ddi_remove_intr(...);
 ddi_regs_map_free(...);
 return DDI_SUCCESS;
}
</pre><p>Open, Close, Read, Write</p><p>Unlike Linux, Solaris drivers do not access data structures such as <span class="box code">inode</span>s or <span class="box code">file</span>s. In general, the only drivers should only access structures passed into entry points, structures that the driver itself declares, and structures specified by the DDI (manual section 9s). This allows kernel structures to change over time without needing to make changes to the driver. Fields within kernel data structures that a driver might need (for instance, the current location of read/write in a device), are arguments to functions, not the structures themselves. If you think you need access to kernel structures outside of the DDI/DKI, you are probably not using the DDI/DKI correctly. Of course, source code access makes all structures and kernel routines "visible" to a programmer. Still, to avoid having to change your driver if a new release of Solaris changes the structure or routine, you should try to stick with the DDI/DKI.</p><p>The following shows pseudo-code examples of driver <span class="box code">open(9e)</span>, <span class="box code">close(9e)</span>, <span class="box code">read(9e)</span>, and <span class="box code">write(9e)</span>. <span class="wikiexternallink"><a href="http://docs.sun.com/app/docs/doc/816-4854">Writing Device Drivers</a></span> has examples of using <span class="box code">ioctl(2)</span>, <span class="box code">mmap(2)</span> -related routines, <span class="box code">poll(2)</span>, and block-driver-related routines.</p><pre>
static int
foo_open(dev_t *devp, int flag, int otyp, cred_t *cred_p) /* called for open(2) or OTYP_LYR */
{
 instance = get instance from minor device number; /* driver specific */
 if (no state for this instance)
 return ENXIO;
 initialize driver for this open;
 handle exclusive open if needed;
 wait for device to be "on-line", if needed;
 return DDI_SUCCESS;
}

static int
foo_close(dev_t dev, int flag, int otyp, cred_t *cred_p) /* called only on last close of minor dev */
{
 undo any initialization done by open;
 return DDI_SUCCESS;
}

static int
foo_read(dev_t dev, struct uio *uio_p, cred_t *cred_p) /* called from read(2) */
{
 copy/dma data from device to user address space via uio_p; /* see uio(9s) */
 return DDI_SUCCESS; /* uio_p will contain # of bytes read */
}

static int
foo_write(dev_t dev, struct uio *uio_p, cred_t *cred_p) /* called from write(2) */
{
 copy/dma data from user address space via uio_p to device;
 return DDI_SUCCESS;
}
</pre><p>Kernel Support Utilities</p><p>State Handling</p><p>To help manage per-instance state, the DDI/DKI provides a set of routines. Per-instance state can include anything you need to keep track of the state for a given device instance. These routines maintain the space for state. You simply request space allocation, retrieve a pointer to the allocated space, initialize the state, update the state, and, when the instance no longer exists, free the state. The kernel manages state (linked list, array, tree, etc.) for you. All of the state routines take either a <span class="box code">dev_info_t</span> or instance number as an argument. The driver needs a way to fetch an instance number from the minor device number, but the implementation is up to the driver. The most simple is to make instance number and minor device number equivalent. Note that the instance number is a field in the <span class="box code">dev_info_t</span>, retrievable through <span class="box code">ddi_get_instance(9f)</span>.</p><p>The state management routines are:</p><ul><li><strong><span class="box code">ddi_soft_state_init(9f)</span></strong>: Called by the driver's <span class="box code">_init(9e)</span> to allocate a handle to be used with the other DDI state routines.</li><li><strong><span class="box code">ddi_soft_state_zalloc(9f)</span></strong>: Called by <span class="box code">attach(9e)</span> to allocate and zero out state for a given instance.</li><li><strong><span class="box code">ddi_get_soft_state(9f)</span></strong>: Called by the driver to retrieve the state structure for a given instance.</li><li><span class="box code"><span style="color: #666666; ">**</span>ddi_soft_state_free(9f)<span style="color: #666666; ">**</span></span>: Called by <span class="box code">detach(9e)</span> to free the state structure for a given instance of the device.</li><li><span class="box code"><span style="color: #666666; ">**</span>ddi_soft_state_fini(9f)<span style="color: #666666; ">**</span></span>: Called by <span class="box code">_fini(9e)</span> to free the handle initialized by <span class="box code">ddi_soft_state_init(9f)</span>.</li></ul><p>Of course, the device might not have state (doubtful), or you might choose to manage your own state.</p><p>Synchronization Mechanisms</p><p>Solaris provides four synchronization mechanisms within the kernel to protect simultaneous access and modification of data by multiple threads running in the kernel. These mechanisms are advisory, so you don't have to use them. However, failure to use them where needed will almost certainly result in corrupted or inconsistent data and panics. The synchronization mechanisms are:</p><ul><li><em>Mutexes</em>, or mutual exclusion locks. These can be spin or adaptive. Spin mutexes spin if someone already owns the mutex. Adaptive mutexes spin if the owner is running on a processor, and block (switch out) if the owner is not running. In addition, spin mutexes mask interrupts at the level associated with the mutex.</li><li><em>Condition variables</em>, which provide a "sleep/wakeup" type mechanism.</li><li><em>Semaphores</em>, either counting or binary, implemented via <span class="box code">p</span> and <span class="box code">v</span> operations.</li><li><em>Reader/writer locks</em>, or shared/exclusive locks.</li></ul><p>The mutex is the fundamental mechanism underlying the other mechanisms. Here is an example of using mutexes:</p><pre>
kmutex_t mp; /* must be global, may be dynamically allocated, usually in per-instance state */

 &lt;~--// in _init() or xxx_attach()// ~--&gt;

 /* initialize mutex(es) */
 ddi_get_iblock_cookie(devinfop, 0, &amp;iblock_cookie); /* needed if device interrupts */
 mutex_init(&amp;mp, NULL, MUTEX_DRIVER, iblock_cookie); /* otherwise, iblock_cookie = NULL */

 &lt;~-- //to use the mutex// ~--&gt;

 mutex_enter(&amp;mp); /* acquire the mutex */
 critical code goes here;
 mutex_exit(&amp;mp); /* release the mutex */

 &lt;~--// in _fini() or xxx_detach()// ~--&gt;

 mutex_destroy(&amp;mp);
</pre><p>Recursive (iterative) mutexes result in panic (unlike Linux). Hierarchical deadlock also results in panic. Fix your bugs!</p><p>The following shows an example use of condition variables, though it leaves off the initialization step.</p><pre>
kcondvar_t cv; /* the condition variable itself is opaque */
kmutex_t mp; /* must use mutex */
int flag = 0; /* represents the condition, event, resource, etc. you are waiting on */

 &lt;~--//thread that needs to wait//~--&gt;

 mutex_enter(&amp;mp);
 while (flag == 0) /* while condition not met, resource not available, event has not occurred, etc. */
 cv_wait(&amp;cv, &amp;mp); /* mutex is released and thread is switched out */
 /* before returning, mutex is re-acquired */
 handle condition, resource, event, etc; /* here we own the mutex */
 mutex_exit(&amp;mp);

 &lt;~--//wakeup thread (typically interrupt handler)// ~--&gt;

 mutex_enter(&amp;mp);
 ++flag;
 cv_signal(&amp;cv); /* or cv_broadcast(&amp;cv), i.e, wakeup one or all */
 mutex_exit(&amp;mp);
</pre><p>Dynamic Memory Allocation</p><p>Dynamic memory allocation typically uses <span class="box code">kmem_alloc(9f)</span> and <span class="box code">kmem_free(9f)</span>. Also, drivers can use <span class="box code">kmem_cache_create(9f)</span>, <span class="box code">kmem_cache_destroy(9f)</span>, <span class="box code">kmem_cache_alloc(9f)</span>, and <span class="box code">kmem_cache_free(9f)</span>. For allocation of DMA-able memory, use <span class="box code">ddi_dma_mem_alloc(9f)</span>.</p><p>The <span class="box code">kmem_alloc(9f)</span> routine takes a size in bytes and a flag as arguments. The flag simply specifies what to do if the space is not available--either <span class="box code">KM_SLEEP</span> or <span class="box code">KM_NOSLEEP</span>. In the <span class="box code">KM_NOSLEEP</span> case, <span class="box code">kmem_alloc()</span> returns a <span class="box code">NULL</span> pointer, leaving recovery to the caller.</p><p>Device Register Access</p><p>To access device registers (and device memory), use the <span class="box code">ddi_regs_map_setup(9f)</span> and <span class="box code">ddi_get<span style="color: #666666; ">/</span>ddi_put</span> routines. When dealing with a memory mapped device (a frame buffer, for example), map in the buffer using <span class="box code">ddi_regs_map_setup(9f)</span>, and then use the address returned to you to access the device. The following example works for a simple, made-up, device.</p><pre>
ddi_device_acc_attr_t foo_acc = { /* used for endianess, ordering constraints */
 DDI_DEVICE_ATTR_V0, /*revision number of structure */
 DDI_STRUCTURE_LE_ACC, /* device is little endian */
 DDI_STRICTORDER_ACC /* all references are issued by cpu in program order, (no re-ordering) */
};

char *dev_regs; /* will point to device registers, or contain port number */
ddi_acc_handle_t *foo_acc_handle; /* filled by ddi_regs_map_setup */

 &lt;~-- //in foo_attach// ~--&gt;

 ddi_regs_map_setup(devinfop, 0, &amp;dev_regs, 0, 0, &amp;foo_acc, &amp;foo_acc_handle);

 &lt;~-- //to access device registers// ~--&gt;

 x = ddi_get8(foo_acc_handle, dev_regs); /* retrieve 8 byte register */
</pre><p>Interrupt Handling</p><p>Solaris interrupt handling is similar to Linux. You may implement an interrupt handler that services the interrupt and returns, or you may implement two interrupt handlers. The first handles the hardware interrupt and a second runs at a lower priority as a software interrupt. Linux tasklets can be implemented using a routine that runs from <span class="box code">timeout(9f)</span>. Solaris does have task queues, but at present there is no programming interface visible in the DDI/DKI.</p><p>Solaris maps interrupts to one of 15 priority levels, where the higher the level, the higher the priority. Interrupts above level 10 are called "high priority interrupts." They run in their own threads. This means they may block (due to trying to obtain an already locked mutex, for instance). Interrupts above level 10 run in the context of the thread that was running when the interrupt occurred. Mutexes associated with high-level interrupts are spin mutexes, and the system masks out interrupts at the level associated with the mutex. The system <span class="box code">clock()</span> routine, responsible for time slicing, runs at interrupt level 10. Bus drivers choose the interrupt priorities for devices on the nexus. PCI bus drivers use the class-code configuration space register to assign interrupt levels. For ISA and EISA nexus drivers, the level of all devices is IPL5. A given device instance may be overridden by setting <span class="box code">interrupt<span style="color: #666666; ">-</span>priorities=<span style="color: #666666; ">//</span>level<span style="color: #666666; ">//</span></span> in the <span class="box code">driver.conf(4)</span> file. For more information, see <span class="box code">sysbus(4)</span>.</p><p>The steps taken for handling an interrupt are:</p><ol><li>Register interrupt handler(s) in <span class="box code">attach(9e)</span> via <span class="box code">ddi_add_intr(9f)</span> and, optionally, <span class="box code">ddi_add_softintr(9f)</span>.</li><li>The handler should: </li></ol><ul><li>Check to see if the device is interrupting. If not, return <span class="box code">DDI_INTR_UNCLAIMED</span>. If the driver returns <span class="box code">DDI_INTR_UNCLAIMED</span>, code above the driver will try calling the next interrupt handler for the next device (if any) that interrupts at the same priority level. In other words, Solaris polls driver interrupt handlers based on interrupt priority level.</li><li>Perform any hardware-specific tasks to handle the interrupt.</li><li>Tell the device the interrupt has been handled. This step is necessary for devices that use level-triggered interrupts.</li><li>Return <span class="box code">DDI_INTR_CLAIMED</span>.</li></ul><p>For high-level interrupts, it is preferable to do the minimum possible in the high-level handler and trigger a software interrupt to do any additional processing.</p><p>The following example shows an <span class="box code">attach(9e)</span> registering an interrupt handler and the handler doing its work.</p><pre>
static uint_t foo_intr(caddr_t arg);

static int
foo_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
 int instance;
 struct foo_state *fsp;

 instance = ddi_get_instance(dip);
 ddi_soft_state_zalloc(statep, instance);

 fsp = ddi_get_soft_state(statep, instance);

 initialize fsp;

 initialize mutexes, etc.;

 ddi_add_intr(dip, 0, NULL, &amp;idevice_cookie, foo_intr, (caddr_t)fsp);

 other initialization (ddi_create_minor_node, etc.);
}

static uint
foo_intr(caddr_t arg)
{
 struct foo_state *fsp = (struct foo_state *)arg;

 read device register to determine if device is generating interrupt;
 if (not my device interrupting)
 return DDI_INTR_UNCLAIMED;

 handle device interrupt;

 write to device to tell it the interrupt has been handled;

 return DDI_INTR_CLAIMED;
}
</pre><p>DMA</p><p>Solaris and Linux both provide a layer of data abstraction to hide DMA platform differences. The generic DMA layer is new for Linux 2.6. Here, we show the steps taken for DMA in a Solaris driver. Note that the code should be identical regardless of whether the device is on SPARC or x86.</p><p>The steps taken for DMA are:</p><ol><li>Allocate and initialize a <span class="box code">ddi_dma_attr(9s)</span>, which describes device and DMA-engine-specific attributes. This is typically a global, static initialization within the driver.</li><li>Allocate a DMA "handle" via <span class="box code">ddi_dma_alloc_handle(9f)</span>, either in <span class="box code">attach(9e)</span> or just prior to programming the device to do a specific DMA transfer.</li><li>Bind an address to the handle via <span class="box code">ddi_dma_addr_bind_handle(9f)</span> or <span class="box code">ddi_dma_buf_bind_handle(9f)</span>. These routines return a DMA "cookie" (or cookies) that contain the address(es) and size(s) to use to program the device to do DMA.</li><li>Program the device to do DMA. This is device-specific.</li><li>On completion, you may need to sync caches via a call to <span class="box code">ddi_dma_sync(9f)</span>.</li><li>When finished with the I/O, call <span class="box code">ddi_dma_unbind_handle(9f)</span> to free up DMA resources.</li><li>When finished with the handle (or in <span class="box code">detach(9e)</span>), use <span class="box code">ddi_dma_free_handle(9f)</span>.</li></ol><p>Here is an example for a PCI device.</p><pre>
static ddi_dma_attr_t foo_dma_attr = {
 DMA_ATTR_V0, /* version of this structure */
 0, /* lowest usable address */
 0xffffffffU, /* highest usable address */
 0x0ffffff, /* maximum DMAable byte count */
 1, /* alignment in bytes */
 0x7f, /* bitmap of burst sizes */
 1, /* minimum transfer */
 0x0ffffffU, /* maximum transfer */
 0x0ffffffU, /* maximum segment length */
 1, /* maximum number of segments */
 1, /* granularity */
 0, /* flags (reserved) */
};

ddi_dma_handle_t foo_dma_handle; /* typically in per-instance state */

foo_attach(dev_info_t *dip, ddi_attach_cmd_t cmd))
{
 ...
 if (ddi_dma_alloc_handle(dip, &amp;foo_dma_attr,
 DDI_DMA_SLEEP, 0, &amp;foo_dma_handle) != DDI_SUCCESS)
 return (DDI_FAILURE);
 ...
}

foo_startio(...) /* the routine to do the DMA */
{
 ddi_dma_cookie_t dma_cookie;
 uint32_t ncookies;
 caddr_t addr; /* do dma to/from this address, */
 /* possible from ddi_dma_mem_alloc(9F) */
 size_t len; /* number of bytes to do dma to/from */
 uint_t flags;

 ...
 flags = DDI_DMA_RDWR | DDI_DMA_STREAMING; /* or DDI_DMA_CONSISTENT, etc. */
 ddi_dma_addr_bind_handle(foo_dma_handle, 0, addr, len, flags,
 DDI_DMA_DONTWAIT, NULL, &amp;dma_cookie, &amp;ncookies);

 ddi_put32(foo_acc_handle, dev_regs+DMA_ADDR, dma_cookie.dmac_address);
 ddi_put32(foo_acc_handle, dev_regs+DMA_SIZE, dma_cookie.dma_size);

 ddi_put32(foo_acc_handle, dev_regs+CMD, GO);
}
</pre><p>On completion, the driver interrupt handler calls <span class="box code">ddi_dma_unbind_handle(9f)</span> and possibly <span class="box code">ddi_dma_sync(9f)</span>. The <span class="box code">detach(9e)</span> routine calls <span class="box code">ddi_dma_free_handle(9f)</span>.</p><p>Timing and Timers</p><p>Solaris timing uses a real-time clock that can generate interrupts at a resolution bound by the processor speed. For scheduling purposes, it fires every 10 milliseconds. As in Linux, this is a clock "tick." Note that 2.6 Linux uses a 1000-tick/second clock, as opposed to the 100-tick/second clock used by Solaris and by previous versions of Linux. User-level programs on Solaris can program the real time clock to fire at nanosecond granularity, rounded up by processor time--much finer than the clock tick granularity of ten or one milliseconds. However, the program interface to use the high-resolution timers is not visible in the DDI/DKI. See <span class="box code">clock_settime(3rt)</span> for user-level details and <em>usr/src/uts/common/os/cyclic.c</em> for details on high-resolution timing in Solaris.</p><p>Also note that in Solaris, you can change the value of <span class="box code">hz</span> or clock ticks/second by setting <span class="box code">hires_tick</span> to 1 and <span class="box code">hires_hz</span> to the desired time in the <em>/etc/system</em> file. The default is 1000 ticks per second. Here's an example:</p><pre>
set hires_tick=1
set hires_hz=10000 &lt;~--- 10000 ticks per second.
</pre><p>High values for <span class="box code">hires_hz</span> are not recommended. With the above value, the <span class="box code">clock()</span> routine runs 10000 times per second, probably taking more overhead than you want or need. The time-related routines visible in the DDI/DKI are:</p><ul><li><span class="box code">timeout_id_t timeout(void(<span style="color: #666666; ">*</span> func)(void <span style="color: #666666; ">*</span>), void <span style="color: #666666; ">*</span>arg, clock_t ticks)</span>, which schedules a function to run after a specified time measured in clock ticks. This fires a "one-shot" timer. If you want it to go off again (periodically, perhaps), call <span class="box code">timeout()</span> again, probably in your <span class="box code">func()</span>.</li><li><span class="box code">clock_t untimeout(timeout_id_t id)</span>, to cancel a previous call to <span class="box code">timeout(9f)</span>. Take care with locks. See the manual pages for details.</li><li><span class="box code">void drv_usecwait(clock_t microsecs)</span>, providing a busy-wait for <span class="box code">microsecs</span> microseconds. The real time clock (not the 10ms clock) may cause the rounding up of microseconds. You can be preempted or interrupted during this spin. If you don't want that, use <span class="box code">ddi_enter_critical(9f)<span style="color: #666666; ">/</span>ddi_exit_critical(9f)</span> instead.</li><li><span class="box code">clock_t drv_usectohz(clock_t microsecs)</span>, which converts <span class="box code">microsecs</span> to clock ticks. Use this to find the number of clock ticks for a given number of microseconds before calling <span class="box code">timeout(9f)</span>, which requires clock ticks.</li><li><span class="box code">void delay(clock_t ticks)</span>, to delay for a specified number of clock ticks. This function switches out the calling thread; it does not busy wait.</li></ul><p>Stacks</p><p>The kernel allocates stack space on a per-thread basis. Each kernel thread receives 8192 bytes on x86 and 24576 bytes on SPARC for stack space. In addition, a REDZONE page is virtually allocated with no permissions to act as a guard against stack overflow. All of this means that you should be careful about declaring large arrays as local variables. Of course, deep levels of recursion can cause stack overflow problems. If you need a large array for a local variable, it is better to <span class="box code">kmem_alloc()</span> the array on the heap, use it, then <span class="box code">kmem_free()</span> it before returning.</p><p>Error Handling</p><p>In general, driver entry points return <span class="box code">DDI_SUCCESS (0)</span> on success, and a positive value (actually an <span class="box code">errno</span>) on failure. Linux uses negative <span class="box code">errno</span> values for failure indications. The <span class="box code">errno</span> to use should be consistent with the <span class="box code">errno</span>s listed on the man page for the entry point. For instance, if the driver open routine needs to return an error, refer to <span class="box code">open(9e)</span> for a list of possible error returns.</p><p>As for reporting errors, Solaris drivers can use <span class="box code">cmn_err(9f)</span>, which is equivalent in most ways to Linux's <span class="box code">printk()</span>. Handling some types of errors is beyond the scope of this article. For instance, handling failure of <span class="box code">kmem_alloc(9f)</span> can be problematic.</p><p>Table 1. Linux/Solaris Driver Comparison</p><p>Conclusion</p><p>The most important and valuable advice for beginning Solaris driver programming is to follow the documentation of the DDI and DKI. You may occasionally need to step outside of the bounds, but consider carefully if you can achieve your goals while sticking to defined interfaces.</p><p>The next article in this series will discuss more details of writing network drivers.</p><p>Max Bruning currently teaches and consults on Solaris internals, device drivers, kernel (as well as application) crash analysis and debugging, networking internals, and specialized topics. Contact him at max AT bruningsystems DOT com or <span class="wikiexternallink"><a class="wikimodel-freestanding" href="http://mbruning.blogspot.com/."><span class="wikigeneratedlinkcontent">http://mbruning.blogspot.com/.</span></a></span></p>
</div>


    <div class="clearfloats"></div>
  </div>      <div id="xdocFooter">
  
                

       <div class="doc-tags" id="xdocTags">
        Tags:
        </div>
  
  <div id="xdocAuthors">
    <div class="xdocCreation">       Created by admin on 2009/10/26 12:07<br/>
          </div>
    <div class="xdocLastModification">       Last modified by admin on 2009/10/26 12:07
    </div>
  </div>
</div>
<div id="xwikidata" class="layoutsubsection">
        </div>  
    </div>      </div><div id="leftPanels" class="panels left">
                  <div class="panel expanded OSNav">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSNav');">Collectives</h1>
<div class="xwikipanelcontents">
<div id="xwikinavcontainer">
<span class="wikilink"><a href="/bin/view/Main/communities">Community Groups</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/projects">Projects</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/usergroups">User Groups</a></span>
</div><p/>
<script type="text/javascript">
document.observe('xwiki:dom:loaded', function() {
var obj = {div:'xwikinav',no:$count,height:250};
var acc = createAccordion(obj);
});
</script>
</div>
</div>
                        <div class="panel expanded OSDocs">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSDocs');">Community Group advocacy Pages</h1>
<div class="xwikipanelcontents">
<ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/articles">Articles</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/christensen%2Dprofile">Profile: Christensen</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/dtrace%2Dteam%2Dprofile">Profile: DTrace</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/intro%2Dsolaris%2Ddrivers">Solaris Drivers</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/schilling%2Dprofile">Profile: Schilling</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/solaris%2Ddriver%2Dprogramming">Driver Programming</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/solaris%2Dlinux%2Dfreebsd">Solaris, Linux, BSD</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/solaris%2Dx86%2Dnotebooks">Solaris on Notebooks</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/teer%2Dprofile">Profile: Teer</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/tucker%2Dprofile">Profile: Tucker</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/using%2Dvmware">OpenSolaris & VMWare</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/buttons">Fan Buttons</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/files">Files</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/marketing">Marketing</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/articles%2Dvideos%2Dstuff">Articles and Videos</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/buy%2Dswag">OpenSolaris Swag</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/contributoraward">Contributor Awards</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/help">How you can help</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/highlights">Marketing Highlights</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/homepagegraphics">Graphics July 2006</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/immigrants">Immigrants</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/mktg%2Dannouncements">Marketing Announces</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/mktgdownloads">OpenSolaris Artwork</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/merger%2Darchive">Merger Archive</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/newsletter">Newsletter Archive</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/0405">2004&#45;2005</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/2006">2006</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/2007">2007</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/2008">2008</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/2009">2009</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/os%2Dpresentations">OSUG Presentations</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/techdays%2Darchive%2D06%2D07">Tech Days 06&#45;07</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/techdays%2Darchive%2D07%2D08">Tech Days 07&#45;08</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/ug%2Dleaders">User Group Leaders</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+advocacy/usergroups">User Group Background</a></span></li>
</ul>
                              </div>
</div>
      </div>

  </div>
<div class="clearfloats"></div>
  </div></div><div id="footerglobal" class="layoutsection">
<div class="minwidth"></div>
<hr/>
        <div id="xwikiplatformversion">XWiki Enterprise 2.7.1.34853 - <a onclick="openURL('http://enterprise.xwiki.org/xwiki/bin/view/Main/Documentation', '_blank'); return false;" href="http://www.xwiki.org/xwiki/bin/view/Main/Documentation">Documentation</a></div>
<br/>
  
      <div id="footer">
    <p>
                <a href="https://markebrooks.github.io/bin/view/Main/tou/">Terms of Use</a>
                |
                <a href="http://www.oracle.com/html/privacy.html">Privacy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/trademark/">Trademarks</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/copyrights/">Copyright Policy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site_guidelines/">Site Guidelines</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site-map/">Site Map</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/help/">Help</a>
                <br/>Your use of this web site or any of its content or software indicates your agreement to be bound by these Terms of Use.<br/>
                &copy; 2012, Oracle Corporation and/or its affiliates.<br/><img src="https://markebrooks.github.io:443/static/images/logo_oracle_footer.gif" alt="Oracle Logo"/>
            </p>
        </div>

  
</div>

</div></div></body>
</html>
