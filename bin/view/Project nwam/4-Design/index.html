<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
                    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
                                    <title>Design (Project nwam.4-Design) - XWiki</title>
                <meta http-equiv="Content-Script-Type" content="text/javascript" />
                        <meta http-equiv="imagetoolbar" content="no"/>
                      <link rel="alternate" type="application/x-wiki" title="Edit" href="/bin/edit/Project+nwam/4%2DDesign" />
                    <link rel="canonical" href="/bin/view/Project+nwam/4%2DDesign" />
                            <meta name="document" content="Project nwam.4-Design"/>
    <meta name="wiki" content="xwiki"/>
    <meta name="space" content="Project nwam"/>
    <meta name="page" content="4-Design"/>
    <meta name="version" content="5.2"/>
    <meta name="restURL" content="/rest/wikis/xwiki/spaces/Project+nwam/pages/4-Design"/>
                <meta name="gwt:property" content="locale=en" />
                <meta name="revisit-after" content="7 days" />
<meta name="description" content="Design" />
<meta name="keywords" content="wiki " />
<meta name="distribution" content="GLOBAL" />
<meta name="rating" content="General" />
<meta name="author" content="Renee Sommerfeld" />
<meta http-equiv="reply-to" content="" />
<meta name="language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="alternate" type="application/rss+xml" title="Wiki Feed RSS" href="/bin/view/Main/WebRss?xpage=rdf" />
<link rel="alternate" type="application/rss+xml" title="Blog RSS Feed" href="/bin/view/Blog/GlobalBlogRss?xpage=plain" />
<link rel="shortcut icon" href="/resources/icons/oso/icon.png">
                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
<link href="https://markebrooks.github.io/static/css/stylesheet.css" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/style.css?colorTheme=ColorThemes.Oso" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/print.css" rel="stylesheet" type="text/css" media="print" />
        <!--[if IE]>
  <link href="/bin/skin/skins/colibri/ie%2Dall.css" rel="stylesheet" type="text/css" />
<![endif]-->
<!--[if IE 6]>
  <link href="/bin/skin/skins/colibri/ie%2D6.css" rel="stylesheet" type="text/css" />
<![endif]-->
<link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Settings?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Style?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/XWiki/SharePage?language=en'/>
<link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/modalPopup.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/jumpToPage.css?language=en'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/confirmationBox.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/notification.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/skins/colibri/resources/uicomponents/viewers/tags.css'/>

    
    <link href="/bin/skin/resources/js/xwiki/suggest/ajaxSuggest.css" rel="stylesheet" type="text/css" />
<link href="/bin/skin/resources/js/xwiki/lightbox/lightbox.css" rel="stylesheet" type="text/css" />
<!--[if IE]>
  <link href="/bin/skin/resources/js/xwiki/lightbox/lightboxIE.css" rel="stylesheet" type="text/css" />
<![endif]-->












<script type="text/javascript" src="/resources/js/prototype/prototype.js"></script>
<script type="text/javascript" src="/bin/skin/resources/js/xwiki/xwiki.js"></script>
<script type="text/javascript">
// <![CDATA[
XWiki.webapppath = "";
XWiki.servletpath = "bin/";
XWiki.contextPath = "";
XWiki.mainWiki = "xwiki";
XWiki.currentWiki = "xwiki";
XWiki.currentSpace = "Project nwam";
XWiki.currentPage = "4-Design";
XWiki.editor = "";
XWiki.viewer = "";
XWiki.contextaction = "view";
XWiki.docisnew = false;
XWiki.docsyntax = "xwiki/2.0";
XWiki.blacklistedSpaces = [ "Import","Panels","Scheduler","Stats","XAppClasses","XAppSheets","XAppTemplates","XWiki","WatchCode","WatchSheets","XApp","WatchAdmin","Watch","ColorThemes","AnnotationCode" ];
XWiki.hasEdit = false;
XWiki.hasProgramming = false;
XWiki.hasBackupPackImportRights = false;
window.docviewurl = "/bin/view/Project+nwam/4%2DDesign";
window.docediturl = "/bin/edit/Project+nwam/4%2DDesign";
window.docsaveurl = "/bin/save/Project+nwam/4%2DDesign";
window.docgeturl = "/bin/get/Project+nwam/4%2DDesign";
// ]]>
</script>
<script type='text/javascript' src='/bin/skin/resources/js/scriptaculous/effects.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/modalPopup.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/jumpToPage.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmationBox.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmedAjaxRequest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/notification.js' defer='defer'></script>
<script type='text/javascript' src='/resources/uicomponents/widgets/list/xlist.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/suggest/ajaxSuggest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/skins/colibri/resources/uicomponents/viewers/tags.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/scriptaculous/scriptaculous.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/accordion/accordion.js' defer='defer'></script>

<script type='text/javascript' src='/bin/jsx/XWiki/WebDAV?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Settings?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Script?language=en' defer='defer'></script>

<script type="text/javascript" src="/resources/js/xwiki/compatibility.js" defer="defer"></script>

  </head>
  <body id="body" class="wiki-xwiki space-Project_nwam viewbody hideright">
<div id="xwikimaincontainer">
<div id="xwikimaincontainerinner">

  <div id="menuview">
    <div id="mainmenu" class="layoutsubsection actionmenu">
<strong id="xwikimenutitle" class="hidden">General Actions:</strong>
<div class="rightmenu">
      <div id="tmLogin" class="tmLogin topmenuentry ">
   <a class="tme" href="https://auth.opensolaris.org/login.action?targetUrl=http%3A%2F%2Fmarkebrooks.github.io%2Fbin%2Fview%2FProject%2Bnwam%2F4%252DDesign"><strong>Log-in</strong></a>
  </div>
  </div>
<div class="leftmenu">
  <div id="tmWiki" class="tmWiki topmenuentry hasIcon">
   <a class="tme" href="/bin/view/Main/"><strong>Wiki</strong></a>
  </div>
  <div id="tmSpace" class="tmSpace topmenuentry dropdownmenuentry  hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Project+nwam/"><strong>Project nwam</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
                <span class="submenuitem "><a href="/bin/view/Main/SpaceIndex?space=Project+nwam" id="tmSpaceDocumentIndex" class="tmSpaceDocumentIndex">Document Index</a></span>
    </span></div>

<div id="tmSubSites" class="tmSubSites topmenuentry dropdownmenuentry dropdownnolink hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Subsites</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem hasIcon"><a href="https://cr.opensolaris.org/" id="tmCR" class="tmCR">Code Reviews</a></span>
<span class="submenuitem hasIcon"><a href="http://repo.opensolaris.org/" id="tmRepo" class="tmRepo">SCM Management</a></span>
<span class="submenuitem hasIcon"><a href="http://pkg.opensolaris.org/" id="tmPkg" class="tmPkg">Package Search</a></span>
<span class="submenuitem hasIcon"><a href="http://bugs.opensolaris.org/" id="tmBugs" class="tmBugs">Bugster</a></span>
<span class="submenuitem hasIcon"><a href="http://defect.opensolaris.org/" id="tmDefect" class="tmDefect">Bugzilla</a></span>
<span class="submenuitem hasIcon"><a href="http://test.opensolaris.org/" id="tmTest" class="tmTest">Test Machines</a></span>
<span class="submenuitem hasIcon"><a href="http://planet.opensolaris.org/" id="tmPlanet" class="tmPlanet">Planet</a></span>
<span class="submenuitem hasIcon"><a href="http://mail.opensolaris.org/" id="tmMail" class="tmMail">Mailing Lists</a></span>
<span class="submenuitem hasIcon"><a href="http://poll.opensolaris.org/" id="tmPoll" class="tmPoll">Elections &amp; Polls</a></span>
<span class="submenuitem hasIcon"><a href="http://arc.opensolaris.org/" id="tmArc" class="tmArc">ARC Case Logs</a></span>
<span class="submenuitem hasIcon"><a href="http://jucr.opensolaris.org/" id="tmJucr" class="tmJucr">Source Juicer</a></span>
<span class="submenuitem hasIcon"><a href="http://pkgfactory.opensolaris.org/" id="tmPkgfactory" class="tmPkgfactory">Package Factory</a></span>
<span class="submenuitem hasIcon"><a href="http://auth.opensolaris.org/" id="tmAuth" class="tmAuth">Auth</a></span>
</span></div>

</div>
</div>

  </div>
 <div id="header" class="layoutsection">
<div class="minwidthb"></div>

  <div id="header">
    <div id="header_banner">
	<table style="width: 100%;">
	    <tr>
		<td style="width: 1%;">
		    <a href="https://markebrooks.github.io/bin/view/Main/"><div id="logo"></div></a>  
		</td>
		<td id="logo-text" style="width: 1%;">
		    Solaris
		</td>         
		<td style="width: 98%;">
		    <table id="loading-indicator">
			<tr>
			    <td><img src="https://markebrooks.github.io:443/static/images/busy.gif"
				    alt="Loading" title="Loading"/></td>
			    <td>Loading...</td>
			</tr>
		    </table>
		</td>
		<td style="width: 1%;">
		    <table id="iconbar">
			<tr>
			<td><a id="collectives-icon" href="https://markebrooks.github.io/bin/view/Main/collectives">
			    Collectives</a></td>
			<td><a id="discussions-icon" href="https://markebrooks.github.io/bin/view/Main/discussions">
				Discussions</a></td>
			<td><a id="documentation-icon" href="https://markebrooks.github.io/bin/view/Main/documentation">
				Documentation</a></td>
			<td><a id="download-icon" href="https://markebrooks.github.io/bin/view/Main/downloads">
				Download</a></td>
			<td><a id="source-browser-icon" href="http://src.opensolaris.org/source">
				Source Browser</a></td>
			</tr>
		    </table>
		</td>
	    </tr>
	</table>
    </div>
    <div id="site-notice">
	<span>
	    <a href="https://markebrooks.github.io/bin/view/Main/">ATTENTION: This website and all services within the opensolaris.org domain will be unavailable after March 24, 2013.</a>	   
	</span>
    </div>
</div>
 </div> 
  <div id="globallinks">
    <form action="/bin/view/Main/Search">
      <div class="globalsearch">
        <label class="hidden" for="headerglobalsearchinput">Search</label><input class="globalsearchinput withTip" id="headerglobalsearchinput" type="text" name="text" value="search..." size="15"/><input class="button" type="image" value="Go" alt="Go" src="/resources/icons/xwiki/search.png"/>
      </div>
    </form>
  </div> <div style="float:left;">

                

   <div id="hierarchy">
                              <a href='/bin/view/Project+nwam/Foundation'>Foundation</a> <span class='separator'>&#187;</span> <span class='current'>Design</span>
                </div>

</div>
  <span class="glink" id="headerlanguages" style="float:right">
        <a href="/bin/view/Project+nwam/4%2DDesign?language=en" class="language-default language-current">en</a>
    </span>


<div class="contenthideright" id="contentcontainer">
<div id="contentcontainerinner">
<div class="leftsidecolumns">
  <div id="contentcolumn"> 
          <div class="main layoutsubsection">
      <div id="contentmenu" class="actionmenu">
    <strong id="xwikicontentmenutitle" class="hidden">Page Actions:</strong>
<div class="rightmenu">
</div>
<div class="leftmenu">
  <div id="tmExport" class="tmExport topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Export</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/export/Project+nwam/4%2DDesign?format=pdf&amp;language=en" id="tmExportPdf" class="tmExportPdf">Export as PDF</a></span>
  <span class="submenuitem "><a href="/bin/export/Project+nwam/4%2DDesign?format=rtf&amp;language=en" id="tmExportRtf" class="tmExportRtf">Export as RTF</a></span>
  <span class="submenuitem "><a href="/bin/export/Project+nwam/4%2DDesign?format=html&amp;language=en" id="tmExportHtml" class="tmExportHtml">Export as HTML</a></span>
    </span></div>

<div id="tmShow" class="tmShow topmenuentry dropdownmenuentry  " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Project+nwam/4%2DDesign?viewer=code&amp;language=en"><strong>View</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem "><a href="/bin/view/Project+nwam/4%2DDesign?viewer=comments&amp;language=en" id="tmViewComments" class="tmViewComments">Comments</a></span>
<span class="submenuitem "><a href="/bin/view/Project+nwam/4%2DDesign?viewer=attachments&amp;language=en" id="tmViewAttachments" class="tmViewAttachments">Attachments</a></span>
<span class="submenuitem "><a href="/bin/view/Project+nwam/4%2DDesign?viewer=history&amp;language=en" id="tmViewHistory" class="tmViewHistory">History</a></span>
<span class="submenuitem "><a href="/bin/view/Project+nwam/4%2DDesign?viewer=information&amp;language=en" id="tmViewInformation" class="tmViewInformation">Information</a></span>
<span class="submenuitem "><a href="/bin/view/Project+nwam/4%2DDesign?viewer=code&amp;language=en" id="tmViewSource" class="tmViewSource">View Source</a></span>
</span></div>

  <div id="tmMoreActions" class="tmMoreActions topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>More actions</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/view/Project+nwam/4%2DDesign?xpage=print&amp;language=en" id="tmPrintPreview" class="tmPrintPreview">Print preview</a></span>
          </span></div>
</div>

    </div>
    <div id="mainContentArea">
      








    
<div id="document-title"><h1>Design</h1></div>





              <div id="document-info">
    <div>
          </div>
    <div class="clearfloats"></div>
  </div>

<div id="xwikicontent">
<h1 id="HNetworkAuto-MagicDesign"><span>Network Auto-Magic Design</span></h1><p>&nbsp;Version 1.0.6, 2007-Jun-07</p><table><tr><td><span class="wikiexternallink"><a href="http://blogs.sun.com/jbeck">John Beck</a></span></td><td><span class="wikiexternallink"><a href="http://blogs.sun.com/carlson">Jim Carlson</a></span></td><td><span class="wikiexternallink"><a href="http://blogs.sun.com/okie">Renee Danson</a></span></td><td><span class="wikiexternallink"><a href="http://blogs.sun.com/mph">Michael Hunter</a></span></td></tr><tr><td><span class="wikiexternallink"><a href="http://blogs.sun.com/anay">Anay Panvalkar</a></span></td><td><span class="wikiexternallink"><a href="http://blogs.sun.com/kcpoon">Kacheong Poon</a></span></td><td>Garima Tripathi</td><td>Jan Xie</td></tr></table><p>&nbsp;There are eight focus areas described below:</p><h2 id="H1.Overview26ComponentInteraction"><span>1. <span class="wikilink"><a href="#overview">Overview &amp; Component Interaction</a></span></span></h2><h2 id="H2.InformationGathering"><span>2. <span class="wikilink"><a href="#info_gather">Information Gathering</a></span></span></h2><h2 id="H3.EventHandler"><span>3. <span class="wikilink"><a href="#event_handler">Event Handler</a></span></span></h2><h2 id="H4.Profiles"><span>4. <span class="wikilink"><a href="#profiles">Profiles</a></span></span></h2><h2 id="H5.NetworkServiceModel"><span>5. <span class="wikilink"><a href="#network_service">Network Service Model</a></span></span></h2><h2 id="H6.Processes26Threads"><span>6. <span class="wikilink"><a href="#processes">Processes &amp; Threads</a></span></span></h2><h2 id="H7.UserInterface"><span>7. <span class="wikilink"><a href="#ui">User Interface</a></span></span></h2><h2 id="H8.DependencieswiththerestoftheSystem"><span>8. <span class="wikilink"><a href="#dependencies">Dependencies with the rest of the System</a></span></span></h2><p>&nbsp;There are also two appendices:</p><h2 id="HAppendixA:Glossary"><span>Appendix A: <span class="wikilink"><a href="#glossary">Glossary</a></span></span></h2><h2 id="HAppendixB:RevisionHistory"><span>Appendix B: <span class="wikilink"><a href="#revision">Revision History</a></span></span></h2><hr/><h2 id="H1.Overview26ComponentInteraction-1"><span>1. Overview &amp; Component Interaction</span></h2><h3 id="H1.1Introduction"><span>1.1 Introduction</span></h3><p>&nbsp;Network Profiles, the primary component of the Network Auto-Magic project, are a way to simplify network configuration management. They work by allowing users to specify profiles (i.e. collections of various properties) which determine how things work in different circumstances. The profiles and their respective properties include:</p><ul><li>Network Configuration Profile (NCP)<ul><li>which network interface(s) to use</li><li>how to obtain IP address(es) for the interface(s) in use</li><li>whether or not a given link should be configured automatically</li><li>parallel interfaces to the same subnet (i.e., link aggregation and IP Multipathing)</li></ul></li><li>Environment<ul><li>conditions under which a profile should be activated</li><li>which name service(s) to use</li><li>a host name (and any required variations thereof)</li><li>routing information</li><li>a set of IP filter rules</li><li><span class="box code">smf(5)</span> services</li><li>user-specified post-activation "hook"</li></ul></li></ul><p>&nbsp;This is discussed in much more detail in <span class="wikilink"><a href="#profiles">section 4</a></span> below.</p><h3 id="H1.2Overview"><span>1.2 Overview</span></h3><p>&nbsp;Let us begin with an <span class="wikilink"><a href="/bin/view/Project+nwam/3%2DArchitecture">architectural</a></span> overview. The primary components are:</p><ul><li>The profile repository. This is where the configuration program stores its data, which will also be read by the profile daemon.</li><li>The profile configuration program (a.k.a. the UI).<ul><li>Note that there will be both CLI and GUI versions of this program which will perform similar if not identical tasks.</li><li>In addition to using the repository, it also interacts with the profile daemon.</li><li>Tasks which users will use this program to perform include:<ul><li>creating, modifying and deleting profiles</li><li>activating one or more profiles</li><li>querying information about profiles</li></ul></li></ul></li><li>The profile daemon.<ul><li>This reads data from the repository.</li><li>It reacts to events as notified by the event handler.</li><li>It reacts to changes which users make via the configuration program.</li><li>The <span class="wikilink"><a href="#event_handler">event handler "state machine"</a></span> is implemented in this daemon.</li><li>The daemon also interacts with the SMF network services.</li></ul></li><li>The event handler, which will gather information about events from the kernel.</li><li>The SMF network services. These are already part of Solaris, but will be modified to some extent. The daemon will restart / refresh some of these services as needed.</li></ul><h3 id="H1.3Interactions"><span>1.3 Interactions</span></h3><p>&nbsp;How they interact is as follows:</p><ul><li>At any given time, one NCP and one Environment are "active".</li><li>At boot, the profile daemon consults the repository for the current active NCP, proceeds until one or more IP addresses have been configured, checks the conditions of the Environments, activates the one specified by the policy engine, and configures the network(s) accordingly.</li><li>As events occur which may trigger a change in the network configuration, the event handler detects these and the daemon consults the active profiles and may reconfigure the network(s) accordingly. Note that some of these events may indicate that the conditions have changed.</li><li>A change in conditions may trigger a change in the Environment, which may in turn affect the network configuration.</li><li>If a user modifies a profile, the configuration program updates the repository and notifies the daemon. If the current active profile is modified, then the daemon will reconfigure the network(s) accordingly.</li><li>Likewise, if a user activates a new profile (NCP or Environment), then the configuration program updates the repository and notifies the daemon, which will then reconfigure the network(s) accordingly. Note that a user can always manually activate a profile (NCP or Environment), regardless of conditions. Also note that users who desire total control will be able to specify conditions such that a different profile is never activated automatically.</li></ul><p>&nbsp;See <span class="wikilink"><a href="#event_handler">Section 3</a></span> and <span class="wikilink"><a href="#profiles">Section 4</a></span> for detailed discussion of how these will all work.</p><h3 id="H1.4Examples"><span>1.4 Examples</span></h3><ul><li>There will be an out-of-the box Environment for "no network" which specifies <span class="box code">files</span> for everything in <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>nsswitch.conf</span>, disables services which make no sense in a stand-alone environment, etc. Then at boot, the profile daemon would consult the conditions, note that there was no networking, then automatically select that Environment.</li><li>A user at Sun might specify a "SWAN" Environment:<ul><li>conditions of the form "apply when a network with IP addresses in the range <span class="box code">129.144.0.0<span style="color: #666666; ">/</span>12</span> is detected"</li><li>a property to use name server X</li><li>a property to use <span class="box code">files<span style="color: #666666; ">/</span>dns<span style="color: #666666; ">/</span>nis</span> or <span class="box code">files<span style="color: #666666; ">/</span>nis</span> in <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>nsswitch.conf</span></li><li>a property to use NIS server Y</li><li>enable the SMF service <span class="box code">nis<span style="color: #666666; ">/</span>client</span></li><li>etc.</li></ul></li><li>A user might specify an NCP of the form "connect link <span class="box code">ath0</span> to whatever WLAN, then use DHCP to get an IP address", then a related Environment whose conditions activate it contingent on <span class="box code">ath0</span> being connected to ESSID <em>X</em> and BSSID <em>Y</em>, then have a user "hook" to punchin, which creates an IPsec tunnel, thus triggering a condition check, which ultimately leads to the "SWAN" Environment being activated.</li></ul><h2 id="H2.InformationGathering-1"><span>2. Information Gathering</span></h2><p>&nbsp;Before NWAM can select a profile to activate, it needs to learn about the available network links and the connected networks. This information gathering is done at different levels of the network stack.</p><p>&nbsp;For example, at the data link level, NWAM might detect that 802.1X is being used to do authentication and need to consult a link layer profile for authentication information.</p><p>&nbsp;Suppose there are two Ethernet interface cards available on a Solaris box and both of them are connected to a network. NWAM might use the Link Aggregation Control Protocol (LACP) to find out if the two NICs can be grouped together to form an aggregation. If it is possible, NWAM will remember this information when selecting a profile.</p><p>&nbsp;Another example is when a machine has a WiFi network interface card, NWAM will need to find out all the available WiFi access points before it can decide which one is preferred.</p><p>&nbsp;At the IP level, NWAM will also need to find out several pieces of information. Again suppose there are two NICs available on a given box. NWAM will need to find out if the two NICs are connected to the same IP network. If they are, there is a possibility to set up an IPMP group on them to increase network availability. NWAM will also need to find out if IPv6 can be used with the attached IP network. It will use this information later to decide if an IPv6 interface needs to be plumbed over a network link. Another example is that NWAM will need to find out if DHCP service is available on the attached IP network. If it is, NWAM will need to find out what the available DHCP server(s) is/are providing. NWAM can use this information to select which server to talk to or if it should use DHCP to configure an interface at all.</p><h3 id="H2.1DHCP"><span>2.1 DHCP</span></h3><h4 id="H2.1.1Background"><span>2.1.1 Background</span></h4><p>&nbsp;When NWAM detects that an IP interface is available (the IFF_RUNNING flag is set), it needs to decide how to configure the interface by consulting an NCP. An NCP may specify that this interface is to have a static IP address. Or it may specify that this interface is to be configured using DHCP. Or it may specify that depending on different "conditions," this interface is to be configured using different methods. Or it may not specify any method to configure the new interface, and NWAM needs to decide what to do with it.</p><p>&nbsp;In the last two cases above, NWAM needs to discover what is available using the new interface. For example, it needs to find out if a DHCP server is available through the new interface. Currently, Solaris' dhcpagent(1M) does not provide a detection method which a caller can request the dhcpagent to find out the DHCP information on a given interface. When DHCP is enabled on an interface, the dhcpagent will try to complete the full DHCP lease processing and bind the interface. This document is to introduce a discover method to the dhcpagent without doing the actual lease processing.</p><h4 id="H2.1.2Proposal"><span>2.1.2 Proposal</span></h4><ol><li>dhcpagent changes<br/>&nbsp;In order to satisfy the above need to NWAM, we propose to add a new discover mechanism to dhcpagent. A new DHCP_DISCOVER request is added. When the dhcpagent receives such a discover request, it will send out the DHCPDISCOVER message through the requested interface as if it is trying to obtain a lease of an IP address from a server. After it receives the DHCPOFFER message from a server, it will reply the discover request with an OK. The agent will remember this DHCPOFFER message for a specific period of time. If dhcpagent receives multiple offers, it will remember all of them. And each offer is assigned a non-zero index. During this period, the internal state of the interface is DISCOVERED. After this period, the state will be changed back to INIT and all the cached DHCPOFFER messages will be freed.<br/>&nbsp;If the dhcpagent receives the discover request on an interface which is already in BOUND state, it will reply the request with an error DHCP_IPC_E_OUTSTATE. As the discover request is asynchronous, the agent may reply with error DHCP_IPC_E_PEND. It is up to the caller to retry.<br/>&nbsp;After the discover request is finished, the requester can then retrieve information from the DHCPOFFER message(s) using the DHCP_GET_ALL_TAG request. This new request can return data either from DHCPOFFER or DHCPACK. The caller can specify which one it wants in the request. If a caller requests data from DHCPOFFER, dhcpagent will return all the received DHCPOFFER messages along with their assigned index to the caller. If a caller requests data from DHCPACK, dhcpagent will return the received DHCPACK message to the caller.<br/>&nbsp;The DHCP_START request is also modified. The caller can specify an index in the request to tell the dhcpagent which DHCPOFFER message to use in generating the DHCPREQUEST message to the DHCP server. If the index is 0, it means that the dhcpagent can use the current rules to pick the appropriate DHCPOFFER message.<br/>&nbsp;If a DHCP_START request comes in for an interface in DISCOVERED state, the dhcpagent will generate a DHCPREQUEST message based on the saved DHCPOFFER message(s). Which message to use is determined by the aforementioned index in the request. If the index is non-zero and the interface is not in DISCOVERED state, the error DHCP_IPC_E_OUTSTATE will be sent back to the caller. After the DHCP lease is acquired, dhcpagent will still cache all the received DHCPOFFER messages for diagnostic purpose. Their information can be retrieved using the DHCP_GET_ALL_TAG request.</li><li>dhcpinfo(1) changes<br/>&nbsp;Two new options, -o and -a , will be added to dhcpinfo. If the -o option is set, dhcpinfo will request information from the DHCPOFFER message and print out the result. If not set, it will request information from the DHCPACK message as is done currently. The -o option takes a parameter which is used to specify which DHCPOFFER message to retrieve the result from. If there is no option, it will return results from all the DHCPOFFER messages stored in dhcpagent.<br/>&nbsp;If the -a option is set, dhcpinfo will print out all fields from either DHCPOFFER or DHCPACK message, depending on whether the -o option is set.</li><li>ifconfig(1M) changes<br/>&nbsp;Two new dhcp sub-commands `discover' and `select &lt;x&gt;' are added to ifconfig. The `discover' sub-command asks ifconfig to send the DHCP_DISCOVER request to the dhcpagent. The `select &lt;x&gt;' sub- command asks ifconfig to send the DHCP_START request with an index &lt;x&gt; to the dhcpagent. The current `start' sub-command will send a DHCP_START request with 0 as the index.</li></ol><h3 id="H2.2IPMPGroups"><span>2.2 IPMP Groups</span></h3><p>&nbsp;Interfaces which are connected to the same Ethernet broadcast domain should be IPMP'd together. Interfaces that are on the same IP subnet will be in the same broadcast domain; thus interfaces that are known to have an IP subnet in common should be placed in an IPMP group together.</p><p>&nbsp;The simple subnet test will not catch all interfaces that are connected to the same Ethernet broadcast domain, however. Jim suggests an additional test to discover interfaces that should be in the same IPMP group:</p><blockquote><p>&nbsp;&nbsp;Instead of pinging (and all the IP and ARP headaches that involves), I'd suggest using a multicast or broadcast message sent to ethertype 9000 (loopback). If the other interfaces can hear your message, then they're in the same Ethernet broadcast domain, and can (and probably should) be IPMP'd together.</p></blockquote><h3 id="H2.3Howtoconfiguredata-linkandIPinterfaces"><span>2.3 How to configure data-link and IP interfaces</span></h3><p>This section discusses the mechanisms NWAM uses to create and configure data-links and IP interfaces.</p><h4 id="H2.3.1Overview"><span>2.3.1 Overview</span></h4><p>In order for a communication pipe to be useful to the user a data-link portion has to be created and configured and an IP interface needs to be created and configured on top of that. It should be noted that a richer structure can be built using tunnels over IP to create another data-link over which IP can be configured and so on.</p><p>This section is closely related to Section 3 (Event Handler). That section covers how the mechanisms described in this section are used to manage the lifetime of the data-link and IP interfaces.</p><p>Until <span class="wikiexternallink"><a href="https://markebrooks.github.io/bin/view/Project+clearview/">Clearview</a></span> has been completely integrated, aggregations, VLANs, and tunnels will not be data-links. This document will discuss the issues surrounding these objects as if they were data-links.</p><p>It is expected that the necessary Clearview components will integrate before NWAM is completed. If that does not turn out to be true then an alternate design will be fleshed out and implemented. It is not expected to be difficult.</p><h4 id="H2.3.2Creationofdata-links"><span>2.3.2 Creation of data-links</span></h4><p>Many data-links are created when the associated driver is attached. We will not discuss those further in this document. For aggregations, VLANs, and tunnels data-links are created using dladm(1M).</p><p>The dladm functionality is built upon the consolidation private libraries libdladm (management of link properties), libaadm (configuration of link aggregations), and libiptun (management of tunnels). Configuration of link layer attributes will be done via these libraries.</p><h4 id="H2.3.2.1Aggregation"><span>2.3.2.1 Aggregation</span></h4><p>If the link we are bringing up is actually an aggregation of data-links then we need to use the laadm_create() entry point in the laadm library.</p><h4 id="H2.3.2.2VLAN"><span>2.3.2.2 VLAN</span></h4><p>In order to create a VLAN data-link the libdladm function dladm_datalink_create() will be used. Related functions will be used to manipulate the VLAN. See the Clearview "UV Design Specification" and "Link management API design" documents for further information.</p><h4 id="H2.3.2.3Tunnel"><span>2.3.2.3 Tunnel</span></h4><p>Tunnel creation will be done with the libiptun function iptun_create(). Related functions will be used to manipulate the tunnel. See the Clearview "IP Tunneling Device Driver Design Specification" for more information. In addition the documents from §2.3.2.2 are relevant.</p><h4 id="H2.3.3ConfiguringIPv4"><span>2.3.3 Configuring IPv4</span></h4><p>The following sections will discuss various mechanisms used to apply IPv4 configuration.</p><p>When creating and configuring an IP interface at the command level ifconfig(1M) is used.</p><p>libinetcfg (PSARC 2001/677, 202/247, 2003/427) was built to provide a rich set of consolidation private routines for configuring interfaces. It is currently not being used by anything within ON. NWAM's needs for configuring IP will be built upon libinetcfg. Due to libinetcfg's lack of use this may cause the need to extend libinetcfg.</p><h4 id="H2.3.3.1DHCP"><span>2.3.3.1 DHCP</span></h4><p>The first mechanism is for the dynamic configuration of IP using DHCP. In order to communicate with dhcpagent the project private library libdhcpagent (PSARC 1999/040) is used. Per §2.1 of this document an additional state is exported from dhcpagent allowing the user to inspect potential leases before accepting one. Minor changes will need to be made to libdhcpagent to generate the new requests.</p><p>Depending on the information needs of the NWAM profile being executed the appropriate DHCP command will be sent via the communication channel. If only information is being requested then that will be placed in the appropriate state structures for other components to consume. At a later point the user will either choose to accept one of the leases offered or not continue using DHCP to configure the interface.</p><h4 id="H2.3.3.2StaticConfiguration"><span>2.3.3.2 Static Configuration</span></h4><p>If interface configuration parameters are supplied by the user then libinetcfg will be use to configure the interface. Currently libinetcfg does not support the creation of logical interfaces. That functionality will be added to libinetcfg.</p><p>Since the removal of logical interfaces might happen in the future, the abstraction used should be consistent with either the use of logical interfaces or the ability to apply multiple addresses to a single link.</p><p>Once a logical interfaces (or equivalent abstraction) is obtained then application of the static config is done via icfg_set_{flags, addr, ...}.</p><h4 id="H2.3.4ConfiguringIPv6"><span>2.3.4 Configuring IPv6</span></h4><p>The following sections will discuss the mechanisms used to apply IPv6 configuration. A fundamental difference between IPv4 and IPv6 is that the decision to use DHCP is not managed from the host but from the network. Additionally link-local addresses are always available on interfaces and are managed without NWAM's intervention.</p><h4 id="H2.3.4.1DHCP"><span>2.3.4.1 DHCP</span></h4><p>Since stateful address management is controlled from the network the choice to use DHCP is not in the local user's hands. We allow the user to reject DHCP configuration but he cannot request it if the network does not offer it. Unless the user wants to reject DHCP configuration we will allow the dhcpagent to control the interface without our intervention.</p><p>The file <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>default<span style="color: #666666; ">/</span>dhcpagent</span> is used to control the agent's actions on each interface.</p><h4 id="H2.3.4.2StaticConfiguration"><span>2.3.4.2 Static Configuration</span></h4><p>The library libinetcfg will be used to apply static IPv6 configuration to IP interfaces. Since the addresses are too long for most people to remember, users rarely do this.</p><h3 id="H2.4Suspend2FResume"><span>2.4 Suspend/Resume</span></h3><p>&nbsp;After a suspend/resume or other operation which causes a link flap, we need to re-evaluate our network environment to determine if our configuration is still valid or not. Fortunately, DHCP takes care of this for us, so there is little to do in the general case. There may be some corner cases in which the use of <span class="wikiexternallink"><a href="http://www.ietf.org/html.charters/dna-charter.html">DNA</a></span> (see <span class="wikiexternallink"><a href="http://www.ietf.org/rfc/rfc4436.txt">RFC 4436</a></span> and <span class="wikiexternallink"><a href="http://www.ietf.org/internet-drafts/draft-ietf-dna-protocol-03.txt">I-D dna-protocol-03</a></span> for details) might provide some degree of optimization, which we may look into in the future if the need arises, but that will be part of a later phase of this project.</p><h2 id="H3.EventHandler-1"><span>3. Event Handler</span></h2><p>&nbsp;The NWAM daemon needs to handle many different events triggered both externally by the system or user and internally by its different threads. For example, it needs to handle the event of an IP interface becomes unavailable because the underlying link is gone. It needs to handle internally generated events such as the thread responsible to gather interface information has completed. This section explains the different events related to data-links and how they are handled by the NWAM daemon.</p><h3 id="H3.1Events"><span>3.1 Events</span></h3><p>&nbsp;The following are the explanations of the events the daemon needs to handle with data-link and IP interface.</p><h4 id="H3.1.1LinkandInterfaceEvents"><span>3.1.1 Link and Interface Events</span></h4><h5 id="H3.1.1.1EV_LINK_CREATE2FEV_LINK_DESTROY"><span>3.1.1.1 EV_LINK_CREATE / EV_LINK_DESTROY</span></h5><p>These events are triggered externally when the daemon detects that a new data-link is created/destroyed. With the Clearview project, a new kind of sysevents will (need to be confirmed) be generated for data-link creation and removal. The daemon will listen to those sysevents and generate the appropriate internal event, EV_LINK_CREATE/EV_LINK_DESTROY. This new kind of sysevents correctly reflects all the link create/ destroy events the daemon is interested in.</p><p>The EV_LINK_CREATE event can also be triggered internally when NWAM starts up. At that time, the daemon detects all existing links and may generate this event depending on the start up method. This is explained in the event handling section later.</p><h5 id="H3.1.1.2EV_LINK_UP2FEV_LINK_DOWN"><span>3.1.1.2 EV_LINK_UP / EV_LINK_DOWN</span></h5><p>The EV_LINK_UP event is triggered externally when the daemon detects that a link is now available and the link flag can be marked NWAM_LINK_UP. Similarly, if the link is down, the EV_LINK_DOWN event is triggered and the link flag NWAM_LINK_UP is cleared. The daemon will use the DLPI interface to catch DL_NOTE_LINK_{UP,DOWN} notifications.</p><p>&nbsp;For those device drivers which do not send DL_NOTE_LINK_UP, the daemon can try periodically polling the kstat of the underlying device of a physically link to check if its link is up.</p><p>For wireless interfaces, this event is generated when the link is connected to a wireless network successfully. This depends on the device driver to correctly send the DL_NOTE_LINK_UP notification to IP.</p><h5 id="H3.1.1.3EV_IF_CREATE2FEV_IF_DESTROY"><span>3.1.1.3 EV_IF_CREATE / EV_IF_DESTROY</span></h5><p>These events should be triggered externally when IP interfaces are plumbed/unplumbed. But currently there is no standard way to catch such events. The NWAM daemon only knows about interface plumbing/ unplumbing done by itself. This mechanism needs to be added, possibly by using routing socket.</p><p>The EV_IF_CREATE event can also be triggered internally when NWAM starts up. At that time, NWAM detects all existing interfaces and may generate this event depending on the start up method. This is explained in the event handling section later.</p><h5 id="H3.1.1.4EV_IF_INFO_KNOWN"><span>3.1.1.4 EV_IF_INFO_KNOWN</span></h5><p>This event is generated internally when the daemon finishes gathering network information of an interface. The NWAM daemon may need to find out network information of an interface before it can make the decision on how to configure that interface. For example, it may want to know about the DHCP information before deciding if the interface should be configured using DHCP.</p><h5 id="H3.1.1.5EV_IF_UP"><span>3.1.1.5 EV_IF_UP</span></h5><p>This event is generated internally when an IP interface is configured and up. For example, suppose an interface is to be configured using DHCP. After the dhcpagent(1M) sets the interface address and marks the interface up, the daemon will get the appropriate routing socket messages (RTM_IFINFO and RTM_NEWADDR). Then it will generate the EV_IF_UP event to tell the other parts of the daemon that an interface is up and running.</p><p>As indicated above, this event depends on an IP interface to have an address (RTM_NEWADDR) and is marked up (RTM_IFINFO). Both of these conditions must be true for this event to be generated. The daemon will remember if an IP interface has an address set or not and if it is marked up or not.</p><h5 id="H3.1.1.6EV_IF_DOWN"><span>3.1.1.6 EV_IF_DOWN</span></h5><p>This event is generated internally when an interface is unconfigured and down. For example, suppose an interface is configured using DHCP. After the dhcpagent(1M) successfully releases the lease, the daemon will get the appropriate routing socket messages (RTM_IFINFO and RTM_DELADDR). Then it will generate the EV_IF_DOWN event to tell the other parts of the daemon that an interface is down.</p><p>&nbsp;This event will be generated when either an IP interface is marked down or the address is deleted.</p><h4 id="H3.1.2Eventhandling"><span>3.1.2 Event handling</span></h4><p>&nbsp;When starting up, the NWAM daemon reads in the Network Configuration Profile (NCP) as described in Section 4.1 "Network Configuration Profile Contents"). It then creates an internal representation of the NCP and all the Network Configuration Units (NCU). All the link structures are marked with the NWAM_LINK_NOT_PRESENT flag. After the event handler is up, the NWAM daemon will detect the existing network configuration of the system. Then it will perform either one of the following.</p><ol><li>If the start up method is to clean up everything, the daemon will unplumb all detected interfaces and remove all virtual links. Then for each detected physical link, the daemon will follow the contingency rules as specified in the NCP and NCU(s) to decide if it needs to generate the EV_LINK_CREATE event to trigger the creation of the associated links and interfaces as described in the NCP.</li></ol><p>2. If the start up method is not to change the existing set up, then for each detected links and interfaces, the daemon will compare it with the internal representation of NCP and note the difference. If a link and an interface does not exist in the NCP, the daemon will trigger a EV_LINK_CREATE or EV_IF_CREATE event.</p><h5 id="H3.1.2.1EV_LINK_CREATE"><span>3.1.2.1 EV_LINK_CREATE</span></h5><p>The daemon will create an internal structure for this link if it is not already created when the daemon starts up. The newly structure does not have the NWAM_LINK_NOT_PRESENT flag set. Based on the information it gets with this event, the daemon will try to find a correct position in the graph of links to place this new link. For example, if this link is a physical link, the daemon will place it as a root link. But if this link is a VLAN link, the daemon will place it as a child of the link it is based on. The link flag of the newly created representation is marked NWAM_LINK_EXTERNAL. The daemon will also check if the new link is up. If it is up, the daemon will trigger a EV_LINK_UP event.</p><p>If the structure of this link is already there, the daemon will clear the NWAM_LINK_NOT_PRESENT flag and check if the link flag NWAM_LINK_ENABLED is set. If yes, the daemon will check if the link is UP and if yes, it will trigger a EV_LINK_UP event. If the NWAM_LINK_ENABLED flag is not set and the daemon gets this event, it means that an external entity has created this link. The daemon will stop the event processing.</p><p>The daemon will also create a new SMF service instance of the link as explained in Section 4.1.3.</p><h5 id="H3.1.2.2EV_LINK_DESTROY"><span>3.1.2.2 EV_LINK_DESTROY</span></h5><p>The daemon will first start the interface NCU handling, as explained later, of this event for all the associated interface NCUs of the link. And then it will mark the link flag NWAM_LINK_NOT_PRESENT. It will walk through all its children link and mark their flag NWAM_LINK_NOT_PRESENT. The exception is for an aggregation link which still has at least one link belonging to that aggregation without being marked NWAM_LINK_NOT_PRESENT. The daemon will also destroy the corresponding SMF service instance of the link, as explained in §4.1.3.</p><h5 id="H3.1.2.3EV_LINK_UP"><span>3.1.2.3 EV_LINK_UP</span></h5><p>The daemon will check the link flag of the corresponding link structure. If it is already set, the daemon stops the event processing.</p><p>If the flag is not set, the daemon will set the flag. Then it will walk through all the children of the link and trigger a EV_LINK_UP event for each of them if it is marked NWAM_LINK_ENABLED. If there is no child link, then the daemon will start the interface NCU handling as described below for all the associated interface NCUs. The daemon will also create a new SMF service instance of all the associated interface NCUs as explained in Section 4.1.3.</p><h5 id="H3.1.2.4EV_LINK_DOWN"><span>3.1.2.4 EV_LINK_DOWN</span></h5><p>In getting the EV_LINK_DOWN event, the daemon will clear the NWAM_LINK_UP flag of the corresponding link. It will then walk through all the children of that link clearing the NWAM_LINK_UP flag. If a child link is an aggregation and there is another link belonging to that aggregation which still has the NWAM_LINK_UP flag set, the aggregation link flag is not touched and the traversal of link will be stopped for that particular branch. For all the children links which have the NWAM_LINK_UP flag cleared but have the NWAM_LINK_ENABLED flag set, the daemon will start the interface NCU handling of this event as described below in "IP interface NCU handling" for all the associated interface NCU(s).</p><h4 id="H3.1.3IPinterfaceNCUhandling"><span>3.1.3 IP interface NCU handling</span></h4><p>Each interface NCU is represented by a structure and the daemon runs a state machine for it. The following are the possible states.</p><ol><li>NWAN_IF_INIT</li></ol><p>2. NWAM_IF_QUERYING</p><p>3. NWAM_IF_READY</p><p>4. NWAM_IF_RUNNING</p><p>For every structure, the initial state is NWAM_IF_INIT. For each interface NCU, the daemon creates it when it reads in the NCP. For externally created interface, the daemon triggers the EV_IF_CREATE event and a structure will be created.</p><p>This is a brief state transition diagram of the interface NCU structure. Note that the EV_IF_DESTROY transition is not shown. The reason is that the EV_IF_DESTROY transition is also dependent on the EV_IF_EXTERNAL flag. This flag is set for externally created interfaces not in the NCP. Instead of adding a new set of states just for those interfaces, the flag is used to differentiate them. So the states are the same for both types of interface. An EV_IF_DESTROY event will remove the structure for externally created interface (meaning going to CLOSED state). But for an interface in a NCP, the structure stays and the state will transition to NWAM_IF_INIT.</p><p>&nbsp;The interface state transition diagram is as follows;<br/> <img src="https://markebrooks.github.io/bin/download/Project+nwam/4-Design/interface-states.new.gif" alt="interface-states.new.gif"/></p><h5 id="H3.1.3.1CLOSED"><span>3.1.3.1 CLOSED</span></h5><p>EV_IF_CREATE: the daemon will create the structure representing this interface. The flag of this newly created interface is set to NWAM_IF_EXTERNAL. The state of this interface structure is set to NWAM_IF_RUNNING. And the daemon will find out information about this interface and use the gathered information to fill in the structure.</p><h5 id="H3.1.3.2NWAM_IF_INIT"><span>3.1.3.2 NWAM_IF_INIT</span></h5><p>EV_LINK_DESTROY: the daemon will unplumb the IP interface.</p><p>EV_LINK_UP: if the flag does not have NWAM_IF_EXTERNAL set, the IP interface is plumbed if it is not plumbed yet and the state will be changed to NWAM_IF_QUERYING. The state machine will start a thread to collect information on the network.</p><p>EV_IF_DESTROY: if the flag has NWAM_IF_EXTERNAL set, the daemon will free up the interface structure. The daemon will also destroy the corresponding SMF service instance of the interface, as explained in §4.1.3.</p><p>All other events: do nothing.</p><h5 id="H3.1.3.3NWAM_IF_QUERYING"><span>3.1.3.3 NWAM_IF_QUERYING</span></h5><p>EV_IF_INFO_KNOWN: the state will be changed to NWAM_IF_READY. The state machine will use the information stored in the interface NCU to determine how to configure the IP interface.</p><p>If only static IP addresses are needed to be set, the IP is configured and the state will be changed to NWAM_IF_RUNNING immediately.</p><p>If further processing are needed, such as finishing up the DHCP processing, the state machine will start a thread to do the job.</p><p>EV_LINK_DESTROY: the state machine will unplumb the IP interface and change the state to NWAM_IF_INIT.</p><p>EV_LINK_DOWN: the state will be changed to NWAM_IF_INIT. Note that the interface is not unplumbed.</p><p>EV_IF_DESTROY: the state will be changed to NWAM_IF_INIT.</p><p>All other events: do nothing</p><h5 id="H3.1.3.4NWAM_IF_READY"><span>3.1.3.4 NWAM_IF_READY</span></h5><p>EV_IF_UP: the state will be changed to NWAM_IF_RUNNING.</p><p>EV_LINK_DESTROY: if a thread has been spawned to configure the interface, the state machine will make a note and the thread will de-configure the interface. If there is no configuration in progress, the state machine will unplumb the IP interface. The state will be changed to NWAM_IF_INIT.</p><p>EV_LINK_DOWN: if configuration is in progress, the state machine will make a note and the thread will not configure the interface. The state of the link will be changed to NWAM_IF_INIT. Note that the interface is not unplumbed.</p><p>EV_IF_DESTROY: the state will be changed to NWAM_IF_INIT.</p><p>All other events: do nothing</p><h5 id="H3.1.3.5NWAM_IF_RUNNING"><span>3.1.3.5 NWAM_IF_RUNNING</span></h5><p>EV_IF_DOWN: if NWAM_IF_EXTERNAL flag is not set, the state will be changed to NWAM_IF_READY.</p><p>EV_LINK_DOWN: if NWAM_IF_EXTERNAL flag is not set, the daemon will de-configure the IP interface. The state will be changed to NWAM_IF_INIT.</p><p>EV_LINK_DESTROY: if the flag NWAM_IF_EXTERNAL is set, the daemon free up the structure. Otherwise, the daemon will unplumb the IP interface and the state is changed to NWAM_IF_INIT.</p><p>EV_IF_DESTROY: if the flag has NWAM_IF_EXTERNAL set, the daemon will free up the interface structure. The daemon will also destroy the corresponding SMF service instance of the interface, as explained in Section 4.1.3. If the flag is not set, the state will be changed to NWAM_IF_INIT.</p><p>All other events: do nothing</p><h2 id="H4.Profiles-1"><span>4. Profiles</span></h2><h3 id="H4.1NetworkConfigurationProfileContents"><span>4.1 Network Configuration Profile Contents</span></h3><p>&nbsp;See <span class="wikilink"><a href="/bin/view/Project+nwam/#llp">Architecture §4.1</a></span> for background and <span class="wikilink"><a href="#property_groups">§5.1.1, item 1</a></span> for a related discussion of how this will be stored.</p><h4 id="H4.1.1PreviouslyConsideredAlternatives"><span>4.1.1 Previously Considered Alternatives</span></h4><p>&nbsp;Originally we had N separate Link-Layer Profiles (LLPs), one per link, but these were perceived to be too complex to be workable when putting the whole system together. So we came up with the idea of a single Link &amp; Interface Specification (link-spec), but this seemed to be too inflexible, and people had a hard time understanding it.</p><h4 id="H4.1.2Proposal"><span>4.1.2 Proposal</span></h4><p>&nbsp;To solve these problems, we returned to the idea of LLPs, using them as a starting point. We then added some attributes to make it easier to build these units into a complete picture. The result is something akin to LLPs which we have dubbed NCUs (network configuration units), which when all put together comprise something akin to a link-spec: an NCP (network configuration profile).</p><p>&nbsp;An NCP may also contain information about external network applications that may be registered with NWAM, allowing them to be enabled/disabled by NWAM according to rules defined by the user. This registration interface is discussed in <span class="wikilink"><a href="#svc_reg_interface">§4.5.2</a></span>.</p><h4 id="H4.1.3Details"><span>4.1.3 Details</span></h4><p>&nbsp;There are several attributes which make up an NCU, each of which can take one of several values, some of which have sub-values. In the internal representation of the configuration, we will have a subset of this structure per address. Thus the attributes in this structure possible describe a set of NCUs:</p><ul><li>What is this NCU named? (Note that the name is derived by the system from the underlying link name.)</li><li>What kind of NCU is this?<ul><li>link<ul><li>must specify link class:<ul><li>phys</li><li>iptun</li><li>aggr</li><li>vlan</li></ul></li><li>acceptable address acquisition methods (for interfaces which may be above this)<ul><li>static IPv4</li><li>DHCPv4<ul><li>how long to wait for DHCP server?</li><li>(optional) static address to use as fallback</li></ul></li><li>stateless address auto-conf (i.e., router)</li><li>stateful address auto-conf (i.e., DHCPv6)</li><li>static IPv6</li></ul></li></ul></li><li>IP address<ul><li>must specify interface class:<ul><li>simple</li><li>ipmp</li><li>loopback</li><li>vni</li></ul></li><li>must also specify IP version:<ul><li>4, must also specify source of IP address:<ul><li>DHCP</li><li>static</li></ul></li><li>6, must also specify IP address source:<ul><li>accept stateless address auto-conf (i.e., router)? [Y]</li><li>accept stateful address auto-conf (i.e., DHCPv6)? [Y]</li><li>static address &amp; prefix? (may be multiple) [none]</li></ul></li></ul></li></ul></li></ul></li><li>When to activate?<ul><li>whenever possible [this is the default for all links]</li><li>contingent on another NCU; a typical example is ath0 being brought up contingent on bge0 not being up</li><li>don't touch this: NWAM will leave links and IP interfaces of this type (henceforth referred to as "manual NCUs") alone &nbsp;Note 1: changes in network configuration are expected to be made using the NWAM UI, to take effect on the next service or instance refresh or system reboot, which would be triggered as part of a "commit" or "apply" operation in the UI. Regarding changes made directly to data links or IP interfaces (other than manual NCUs) using some other UI:</li><li>Persistent changes (e.g., those made using <span class="box code">dladm(1m)</span>) will be applied to the current NCP and thus applied to the running system on the next service or instance refresh or system reboot.</li><li>Transient changes (e.g., those made using "dladm -t" or <span class="box code">ifconfig(1m)</span>) will not be undone proactively, but they will not persist beyond the next service or instance refresh or system reboot. &nbsp;Note 2: to facilitate the management of all this, NWAM will create service instances dynamically, one per NCU. This will allow finer granularity, as instances can be refreshed individually rather than having to refresh the entire service. Because of the dynamic nature of this instance creation, it is inappropriate for any higher level services (whether system provided or user added) to create dependencies on any of these instances.<br/>&nbsp;Note 3: other projects have proposed similar "instance per link" ideas in the past, largely for fault management purposes. In this case, the motivation is for configuration management, though the result may be serendipitously useful for fault management as well.<br/>&nbsp;Note 4: the proposed names for these dynamic instances are:</li><li>svc:/network/&lt;TBD NWAM service name&gt;:link-&lt;NCU name&gt;</li><li>svc:/network/&lt;TBD NWAM service name&gt;:ip-&lt;NCU name&gt; &nbsp;though we may end up adding more .X classifiers to the instance name to specify the link/interface class, IP version, etc.<br/>&nbsp;Note 5: during design, a request was made for the ability "to set a static IP for one environment and obtain a DHCP address in another, and have NWAM select appropriately." This use case was deemed sufficiently narrow (DHCP is available just about everywhere) that it would not justify the technical lengths required to support such a feature. The optional static address to use as a fallback in the DHCPv4 entry above was deemed an appropriate compromise.</li></ul></li><li>What kind of NCU(s) is/are below this? Depending on whether this NCU is a link or an IP interface, and which class thereof, only certain values will be allowed.<ul><li>nothing</li><li>some link(s)<ul><li>specify link class(es) (if multiple, must all be the same)</li></ul></li></ul></li><li>What kind of NCU(s) is/are above this? Depending on whether this NCU is a link or an IP interface, and which class thereof, only certain values will be allowed. Note that we have both 1:N and N:1 relationships between aggregations/IPMP and VLANs. With aggregations all the link types below have to be the same. With IPMP it is more complex: all links in an IPMP group have to be the same link type (e.g., all DL_ETHER). Further, a single IPMP group cannot exist across multiple VLANs (by definition, all IP interfaces in a group must be in the same link-layer broadcast domain). So, IPMP and VLANs only interact one way: IP interfaces on the same VLAN must be placed into the same IPMP group.<ul><li>nothing</li><li>simple interface</li><li>ipmp interface</li><li>aggr link</li><li>vlan link</li></ul></li></ul><p>&nbsp;Taken together, the entire set of NCUs will comprise the system NCP. Except in the stand-alone scenario, there will be multiple (at least three: loopback + 1 link + 1 IP interface) NCUs in an NCP. The system will only have a single NCP active at any time; although cloning and switching between NCPs will be supported, neither of these is expected to be necessary for "simple" configurations like laptops or desktops.</p><h3 id="H4.2MultipleActiveLinks"><span>4.2 Multiple Active Links</span></h3><p>&nbsp;The primary design goal here is that, whenever possible, things should Just Work™, with minimal manual intervention. Since we have the technology to plumb all interfaces at boot, and bring them all up (<span class="box code">`ifconfig <span style="color: #666666; ">//</span>IF<span style="color: #666666; ">//</span> dhcp`</span> as needed, possibly preceded by <span class="box code">`wificonfig <span style="color: #666666; ">-</span><span style="color: #008000; ">i</span> <span style="color: #666666; ">//</span>IF<span style="color: #666666; ">//</span> autoconf`</span> or equivalent), the key question is when we would want to do that, or more to the point, when we would <strong>not</strong> want to do that. In other words, we can already implement the mechanisms, but we need to be able to implement various policies.</p><p>&nbsp;So we will need the UI to allow users to specify policies, but we also need to have a default policy (i.e., for when the user has failed to express his/her preferences for a given scenario). The proposal is that by default all interfaces are plumbed and brought up, though wireless networks will only be connected to after explicit authorization from the user.</p><p>&nbsp;If multiple IP interfaces get brought up, then IPMP will be used as possible. IPMP does not work with DHCP, though this is being fixed by Clearview's IPMP Rearchitecture project. So until this is fixed, when multiple IP interfaces are detected to be in the same broadcast domain, only one will be brought up, and it will be brought up using DHCP but not IPMP. Once the IPMP Rearchitecture project is complete, all such interfaces will be brought up using DHCP and IPMP.</p><p>&nbsp;This should allow us to do the Right Thing™ in the horizontal scaling and large server scenarios, yet still be flexible for the laptop scenario. The rationale for this set of defaults is Requirement #17:</p><blockquote><p>&nbsp;&nbsp;For security reasons, bridging networks must be not permitted by default.</p></blockquote><p>&nbsp;(Note that we tend to think of this internally as "thou shalt not have a SWAN interface and a non-SWAN interface up at the same time".) It is fairly safe to assume that if a cable is plugged into an Ethernet port of a machine, then the user wants the machine to bring up <strong>the</strong> network to which the cable is attached, whereas a wireless interface could pick up an AP from just about anywhere, and choosing from among <strong>multiple</strong> networks (and even worse, multiple unknown networks) without data is a potential security hazard.</p><h3 id="H4.3EnvironmentContent"><span>4.3 Environment Content</span></h3><p>&nbsp;See <span class="wikilink"><a href="/bin/view/Project+nwam/3%2DArchitecture">Architecture</a></span> §4.2 for background and §5.1.1 for a related discussion of how this will be stored.</p><p>&nbsp;An Environment (previously called an Upper Layer Profile or ULP) contains information to configure the system after IP service is available. As opposed to NCP attributes which are per-link or per-interface, each of these Environment attributes affect the entire system.</p><ol><li>Name-services information: what name service to use. More details in §4.3.1</li><li>Identity:<br/>1* Node name<br/>1* NFSv4 domain</li><li>proxy servers</li><li>configuration files for various services, including, but not limited to:<br/>1* IP Filter<br/>1* IPsec</li><li>SMF services to enable or disable (see <span class="wikilink"><a href="#service_model">§5.4</a></span> for a complete list of services)</li></ol><h4 id="H4.3.1Duckwater"><span>4.3.1 Duckwater</span></h4><p>&nbsp;The <span class="wikilink"><a href="/bin/view/Project+duckwater/">Duckwater</a></span> (aka Simplified Name Service Management) project will introduce name service profiles, which are collections of name service configuration data. These collections will include both name service switch (which name service back-end to use for different types of lookups) information and configuration details for specific back-ends (e.g. DNS, NIS, LDAP).</p><p>&nbsp;The general rule we are following for NWAM is that the NWAM Environment specifies the enabled/disabled state of certain upper-layer network services, but the detailed configuration and policy rules for those services belong in the services themselves.</p><p>&nbsp;Thus for name service configuration, NWAM will allow the user to specify a name service profile as part of each Environment: when setting up an NWAM Environment, "Name Services" will be a tab, menu item, whatever (depending on GUI details). When you choose this item, you will be presented with a single list of options:</p><blockquote><p>&nbsp;&nbsp;Automatic</p></blockquote><p>&nbsp;list of existing name services profiles to choose from<br/>&nbsp;"specify name service configuration" which links to Duckwater config GUI</p><p>&nbsp;The Automatic option would be the default and would map to a Duckwater profile with all properties set to "automatic." These are described in the <span class="wikilink"><a href="/bin/view/Project+duckwater/profiles_new">Duckwater design draft</a></span></p><blockquote><p>&nbsp;&nbsp;auto value for nsswitch/* properties means that the name service switch (nscd(1M)) should decide which source types to use based on the back-end availability information provided to it by back- ends and delivered using nsutil(1M) [nsutil].</p></blockquote><p>&nbsp;auto value for nsbec/* property means that special NSBEC instance for particular source type is used which would have all appropriate property values set to auto meaning that the configuration for given type should be auto-configured (name service servers discovered using DNS or DHCP etc.).</p><p>&nbsp;[Note that NSBEC stands for Name Service Back End Configuration.]</p><p>&nbsp;The link to the Duckwater/name service configuration GUI could be a menu item, or it could be a button in the Name Services window.</p><h5 id="H4.3.1.1AlternativesConsidered"><span>4.3.1.1 Alternatives Considered</span></h5><ul><li>A somewhat-less-minimal way of doing this would be to allow the user to choose a particular name service, and then click into Duckwater to configure that particular back-end. There are a few problems with this option. First, it does not play well if the user wants to use multiple back-ends--SWAN's DNS/NIS blend, for example. So it may not be an either-or choice. Second, the Duckwater architecture is being designed to be extensible, to allow addition of new back-ends. Building back-end knowledge into NWAM would be an issue if a new back-end were added.</li><li>A simple DNS config could be specified in the NWAM GUI, while more complex configurations are punted to tools introduced by Duckwater. While this does seem convenient for the simple case, it muddles the distinction between the name service configuration subsystem and the NWAM subsystem. The ideal scenario is to keep the two architecturally separate but still have a cohesive user experience, and that should be doable.</li></ul><h5 id="H4.3.1.2Concerns"><span>4.3.1.2 Concerns</span></h5><ul><li>The Duckwater team is not including a GUI in their phase 1 plans. One plus here is that Duckwater profiles are an instance of <span class="wikiexternallink"><a href="https://markebrooks.github.io/bin/view/Project+smf-profiles">Enhanced SMF profiles</a></span>; so they will tie in to the <span class="wikiexternallink"><a href="https://markebrooks.github.io/bin/view/Project+vpanels">Visual Panels</a></span> work, which may help with the creation of a name service configuration GUI. However it happens, having a name service configuration GUI is a requirement for NWAM. If that GUI needs to be implemented as part of the NWAM project, the boundary between it and the NWAM GUI should be clear so that future Duckwater enhancements could be made cleanly without changes to the NWAM GUI. Creating a separate panel for name service profile configuration would likely be the best approach here.</li></ul><h4 id="H4.3.2EnhancedSMFProfileFramework"><span>4.3.2 Enhanced SMF Profile Framework</span></h4><p>&nbsp;NWAM profiles will be instances of <span class="wikiexternallink"><a href="https://markebrooks.github.io/bin/view/Project+smf-profiles">Enhanced SMF profiles</a></span>. The Enhanced SMF Profile model allows SMF service properties to be grouped into profiles, which may then be layered on the running system. In this model, NWAM profiles will be layered above the base and the system default (<span class="box code">generic_open</span>, for example) profiles. The <span class="box code">local</span> profile will include changes introduced by the user, and will overlay any NWAM profiles.</p><h5 id="H4.3.2.1SecureByDefaultandEnhancedSMFProfiles"><span>4.3.2.1 Secure By Default and Enhanced SMF Profiles</span></h5><p>&nbsp;The Enhanced SMF Profile team is planning to introduce new system profiles to reflect Secure By Default requirements. The current proposal is to break <span class="box code">generic_open</span> and <span class="box code">generic_limited_net</span> into four new profiles:</p><ul><li><span class="box code">system_services</span>: services for the system, no public interfaces</li><li><span class="box code">local_services</span>: services for local users, like dtlogin, rpcbind in local-only mode, sendmail in local-only mode</li><li><span class="box code">secure_net_services</span>: sshd</li><li><span class="box code">network_services</span>: services offered to the network, including rpcbind and sendmail in normal mode</li></ul><p>&nbsp;The <span class="box code">system_services</span> and <span class="box code">local_services</span> profiles will be applied by default, layered below any NWAM profiles. The <span class="box code">&nbsp;secure_net_services</span> and <span class="box code">network_services</span> profiles may be used as templates for the creation of new NWAM profiles.</p><h4 id="H4.3.3hostnames"><span>4.3.3 host names</span></h4><p>&nbsp;Currently if the user wants to change the hostname of the system, s/he has to either sys-unconfig then configure the system, or update a bunch of files then reboot the machine.</p><p>&nbsp;NWAM can introduce an interface for setting the hostname and subscribing to hostname changes. To achieve this, the following steps need to be taken:</p><ol><li>Use system/identity:node to keep track of system's hostname.</li><li>When the user changes the hostname through the NWAM UI, NWAM will need to update the node name in the kernel, then update /etc/nodename and /etc/inet/hosts.</li><li>Refresh system/identity:node</li><li>All services that use hostname as a rendezvous point, such as autofs and keyserv, they should either be reworked to use "localhost" rather than the current hostname. Or they should build a "restart_on=refresh" dependency with system/identity:node.</li></ol><h4 id="H4.3.4EnvironmentExtensibility"><span>4.3.4 Environment Extensibility</span></h4><p>&nbsp;We have defined a set of configuration details that make up an Environment, but we also need to make it easy to extend that list. What happens when new "network-related" services are added to the system? What happens if the configuration properties of an existing service change? Forcing the developer who introduces that new service to wire their config into the NWAM UI and environment handling is not a good approach, and will most likely result in a return to fragmentation of configuration data; as has been pointed out in earlier discussions:</p><blockquote><p>&nbsp;&nbsp;If it's "hard" for people working in other areas to add new things here, then I suspect that they won't do it at all. We'll end up with a mechanism that rots away, and an uneven feature landscape: some controlled by NWAM, others not.</p></blockquote><h5 id="H4.3.4.1Proposal"><span>4.3.4.1 Proposal</span></h5><p>&nbsp;The Environment is a collection of SMF services and properties which are applied to the running system when the Environment is activated. We could define properties that allowed a service developer to identify which of its service properties should be user-configurable; NWAM could then identify those properties, and make them available for configuration through its UI.</p><p>&nbsp;User-configurable properties will be identified as follows:</p><ul><li>A single nwam/config boolean property must be defined and set to true</li><li>A property group, along the lines of the existing dependency groups, must be defined for each configurable property. This property group should include a set of values that describe the property NWAM should make available, and how exactly to do so.</li></ul><p>&nbsp;When NWAM is asked for the list of attributes of an Environment, it will return both the hard-wired attributes it already knows about, and the set it discovers by walking the SMF repository and looking for the nwam/config property and associated property groups.</p><h5 id="H4.3.4.2Example"><span>4.3.4.2 Example</span></h5><p>&nbsp;Suppose that the ipfilter service defined a property for the name of its config file:</p><pre>

# svcprop -p config/ipf_conf_path ipfilter
config/ipf_conf_path astring /etc/ipf/ipf.conf

</pre><p>&nbsp;To make this property manageable via NWAM, the ipfilter service developer would need to add an nwam/config property and ipf_conf_path property group:</p><pre>

# svcprop -p nwam/config ipfilter
nwam/config boolean true
# svcprop -p ipf_conf_path ipfilter
ipf_conf_path/label_name astring Path\ to\ ipf.conf\ file
ipf_conf_path/prop astring config/ipf_conf_path
ipf_conf_path/prop_type astring astring

</pre><h5 id="H4.3.4.3Considerations"><span>4.3.4.3 Considerations</span></h5><p>&nbsp;One definite drawback of this proposal is that it only works for services that are actual SMF services. However, we could hardwire in handling for any non-SMF services that seem important; and this could (hopefully) be another motivation to move things to the SMF framework.</p><p>&nbsp;Another downside is that configuration options that are hardwired into the UI will likely *look* better than options that are automatically added. This could be mitigated somewhat by structuring the UI to make a distinct separation between hardwired and automatic properties (without going too far, of course; these are all parts of Environment config).</p><p>&nbsp;It might also be possible to make this a somewhat separate follow-on project.</p><h3 id="H4.4EnvironmentPolicy"><span>4.4 Environment Policy</span></h3><p>&nbsp;This section describes the way a user can create Environments for NWAM and also how the policy for selecting the appropriate Environment will work.</p><h4 id="H4.4.1CreatinganEnvironment"><span>4.4.1 Creating an Environment</span></h4><p>&nbsp;The creation of a new Environment would be explicitly initiated by the user via the User Interface (UI). When the user indicates that s/he wishes to create a new Environment, the UI would enable the user to provide the list of attributes associated with that Environment. This set of attributes (or outputs) would be available when the Environment is active. See <span class="wikilink"><a href="#environment_content">§4.3 just above</a></span> for a list of these attributes.</p><p>&nbsp;Due to the system-wide nature of these attributes, only one Environment may be active at any time. Based on each attribute selected, a detailed description of services/rules and/or configurations applicable to that particular attribute will be presented. So, for example, if the user wants to specify a particular node name for the machine, and so selects the attribute "Node Name", the UI will prompt him/her for the node name s/he wants to give the machine.</p><p>&nbsp;The user will also need to specify some sort of selection criteria (or input) such that the NWAM daemon can find the best-fit Environment, given the information available. These selection criteria include IP address, domain name, ESSID and/or BSSID to connect to (in case of wireless) and possibly the active link available.</p><h4 id="H4.4.2SelectinganEnvironment"><span>4.4.2 Selecting an Environment</span></h4><p>&nbsp;By default, NWAM will provide two Environments - a "No Network" Environment and an "Automatic" Environment At the time of selection of Environments, the NWAM daemon will first check for the number of active links available. If there are no active links available, then the daemon will not try to apply any Environment, neither user-defined nor "Automatic". Instead, it will assume that the "No Network" Environment should apply, and that the attributes for the machine in the stand-alone mode are required. However, if an active link is discovered, the daemon will examine the Conditions of each Environment and select the one which matches. If none match, the "Automatic" profile will be available as a fall-back, allowing the NWAM daemon to connect to some available network (per <span class="wikilink"><a href="/bin/view/Project+nwam/2%2DRequirements">Requirement #7</a></span>). If more than one Environment has Conditions which are met, the Priority of the matching Environments will be used as a tie-breaker.</p><h3 id="H4.5ExternalNetworkModifiers"><span>4.5 External Network Modifiers</span></h3><p>&nbsp;The NWAM solution must be able to coexist with external entities, in particular those provided by third parties, which may perform their own link/IP configuration. We will henceforth use the term External Network Modifiers (ENM). Configuration performed by an ENM cannot be stored within the NWAM framework; this would require that the user understand the details of how the service is configured, or that NWAM be designed with that knowledge, for all possible services. Neither of these alternatives is practical.</p><p><span class="wikilink"><a href="#ext_init_config">§4.5.1</a></span> describes the coexistence of NWAM and ENMs when they have no knowledge of each other. §s <span class="wikilink"><a href="#svc_reg_interface">4.5.2</a></span> and <span class="wikilink"><a href="#enm_api">4.5.3</a></span> discuss an interface provided by NWAM which will allow better integration of NWAM and ENMs.</p><h4 id="H4.5.1Externally-InitiatedConfiguration"><span>4.5.1 Externally-Initiated Configuration</span></h4><p>&nbsp;The model described in <span class="wikilink"><a href="#ncp_contents">§4.1</a></span> allows externally-initiated configuration; if an ENM (such as a VPN application) does any new plumbing, NWAM's view of the system will be updated to reflect the changes. This will be done by creating in-memory representations of these new links and/or IP interfaces; as such, these changes are considered transient and not part of the NCP stored in the repository.</p><p>&nbsp;When the NWAM service is restarted or refreshed, transient changes will not be recreated. It is not feasible for NWAM to attempt to recreate a given configuration for which it does not have a complete description; nor is it reasonable to extract the NWAM-controlled part of the configuration and only reset that part. Rather, the restart/refresh request must be treated as a request from the administrator for NWAM to restore a specific configuration, i.e. the current NCP stored in the repository.</p><p>&nbsp;If the ENM is an SMF service, it can be restarted automatically in this case with a dependency (with <span class="box code">restart_on refresh</span> attribute) on the NWAM service, but non-SMF services will need manual intervention to recover.</p><h4 id="H4.5.2ServiceRegistryInterface"><span>4.5.2 Service Registry Interface</span></h4><p>&nbsp;ENMs may be registered with NWAM, allowing NWAM to correctly enable and disable them as needed. The registration may be performed by the ENM itself via an NWAM-provided API, or by the user via the NWAM UI.</p><p>&nbsp;An "unregister" operation will also be provided, removing a registered ENM.</p><p>&nbsp;Registered ENMs will be instances of the NWAM service. Attributes will include:</p><ul><li>name</li><li>when to activate: whenever possible, contingent (on an NCU), or on user request</li><li>start and stop property groups</li><li>Environment: the ENM may identify an Environment which should be activated when it is enabled.</li><li>state: enabled/disabled/maintenance; set by NWAM. Depends on the last action taken (start/stop, and whether or not it completed successfully).</li></ul><p>&nbsp;When an ENM is registered with NWAM, its instance will be created; it will not be tied to the current NCP. Thus, if the NCP is changed, the ENM registration will not be affected.</p><h4 id="H4.5.3APIforExternalNetworkModifiers"><span>4.5.3 API for External Network Modifiers</span></h4><p>&nbsp;In addition to the service registry, NWAM will offer several control hooks to ENMs. ENMs need not be registered with NWAM to take advantage of these control hooks.</p><h5 id="H4.5.3.1EnvironmentSelectionEngine"><span>4.5.3.1 Environment Selection Engine</span></h5><p>&nbsp;ENMs may request that the Environment selection engine be run; this may be desired if the ENM makes changes which may not automatically trigger the engine (such as bump-in-stack VPNs, which do not create any new links or system changes detectable by NWAM).</p><p>&nbsp;An additional hook will allow ENMs to request that the selection engine <strong>not</strong> run until a further request to run it is received. This may be desirable if the ENM is making a series of configuration changes, and it wants to be sure that NWAM does not react until all of its changes have completed. A timeout must be included with this request.</p><h5 id="H4.5.3.2EnvironmentSpecifications"><span>4.5.3.2 Environment Specifications</span></h5><p>&nbsp;NWAM will also provide an interface for external entities, including ENMs, to load complete Environment specifications, including conditions under which the Environment should be applied. Thus, an NWAM-aware ENM would be able to specify the Environment that should be activated when the ENM is enabled.</p><p>&nbsp;These Environment specifications will be visible through the NWAM UI, and may be modified by the user, as with any other Environment specification. The intention here is to allow an application to install itself such that minimal user intervention is required; but a user who wishes to further customize may certainly do so.</p><h3 id="H4.6Wireless"><span>4.6 Wireless</span></h3><h4 id="H4.6.1PrioritizingofWLANs"><span>4.6.1 Prioritizing of WLANs</span></h4><p>&nbsp;The NWAM daemon maintains a "Preferred WLANs List" which contains the information of all the WLANs that the system has connected to and the used has asked NWAM to remember. This information includes the ESSID, BSSID, the priority of each WLAN, and the type of encryption/authentication used (if any). When a system needs to connect to a network, the daemon scans for the available WLANs. This list of available WLANs is henceforth referred to as the "available WLAN List".</p><p>&nbsp;Since it is quite possible to have multiple known WLANs available at the time the system needs to connect to the network, it is required that some kind of prioritization be applied to the "Preferred WLANs List". NWAM will take a simple approach to the prioritization - it will allow the user to specify the order in which the known WLANs should be tried in order to connect, and, in the event that the user has not explicitly specified any order, it will assume that the known WLANs should be tried in the order in which they appear on the "Preferred WLANs List". The NWAM daemon will use the following policies to create and maintain the "Preferred WLANs List" -</p><ul><li>When the user selects an available WLAN to connect to, he has the option to "remember this WLAN". If this box is checked, the WLAN will be appended to the known WLAN list.</li><li>The user may explicitly add to (or remove from, or reorder) the known WLAN list via the UI's "Configure" option.</li><li>The UI will allow the user to enter WEP/WPA-PSK "keys" when connecting to networks secured by WEP/WPA and have the choice of whether or not to save these "with" the "Preferred WLANs List".</li></ul><p>&nbsp;The "Preferred WLANs List" will be used in the following ways by the nwam daemon to decide which WLAN to connect to:</p><ul><li>If the "Preferred WLANs List" is empty, then the user will be presented with the "available WLAN List", from which he can pick the WLAN to connect to. This list will be ordered in terms of signal strength - the WLAN with the highest signal strength will be at the top. The user can pick whichever WLAN works best for him.</li><li>If the "Preferred WLANs List" is not empty, but none of the available WLANs matches the WLAN entries in the "Preferred WLANs List", then the user is presented with the "available WLAN List" (ordered in terms of the signal strength), and is asked to select a WLAN to connect to.</li><li>If the "Preferred WLANs List" is not empty, and only one of the WLAN entries on the "Preferred WLANs List" matches the available WLANs, then the NWAM daemon automatically connects to this WLAN.</li><li>If the "Preferred WLANs List" is not empty, and more then one WLAN entries in it match the available WLANs, then the order of the "known WLAN List" will be followed. Thus, the daemon will try to connect to the entry appearing closest to the top of the "Preferred WLANs List". In the event that this connection cannot be established, the next highest entry in the "Preferred WLANs List", which also appears on the "available WLAN List" will be tried, and so on. The connection to the highest priority known WLAN would be established irrespective of the signal strength it displays. This might seem a bit arbitrary especially if the known WLAN signal strength is low and the signal strength of a new or lower priority WLAN is high, but since the user has already indicated a preference, it will be followed. The UI will provide a facility to the user which will display the signal strengths of all the WLANs available. If the user gets too frustrated by the connection quality, he can check for the signal strengths of other available WLANs, and select another WLAN with a stronger signal to connect to.</li><li>If the system is already connected to a known WLAN and another WLAN becomes available which is a new or lower priority known WLAN but with higher signal strength, the daemon will not undo an existing established connection. If the user gets too frustrated with the connection quality, he can use the UI facility to scan for all available WLANs and can change the WLAN to connect to.</li><li>If the system is connected to an WLAN which is not in the "known WLAN List" (or is maybe of a low priority), and a new WLAN becomes available which has a higher priority in the "Preferred WLANs List", the daemon would indicate this development to the user. This would most likely be done via visual flag on the Panel.</li></ul><p>&nbsp;It should be noted that any time a switch takes place between WLANs, it can affect some currently running applications, and therefore it is better to warn the user that doing so would affect currently running TCP applications. Currently neither Windows nor Mac OS prompt any such warning.</p><p>&nbsp;Non-broadcast WLANs are those that don't show up in the `wificonfig scan`. They require that user inputs the ESSID at the very first time. The NWAM daemon keeps track of all non-broadcast wireless LANs which a user has specified, as described in the discussion above about the Preferred WLANs List. This would include both the non-broadcast WLANs that it has successfully connected to, and also those that the user has provided but may not have been connected to yet, unless the user specifically deletes the entry from the "Preferred WLANs List".</p><p>&nbsp;Only one "Preferred WLANs List" is maintained for the system instead of a per NCU list, which will include both the broadcast as well as the non- broadcast WLANs. The biggest reason for maintaining a single list is to avoid the deadlock situation at boot time. The NWAM daemon has to know which Profile would need to get activated when the system boots up. However, to decide which Profile gets activated, the daemon would have to know which WLANs are available, which makes it a deadlock if the "Preferred WLANs List" is kept per Profile. The "Preferred WLANs List" will be stored in the SMF repository (libscf.3LIB). The "available WLAN List", however, will be created per NIC, but all the respective "available WLAN Lists" for all NICs will be rolled into one master "available WLAN List" to be presented to the user.</p><p>&nbsp;As mentioned above, the user decides the order in which WLANs appear in the "Preferred WLANs List". Whichever WLAN has been assigned the highest ordering by the user, will be tried first (irrespective of whether it is a broadcast WLAN or a non-broadcast WLAN).</p><p>&nbsp;Note: during design, it was suggested that "many users would like to choose between available known networks at connect time rather than having to make a persistent decision which will often be wrong". As we did not have sufficient data about which model would be better, we chose the one which we thought was more "auto-magic".</p><h4 id="H4.6.2PeriodicScanofWirelessAccessPoints"><span>4.6.2 Periodic Scan of Wireless Access Points</span></h4><p>&nbsp;The daemon would have to perform periodic scan of all available wireless APs to ensure completeness of information about the network. The scan needs to be done periodically so as to make sure that any WLANs that were not visible at boot time (or connection establishment time), but have become available later, do not get ignored. This is especially important in situations where the WLAN which has become available later is actually present in the "known WLAN List" with a higher priority than the one with which connection is currently established.</p><p>&nbsp;As of now, the scan will be done on a fixed interval, the exact duration of which will be determined later. Apart from this, scan should also happen every time the user uses the UI option to list the available WLANs.</p><p>&nbsp;Effect of frequent scans on the system:</p><ol><li>CPU impact - Based on a high level overview of the existing code (usr/src/uts/common/io/ath/) it seems like the probe requests sent out are just like any other network packets sent out, and the response is also treated like normal networking packets received. It is, therefore, safe to assume that they carry minimum impact. They generate an interrupt, but do not over-tax the CPU.</li><li>Battery impact - This is a bigger cause of concern since frequent scanning would drain battery power. Also, this impact would differ on different types of systems based on their make and manufacturers. It is not clear how exactly to address this issue.</li><li>One of the problems that might arise with periodic scanning is that the the hardware may not be able to support simultaneous sending/receiving packets on the currently connected WLAN. For example, scanning requires the NIC to switch between different frequencies, so a NIC may not provide the support to send a probe at a given channel and listening on that channel for a reply while allowing sending/receiving packets on the currently connected WLAN as the channel is different.</li><li>Another issue to be considered is whether the scan intervals should be user-specifiable or not. Currently the maximum number of transmit attempts (ATH_TXMAXTRY) and the minimum scan interval (IEEE80211_INACT_MAX) both seem to be hard-coded which seems a little arbitrary. libwladm allows the user to specify properties, but it is not clear at this point whether the scan interval can be set through wladm_set_prop(). The aim is that the user should be able to increase the scan frequency via the UI, and there should also be a separate setting for the scan frequency when the system is on battery power.</li></ol><h3 id="H4.7Routing"><span>4.7 Routing</span></h3><p>&nbsp;Generally speaking, routing is an area where complex configuration and policy details should remain part of the subsystem, and not be subsumed by NWAM. NWAM's role should be that of administrator, specifying the circumstances under which the subsystem (or components of the subsystem) should be enabled; <span class="wikilink"><a href="#routing_admin">§4.7.1</a></span> will discuss this aspect of NWAM's relationship with the routing subsystem.</p><p>&nbsp;Unfortunately, it is difficult to make such a clean distinction between NWAM and the routing subsystem. There are a couple additional areas in which NWAM must interact with the routing subsystem; these are discussed in <span class="wikilink"><a href="#route_provider">§4.7.2</a></span> and <span class="wikilink"><a href="#routing_policy">§4.7.3</a></span>.</p><p>&nbsp;Finally, the interfaces between NWAM and the routing subsystem's Routing Information Base (RIB), for the setting of both routes and routing policy, are defined in <span class="wikilink"><a href="#routing_interfaces">§4.7.4</a></span>.</p><h4 id="H4.7.1NWAMasRoutingAdministrator"><span>4.7.1 NWAM as Routing Administrator</span></h4><p>&nbsp;One component of the Upper Layer Profile/Environment will be the specification of which routing daemons to run. NWAM will build on the functionality introduced by the <span class="wikilink"><a href="/bin/view/Project+quagga/">Quagga</a></span> project to convert routing services to the SMF framework. As SMF services, the different routing service options can easily be enabled/disabled by NWAM as specified by the user.</p><p>&nbsp;The NWAM interface will offer the user all the functionality that is available through the <span class="box code">routeadm(1M)</span> command. That is, the user will be able to select whether or not IPv4 routing, IPv4 forwarding, IPv6 routing, and IPv6 forwarding are enabled, as well as which routing daemons to run if routing is enabled.</p><h4 id="H4.7.2NWAMasRouteProvider"><span>4.7.2 NWAM as Route Provider</span></h4><p>&nbsp;The user may wish to set static routes for a particular environment. Thus, a list of static routes will be an additional component of the Upper Layer Profile/Environment. When the ULP/Environment is enabled, NWAM will pass these routes to the RIB, which will apply policy and send routes to the kernel's Forwarding Information Base (FIB) as needed. The interface between NWAM and the RIB is specified in <span class="wikilink"><a href="#routing_interfaces">§4.7.4</a></span>.</p><h4 id="H4.7.3NWAMasRoutingPolicyProvider"><span>4.7.3 NWAM as Routing Policy Provider</span></h4><p>&nbsp;On multi-homed systems, it is possible that automatic configuration could result in multiple routes to a given destination. The most common example of this is the case where a system with two interfaces uses DHCP on both interfaces, and is given the address of a different "default" router (i.e. a route to destination 0.0.0.0 or ::0) on each interface. In that case, the user may specify a preferred interface as part of the NCU. NWAM will pass this preference to the RIB, which will take it into account when determining which routes to send to the FIB. Routes learned via DHCP and IPv6 Router Advertisements will be sent to the RIB for policy filtering, rather than directly to the kernel's FIB, as is currently the case.</p><h4 id="H4.7.4InterfacesBetweenNWAMandtheRIB"><span>4.7.4 Interfaces Between NWAM and the RIB</span></h4><p>&nbsp;The zebra daemon will serve as the RIB, receiving routes from various sources (routing daemons, <span class="box code">dhcpagent</span>, <span class="box code">in.ndpd</span>, NWAM) and policy information (currently only from NWAM, but possibly from other sources in the future). Given a set of policy rules, it will decide which of the routes it receives should be passed to the FIB in the kernel; it will also have the ability to delete routes from the FIB if policy changes make this necessary.</p><p>&nbsp;The interface by which routes are specified will be based on the existing <span class="box code">PF_ROUTE</span> socket interface.</p><p>&nbsp;The interface by which routing policy is specified will be extensible, so that in the future different types of policy may be passed using the interface; but initially, interface preferences will be the only type of policy specified.</p><p>&nbsp;It should be noted that this design requires changes beyond the NWAM project:</p><ul><li><span class="box code">dhcpagent</span> and <span class="box code">in.ndpd</span> will need to be modified to use the new interface to the RIB to set routes, rather than sending them directly to the kernel. These changes will be fairly small and can be completed by the NWAM team.</li><li>The zebra daemon will be used as the RIB. Though this daemon currently receives routes from some routing daemons, it will need to be extended to support both the route-setting interface and the policy-setting interface. These changes will be more involved and would ideally be completed as follow-ups to the <span class="wikiexternallink"><a href="https://markebrooks.github.io/bin/view/Project+quagga">Quagga</a></span> project.</li></ul><h3 id="H4.8StaticConfiguration"><span>4.8 Static Configuration</span></h3><p>&nbsp;Static (link &amp; IP) configuration means everything has a fixed value, which also implies that the conditions are static and thus whatever Environment is selected is also static. This is all just a degenerate case of the rest of this document; this section is only included for the sake of completeness.</p><h3 id="H4.9LegacySupport"><span>4.9 Legacy Support</span></h3><h4 id="H4.9.1files"><span>4.9.1 <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>hostname<span style="color: #666666; ">.//</span>interface<span style="color: #666666; ">//</span></span> files</span></h4><p>&nbsp;One of the most vile interfaces (in the <span class="box code">attributes(5)</span> sense) in all of Solaris is using <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>hostname.interface</span> (in the <span class="box code">ifconfig(1m)</span> sense) to configure network interfaces. This project will make these interfaces obsolete, but we will still have to deal with them to be backward compatible.</p><p>&nbsp;Fortunately, a check of the various man pages which mention them indicates that their documented use is of the form <em>write to this file, then it will be consumed at the next system boot</em>. So migration is proposed as follows.</p><p>&nbsp;When the NWAM daemon starts, it will look at the existence of these files and translate the information to the SMF repository (see §4.9.2 just below for details of the SMF representation):</p><ul><li>If no information exists for the corresponding interface, NWAM will create an instance, <span class="box code">svc:<span style="color: #666666; ">/</span>network<span style="color: #666666; ">/&lt;</span>TBD NWAM service name<span style="color: #666666; ">&gt;</span>:ip<span style="color: #666666; ">-&lt;</span>NCU name<span style="color: #666666; ">&gt;</span></span>. NWAM will also need to set up appropriate dependencies between the created instance and other instances.</li><li>If a corresponding service instance already exists, NWAM will check the information, such as property values and dependencies, and decide if there is a conflict. If not, nothing needs to be done. When there is a conflict, whatever is in the SMF repository will be honored and the user will be notified of the conflict(s).</li></ul><p>&nbsp;During the lifetime of the NWAM daemon, it does not check for any changes to these files: they are only read when the service starts.</p><p>&nbsp;At fresh install, NWAM will automatically detect the existence of NICs, create a service instance for each interface and apply some default properties on them. If NWAM detects that some interfaces can be grouped into one IPMP group, it will do so and create the corresponding "IPMP" instance.</p><p>&nbsp;If the user plugs in a new device, s/he is encouraged to use the NWAM UI to configure the link and interface(s) above it. If s/he chooses to use the traditional way, editing a hostname.&lt;if&gt; and using ifconfig, information in the file will not be imported to SMF until a reboot or a restart of the NWAM service.</p><h4 id="H4.9.2SMFrepresentation"><span>4.9.2 SMF representation</span></h4><p>&nbsp;Information from <span class="box code"><span style="color: #666666; ">/</span>etc<span style="color: #666666; ">/</span>hostname<span style="color: #666666; ">.//</span>interface<span style="color: #666666; ">//</span></span> files will be stored as an <span class="box code">:ip<span style="color: #666666; ">-&lt;</span>NCU name<span style="color: #666666; ">&gt;</span></span> service instance in SMF. More details in §5.1.</p><h2 id="H5.NetworkServiceModel-1"><span>5. Network Service Model</span></h2><p>&nbsp;This section might also be called "how we interact with SMF".</p><h3 id="H5.1SMFRepresentation"><span>5.1 SMF Representation</span></h3><h4 id="H5.1.1ServiceInstances"><span>5.1.1 Service Instances</span></h4><p>&nbsp;The NWAM service can have the following instances.</p><dl><dt>:default</dt><dd>This is the default instance for NWAM service, which will be brought up by svc.startd(1M). It will launch the NWAM daemon.</dd><dt>:link-&lt;NCU name&gt;</dt><dd>This kind of instance represents a datalink. It will be created/modified by the NWAM daemon as needed to reflect changes to the NCP configuration. Its properties include:</dd></dl><ul><li>link-class: phys, iptun, aggr or vlan</li><li>when to activate: whenever possible, never, or contingent</li><li>what kinds of address selection methods to accept on an interface above this link</li></ul><dl><dt>:ip-&lt;NCU name&gt;</dt><dd>This kind of instance represents an IP interface. It will be created/modified by the NWAM daemon as needed to reflect changes to the NCP configuration. Its properties include:</dd></dl><ul><li>interface-class: simple, ipmp, loopback or vni</li><li>IP version: 4 or 6</li><li>IP address-source</li><li>when to activate: whenever possible, never, or contingent</li></ul><dl><dt>:enm-&lt;ENM name&gt;</dt><dd>This kind of instance represents an External Network Modifier which has been registered with NWAM. Its properties include:</dd></dl><ul><li>start and stop property groups</li><li>Environment: the Environment to be activated when the ENM is enabled</li><li>state: enabled/disabled/maintenance; set by NWAM</li><li>when to activate: whenever possible, never, contingent, or on user request</li></ul><p>&nbsp;Appropriate dependencies will be specified when an instance is created; SMF dependencies will be used to model the contingent activation of NCUs. If the value of "when to activate" is "contingent", it means whether to bring up this NCU entity is contingent to some other NCU entity. Hence a dependency should be set up between this and the other party, for example, if bge0 is up then don't bring ath0 up, then NCU-ath0 should depend on NCU-bge0 as <span class="box code">exclude_all</span> dependency. (See the Dependencies section in smf(5) for a more detailed description.)</p><p>&nbsp;Additionally, a dependency on each new instance will be added to the :default instance to insure that the new instance will be included in the dependency graph. This will prevent problems caused by changing run-levels, which could disable instances that are not tied in to the graph.</p><p>&nbsp;There might be other dependencies. For example, a "simple" ip.&lt;NCU name&gt; requires a physical link under it, so it should depend on a particular link.&lt;NCU name&gt; as <span class="box code">require_all</span> or depend on a set of link.&lt;NCU name&gt; instances as <span class="box code">require_any</span>.</p><h4 id="H5.1.2SMFprofiles"><span>5.1.2 SMF profiles</span></h4><p>&nbsp;Both NCPs and Environments are instances of Enhanced SMF profiles. NCPs should be one layer below Environments logically because information in NCPs is applied first and which Environment to select is determined by the NCP and the policy engine.</p><h3 id="H5.2WEPKeyStorage"><span>5.2 WEP Key Storage</span></h3><p>&nbsp;The biggest concern about wepkey is its security. wepkey handle, a name to indicate a wepkey, is stored in SMF repository along with other data NWAM manipulates. The name of the wepkey should indicate not only the network this wepkey is associated but also the user who inputs this wepkey. The value of the wepkey, the secure part, is manipulated(get and set) by libdladm. When NWAM detect a wireless network which need a wepkey to access, it calls libdladm to retrieve the value of the wepkey, and use the value to connect to the network. If none is found, NWAM prompts user to input one. NWAM then uses what user inputs to connect, creates a secure object using libdladm, and sets its value to what user input for later reference.</p><h3 id="H5.3SMFMethods"><span>5.3 SMF Methods</span></h3><p>&nbsp;The :default instance will have a start method, a refresh method, and a stop method. The NWAM daemon will be a delegated restarter for its dynamic instances, and thus the methods for those instances will be managed internally by the daemon.</p><h3 id="H5.4SMFServiceModel"><span>5.4 SMF Service Model</span></h3><h4 id="H5.4.1Proposal"><span>5.4.1 Proposal</span></h4><p>&nbsp;The existing SMF services network/loopback, network/physical, network/initial, network/services will be deleted. The transient tasks currently done by these services will be done by the NWAM daemon except the IPsec related and the IP tunneling related parts of network/initial. (Note that one or more new services will be created for IPsec as part of the work to fix bug 6185380.)</p><p>&nbsp;The existence of milestone/network is misleading. Some poorly written applications may have created a dependency on it, thinking that this would ensure a connection to peer hosts. However, such a milestone cannot guarantee the connection to any peer. Ideally this milestone should be deleted. But for backward compatibility, it will will remain for now, and be marked as obsolete so that we can delete it later.</p><p>&nbsp;NWAM will introduce a new SMF service: network/profiled. This service will only depend on system/device/local which in turn depends on filesystem/usr. This service will have instances as described in §4.1.3.</p><h4 id="H5.4.2Howitworks"><span>5.4.2 How it works</span></h4><p>&nbsp;First, a few definitions are needed:</p><ul><li>reset: bringing the system from where it is (point A) to where the active NCP says it should be (point B); there are two variants:</li><li>hard reset: we tear everything (except manual NCUs) down, then configure everything according to the active NCP. In other words, we go from A to 0 to B.</li><li>soft reset: we go directly from A to B, making as few changes as possible to get there.</li></ul><ul><li>On boot, we configure everything according to the repository, as specified in the sequential list below. Once this configuration is complete, we place a marker somewhere (perhaps a file in <span class="box code"><span style="color: #666666; ">/</span>var<span style="color: #666666; ">/</span>run</span> or perhaps some other mechanism). Note that this is just a special case of the "not found" scenario immediately below; it is mentioned here merely for explanatory purpose.</li><li>On service start, we look for this marker.<ul><li>If it is found (i.e., we have already been running), we assume that we died prematurely, and attempt to resume subsequent operations (i.e., monitoring for new links appearing or old links going away or whatever) without making any changes as we start.</li><li>If it is not found (i.e., we have not already been running), we assume this is an initial start and we treat it like a hard reset, and bring anything which we find down (except manual NCUs), then configure everything per the repository (again, see the sequential list below). Note that boot is just a special case of this scenario. Note also that bringing everything (except manual NCUs) down will have the result that any network connections established on top of the affected NCUs will be lost.</li></ul></li><li>On explicit service stop, we tear everything down (except manual NCUs), including the marker. Again, note that this tear-down will have the result that any network connections established on top of the affected NCUs will be lost. To aid debugging, a committed interface will be provided to have NWAM exit without tearing anything down.</li><li>As a result of the above, service restart behaves just like a hard reset.</li><li>We treat service refresh like a soft reset.</li></ul><p>&nbsp;Further clarification on restart: if the NWAM service were to have a dependency on some other service with a <span class="box code">restart_on</span> value of something other than <span class="box code">none</span> then there would be a risk of service disruption, but we do not anticipate any such dependencies. So the only ways the NWAM service should be administratively restarted are 1) if the user explicitly requests it via <span class="box code">svcadm restart</span> and 2) via reboot.</p><p>&nbsp;Distinction between restart and refresh: as mentioned above, restart behaves like a hard reset, whereas refresh is treated like a soft reset. Thus any system administrator should choose carefully between the two, as restart represents a much bigger hammer. As such, we expect that refresh will be far the more common operation, as it will not involve disrupting any existing connections or higher level service which might be using them.</p><p>&nbsp;The following sequential steps are taken to configure everything according to the repository:</p><ol><li>NWAM plumbs and configures the loopback interface first.</li><li>If any security rules (IP filter and/or IPsec and/or any other security) need to be loaded when only loopback is available, NWAM will load them. By default, IP filter will be disabled and no IP filter rules will be loaded. If the user configures any IP filter rules, NWAM can enable the IP filter start service to load them and start IP filtering.</li><li>NWAM then enables milestone/network.</li><li>NWAM applies the active NCP onto the system; i.e., certain <span class="box code">:link<span style="color: #666666; ">-&lt;</span>NCU<span style="color: #666666; ">&gt;</span></span> and <span class="box code">ip.<span style="color: #666666; ">&lt;</span>NCU<span style="color: #666666; ">&gt;</span></span> instances will be created.</li><li>NWAM then applies the stand-alone Environment to the system. Meanwhile the daemon tries to gather information from outside networks and to connect to one or more networks.</li><li>If some network is connected (see §2.3) and we need to switch to another Environment, the daemon will perform an Environment switch.</li></ol><p>&nbsp;After starting, the NWAM daemon will keep listening for any network environment changes and user administration activities (for instance, a user asking for a profile switch or a user making a change in the active Environment). If such a change will cause an Environment switch or some service(s) to be refreshed, the NWAM daemon will do so.</p><h4 id="H5.4.3Environments"><span>5.4.3 Environments</span></h4><p>&nbsp;NWAM will provide a default stand-alone Environment (applied at step 5 in §5.4.2 just above) and a default networked Enviroment. Although these two Environments will have the same default values (except for sshd), they are provided separately to facilitate customization: users can customize each of these Environments, though there should be only one stand-alone Environment. Users can create more Environments and associate each with a different network environment. Users can also choose to stay stand-alone even when a network is detected.</p><p>&nbsp;In any Environment, there will be a list of properties that will be applied on the system, and a list of services that will be enabled and/or disabled in that network environment.</p><h4 id="H5.4.4Dependencyrearrangement"><span>5.4.4 Dependency rearrangement</span></h4><p>&nbsp;For the services that currently have any sort of direct dependencies on those deleted services, all dependencies will be deleted. Some services will be enabled by default (meaning that NWAM profiles will not control them) and some will be controlled by an NWAM profile (enabled or disabled). Below is a detailed description of each individual services. (Note: services listed below may have other dependencies than those deleted. But since those dependencies will remain as is and to keep things simpler, they are not listed below. For instance, "network/ipfilter" depends on "network/physical", "filesystem/usr" and "system/identity:node". But since network/physical will be deleted by NWAM, we only listed the dependency on network/physical, only this dependency will be deleted and others will remain as they are.)</p><table><tr><th scope="col">service name</th><th scope="col">current dependency</th><th scope="col">future default disposition</th></tr><tr><td>milestone/single-user:default</td><td>network/loopback (require-any)</td><td>enabled, not controlled by any NWAM profiles</td></tr><tr><td>system/identity:node</td><td>network/loopback (require_any) and network/physical (optional_all).</td><td>The NWAM daemon will set the node name and domain after it decides the value for each, then the daemon will enable the services. The services should be refreshed if the network environment changes and the change causes the nodename / domain to change.</td></tr><tr><td>system/identity:domain</td></tr><tr><td>network/ipfilter:default</td><td>network/physical (require_all).</td><td>disabled in standalone Environment</td></tr><tr><td>network/ssh:default</td><td>network/loopback (require_all) and network/physical (require_all).</td><td>disabled in standalone profile</td></tr><tr><td>network/smtp:sendmail</td><td>network/service (require_all).</td><td>enabled in standalone profile as local-only mode and needs to be refreshed if the network environment changes.</td></tr><tr><td>network/inetd:default</td><td>network/loopback (require_any)</td><td>enabled in standalone profile</td></tr><tr><td>network/iscsi_initiator:default</td><td>network/loopback (require_any)</td><td>enabled in standalone profile</td></tr><tr><td>network/rarp:default</td><td>network/loopback (require_any)</td><td>disabled in standalone profile</td></tr><tr><td>network/slp:default</td><td>network/loopback (require_any)</td><td>disabled in standalone profile</td></tr><tr><td>network/shell:kshell</td><td>network/loopback (require_any)</td><td>disabled in standalone profile</td></tr><tr><td>network/shell:default</td><td>network/loopback (require_any)</td><td>disabled in standalone profile</td></tr><tr><td>network/ntp:default</td><td>network/service (require_any)</td><td>disabled in standalone profile</td></tr><tr><td>network/dns/server:default</td><td>network/loopback (require_any)</td><td>disabled in standalone profile</td></tr><tr><td>network/dns/client:default</td><td>network/loopback (require_any) and network/service (require_any)</td><td>disabled in standalone profile</td></tr><tr><td>network/ldap/client:default</td><td>network/initial(require_all)</td><td>disabled in standalone profile</td></tr></table><p>&nbsp;Note: if a user wants to run some disabled service(s) above, s/he can modify and provide his/her own custom copy of the standalone Environment.</p><h2 id="H6.Processes26Threads-1"><span>6. Processes &amp; Threads</span></h2><h3 id="H6.1Breakdown"><span>6.1 Breakdown</span></h3><p>NWAM will be broken down into a set of processes and threads. This section specifies how this will be done. This section is coupled with §8.1 (Internal IPC) and §8.2 (External IPC).</p><p>Along with this section are diagrams which show how the nwam daemon interacts with the system and other processes and another diagram which shows some of its internal organization into threads. The diagram is available at <span class="wikiexternallink"><a href="https://markebrooks.github.io/bin/download/Project+nwam/4-Design/nwamprocess.pdf">nwam_process.pdf</a></span>.</p><p>At this time there is no room for a legend on the diagrams so here is help in interpreting the diagrams. In the first diagram (NWAM sys interaction) the diagram is broken up by a horizontal red bar which indicates the user space/kernel space split. Circles below the bar indicate conceptual sources of events. In some cases those will actually be connected through the kernel to another user space process or might actually be multiple sources of information. Boxes above the line indicate user space processes. Ovals above the line indicate shared objects or families of shared objects. A line connecting a box to an oval indicates that the process (box) uses the shared object (oval). Arrow between boxes indicate primary data flow. There is also a vertical line which indicates the separate between two zones. With shared networking stacks the configuration information will be provided by the nwam daemon in the global zone. For zone exclusive stacks the configuration information will be provided by a nwam daemon running in the zone the stack is attached to.</p><p>In the second diagram (NWAM proc design) the same kernel/user space horizontal bar exists. Below the bar are event sources. Above the bar boxes indicate threads within the NWAM process (instead of separate processes as they did on the previous diagram). Ovals indicate shared objects again. Lines indicate a uses relationship and arrows indicate data flow. Rectangles with horizontal lines through them indicate a queue used for inter-thread communication.</p><h4 id="H6.1.1Corefunctionality"><span>6.1.1 Core functionality</span></h4><p>The core functionality of NWAM will be contained in a single daemon. Within that daemon will exist a set of threads used to manage various asynchronous needs.</p><h4 id="H6.1.2maineventloop28MEL29"><span>6.1.2 main event loop (MEL)</span></h4><p>A single thread will be used to manage the main event loop (section 3) The other threads will gather up events and feed to them to queue that this thread retrieves its work from.</p><h4 id="H6.1.3eventcollection"><span>6.1.3 event collection</span></h4><p>A set of threads will be used to collect events. Each of these threads will collect events and place them on the main event queue for the main event loop to consume.</p><p>A single thread will be used to turn signals into synchronous events. Signals will be blocked in all threads. <span class="box code">sigwait(2)</span> is used to wait for threads and that that thread will determine how to manage that signal. This allows for the synchronous management of signals.</p><p>A thread will be used to collect file based events. At this time these are the events from the routing socket.</p><p>A thread will be used to wait for sys events.</p><h4 id="H6.1.4IntegrationwithZones"><span>6.1.4 Integration with Zones</span></h4><p>Post stack instances (Nevada build 57) the administrative model for interfaces in zones with exclusive stacks is similar enough to that of a global zone and rich enough to be able to manage interfaces from within a zone. We will have a separate NWAM daemon running in the each zone to effect this. Shared stacks are administered from the NWAM daemon running in the global zone. The user can assign use of shared stacks to non global zones via zonecfg(1m).</p><h4 id="H6.1.5FutureintegrationwithCrossbow"><span>6.1.5 Future integration with Crossbow</span></h4><p>As more of Crossbow is integrated into Solaris the administrative model of Zones will become richer. In section 6.1 there is a description of how configuration will be applied across zones with different types of networking stacks.</p><h4 id="H6.1.6IntegrationwithCLI"><span>6.1.6 Integration with CLI</span></h4><p>The cli will be a single command modeled after zoneadm(1M).</p><h4 id="H6.1.7IntegrationwithGUI"><span>6.1.7 Integration with GUI</span></h4><p>Integration with the GUI will be done via the NWAM API defined in §7.3.</p><h4 id="H6.1.8IntegrationwithGnomepanelapplication"><span>6.1.8 Integration with Gnome panel application</span></h4><p>The API mentioned in §6.1.7 immediately above will be used to integrate with the Gnome panel application.</p><h3 id="H6.2InternalIPC"><span>6.2 Internal IPC</span></h3><p>The current design for NWAM is as a single process. Since Stack Instances integrated further work will be done to have the nwam daemons managing zone exclusive networking stacks communicating with the daemon in the global zone if necessary.</p><h2 id="H7.UserInterface-1"><span>7. User Interface</span></h2><h3 id="H7.1CommandLineInterface"><span>7.1 Command Line Interface</span></h3><p>&nbsp;See our <span class="wikilink"><a href="/bin/view/Project+nwam/CLI">separate page</a></span> for this.</p><h3 id="H7.2GraphicalUserInterface"><span>7.2 Graphical User Interface</span></h3><p>&nbsp;See our <span class="wikilink"><a href="/bin/view/Project+nwam/ConfigUI">separate page</a></span> for this.</p><h3 id="H7.3DataStructures26APIs"><span>7.3 Data Structures &amp; APIs</span></h3><p>&nbsp;See our <span class="wikicreatelink"><a href="/bin/create/Project+nwam/5%2DAPI?parent=Project+nwam.4%2DDesign">separate page</a></span> for this.</p><h2 id="H8.DependencieswiththerestoftheSystem-1"><span>8. Dependencies with the rest of the System</span></h2><h3 id="H8.1Privileges"><span>8.1 Privileges</span></h3><h4 id="H8.1.1Introduction"><span>8.1.1 Introduction</span></h4><p>Least Privilege for Solaris (PSARC 2002/188) was introduced in Solaris 10 build 30 (2003-Feb-27). It provides a mechanism to divide up the privileges normally given to root so that processes can execute with a minimal set.</p><h4 id="H8.1.2Processrequirements"><span>8.1.2 Process requirements</span></h4><p>The NWAM processes will need the following privileges. Depending on how NWAM is broken into processes only a subset of these might be needed by any specific part of NWAM. The privileges needed by external processes (like dhcpagent, §2.1) are not listed here.</p><table><tr><th scope="col">privilege</th><th scope="col">requirement</th></tr><tr><td>PRIV_SYS_NET_CONFIG</td><td>§2.3 needed to configure network interfaces</td></tr><tr><td>PRIV_NET_RAWACCESS</td><td>§3, 4.7 (needed for routing socket)</td></tr><tr><td>PRIV_PROC_EXEC</td><td>§4.3 Environment selection script</td></tr><tr><td>PRIV_PROC_FORK</td><td>§4.3 Environment selection script</td></tr></table><p>Two types of user hook are available. The first (§4.4.2) allows the user to write code to query the state of the machine and select the appropriate environment. The second (§4.5) allows the user to provide a hook to invoke functionality not directly supported by NWAM.</p><p>The selection scripts do not need to be run with any special privileges. They are not allowed to modify their environment. This script will be run as a non-root user with basic privileges.</p><p>The configuration scripts will need to be run with privileges. Several designs have been discussed from exec'ng with all privileges to pfexec'ng from basic privileges. Since it is going to take root privileges to install one of these scripts (at least one that wants additional privileges) it is not seen as a burden for the user to have to create <span class="box code">exec_attr</span> entries for each script. Thus the configuration scripts should assume that they will be pfexec'd with a default of basic privileges.</p><h4 id="H8.1.3Startupconsiderations"><span>8.1.3 Startup considerations</span></h4><p>Nominally NWAM will be started by SMF. In order to allow an administrator to start NWAM by hand when debugging configuration privileges will be assigned to the NWAM processes (section 6) via exec_attr(4). This will be referenced via use_profile and profile in the smf_method(5) manifest.</p><h3 id="H8.2ExternalIPC"><span>8.2 External IPC</span></h3><p>&nbsp;There are multiple external processes which NWAM must communicate with. They are listed in the following table with information about the type of information exchanged and the method of IPC.</p><table><tr><th scope="col">External Entity</th><th scope="col">Purpose of</th><th scope="col">Kind of IPC interaction</th><th scope="col">Notes</th></tr><tr><td>RIB (Quagga)</td><td>interface preference</td><td>undefined</td><td><span class="wikilink"><a href="#routing">§4.7.1</a></span></td></tr><tr><td>kernel</td><td>obtain state changes</td><td>routing sockets</td><td><br/></td></tr><tr><td>DHCP</td><td>DNS server, default route, IP address, etc.</td><td>socket via libdhcpagent</td><td><br/></td></tr><tr><td>Link Status change</td><td>LINK_UP/DOWN info sys, *_RUNNING flag changes</td><td>sysevents, DLPI</td><td><br/></td></tr><tr><td>SMF</td><td>system management state changes</td><td>door via libscf</td><td><br/></td></tr><tr><td>CLI, GUI</td><td>allow for user interaction</td><td>door</td><td><span class="wikilink"><a href="#apis">§7.3</a></span></td></tr><tr><td>NWAM in other Zones</td><td>coordinate NWAM across zones</td><td>undefined</td><td></td></tr></table><h3 id="H8.3Install"><span>8.3 Install</span></h3><p>&nbsp;Between the Solaris installation program and the sysidtool(1m) suite of programs, many questions are asked of the user, several of which will no longer be needed once this project makes them obsolete. I.e., NWAM will do as its name suggests, and automatically determine network configuration for use both during installation and subsequently. If any permanent static network configuration is desired, it will be deferred; post-installation, the NWAM UI can be used for this.</p><p>&nbsp;Specifically, there are several programs in the sysidtool(1M) suite which will need to be modified not to ask questions for which NWAM will provide the answer. In particular:</p><ul><li>sysidnet will no longer need to query for network interface or IP address or IPv6 usage (IPv6 will be enabled by default)</li><li>sysidns will no longer need to query for anything; in fact, this may go away completely</li><li>sysidsys will no longer need to query for netmask (as no IP address will be queried for)</li><li>sysidnfs4 will no longer need to query for the NFSv4 domain (it will be left undefined)</li></ul><p>&nbsp;Note that the above may not square completely with the task breakdown claimed by sysidtool(1M), but that man page appears to be out of date; we are going thru the code to make sure we have the tasks broken down correctly. Note also that this is being addressed in a related project as part of <span class="wikiexternallink"><a href="https://markebrooks.github.io/bin/view/Project+caiman">Caiman</a></span>, so consider the above changes in that context.</p><p>&nbsp;Looking ahead to implementation, this will require multiple putbacks, as most of NWAM will go in the ON consolidation, whereas the sysidtools are in the Install consolidation, unless <span class="wikiexternallink"><a href="https://markebrooks.github.io/bin/view/Project+vpanels">Visual Panels</a></span> should happen to come along soon enough to save us the trouble.</p><hr/><h2 id="HAppendixA:Glossary-1"><span>Appendix A: <span class="wikicreatelink"><a href="/bin/create/Project+nwam/AB%2DGlossary?parent=Project+nwam.4%2DDesign">Glossary</a></span></span></h2><h2 id="HAppendixB:RevisionHistory-1"><span>Appendix B: Revision History</span></h2><table><tr><th scope="col">Revision</th><th scope="col">Date</th><th scope="col">Changes</th></tr><tr><td>0.1</td><td>2006-Apr-11</td><td>initial draft, cloned from Version 1.0.3 of Architecture</td></tr><tr><td>0.1.1</td><td>2006-Apr-18</td><td>changed section 4 name from <em>Configuration</em> to <em>Profiles</em></td></tr><tr><td>0.1.2</td><td>2006-Apr-20</td><td>split sections into child pages</td></tr><tr><td>0.2</td><td>2006-Aug-30</td><td>re-merged child pages, updated with months of discussions</td></tr><tr><td>0.2.1</td><td>2006-Aug-31</td><td>updated diagram, filled in §2.2</td></tr><tr><td>0.2.2</td><td>2006-Sep-01</td><td>updated §2.2</td></tr><tr><td>0.2.3</td><td>2006-Sep-13</td><td>Added introduction to §2</td></tr><tr><td>0.2.4</td><td>2006-Sep-14</td><td>First draft of §4.8</td></tr><tr><td>0.2.5</td><td>2006-Sep-26</td><td>First draft of §5.4</td></tr><tr><td>0.2.6</td><td>2006-Nov-03</td><td>First draft of §4.6</td></tr><tr><td>0.3</td><td>2006-Nov-10</td><td>Filled in §4.1 &amp; §4.3, merged §5.4.4 into §4.8.1, moved §5.4.5 to §4.3.3, rewrote §5.4</td></tr><tr><td>0.3.1</td><td>2006-Nov-21</td><td>Minor corrections to §5.4</td></tr><tr><td>0.3.2</td><td>2006-Nov-21</td><td>First draft of §4.3.1</td></tr><tr><td>0.3.3</td><td>2006-Nov-28</td><td>Filled in §4.4, minor tweaks to §4.3, added §8.3</td></tr><tr><td>0.3.4</td><td>2006-Dec-01</td><td>Revised §4.8</td></tr><tr><td>0.3.5</td><td>2006-Dec-04</td><td>First draft of §4.3.2</td></tr><tr><td>0.3.6</td><td>2006-Dec-05</td><td>Added §2.4</td></tr><tr><td>0.4</td><td>2006-Dec-08</td><td>Filled in §2.3, §6.0, §6.1, §8.1</td></tr><tr><td>0.4.1</td><td>2006-Dec-10</td><td>Fixed broken hierarchy in §6</td></tr><tr><td>0.5</td><td>2006-Dec-15</td><td>Major revision to §4.1</td></tr><tr><td>0.5.1</td><td>2006-Dec-19</td><td>Updated §s 4.8.2 and most of 5 to match §4.1</td></tr><tr><td>0.5.2</td><td>2006-Dec-21</td><td>Added §8.2</td></tr><tr><td>0.5.3</td><td>2006-Dec-21</td><td>Minor edits (orange text removal)</td></tr><tr><td>0.5.4</td><td>2006-Dec-21</td><td>Filled in §4.7, more orange text clean-up</td></tr><tr><td>0.5.5</td><td>2006-Dec-21</td><td>Updated §4.2 &amp; §4.8.1 to match §4.1</td></tr><tr><td>0.6</td><td>2006-Dec-21</td><td>Updated §1 to match §4.1</td></tr><tr><td>0.7</td><td>2006-Dec-22</td><td>Inserted new §4.5 (shifting §4.5 to §4.6, etc.), updated §4.1.2, §4.3. &amp; §5.1.1 to match</td></tr><tr><td>0.7.1</td><td>2006-Dec-23</td><td>Edited §8.1.2</td></tr><tr><td>0.7.2</td><td>2007-Jan-03</td><td>Minor edits to §s 1.3 &amp; 1.4</td></tr><tr><td>0.7.3</td><td>2007-Jan-04</td><td>Minor edits to many §s</td></tr><tr><td>0.7.4</td><td>2007-Jan-04</td><td>Revised §2.4</td></tr><tr><td>0.7.5</td><td>2007-Jan-09</td><td>Revised §8.1.2</td></tr><tr><td>0.8</td><td>2007-Jan-11</td><td>Minor update to §4.1.3, significant updates to §s 4.5 &amp; 5.4.2</td></tr><tr><td>0.8.1</td><td>2007-Jan-12</td><td>Fix typos from 0.8 updates</td></tr><tr><td>0.8.2</td><td>2007-Feb-02</td><td>Added §7.3: link to APIs doc</td></tr><tr><td>0.8.3</td><td>2007-Feb-13</td><td>Edit §6, §7.1: remove orange text</td></tr><tr><td>0.9</td><td>2007-Feb-16</td><td>Update §3: rewrite</td></tr><tr><td>0.9.1</td><td>2007-Feb-16</td><td>Update §6.1.4, §6.1.5: for stack instances</td></tr><tr><td>0.9.2</td><td>2007-Feb-16</td><td>Replace ASCII art in §3.1.3 with diagram</td></tr><tr><td>0.9.3</td><td>2007-Feb-16</td><td>Minor cleanup in §3.1</td></tr><tr><td>0.9.4</td><td>2007-Feb-16</td><td>Minor tweaks to §s4.1 &amp; 5.1</td></tr><tr><td>1.0</td><td>2007-Feb-16</td><td>Link to CLIs page from §7.1, Design Complete</td></tr><tr><td>1.0.1</td><td>2007-Feb-28</td><td>Fix a number of minor issues noticed by David Bustos</td></tr><tr><td>1.0.2</td><td>2007-Mar-01</td><td>More minor issues noticed by David Bustos</td></tr><tr><td>1.0.3</td><td>2007-Mar-02</td><td>Minor issues in §5</td></tr><tr><td>1.0.4</td><td>2007-Mar-05</td><td>Updates due to issues noticed by David Bustos, §6.14, §8.1.2, §8.2</td></tr><tr><td>1.0.5</td><td>2007-Mar-05</td><td>Updates due to issues noticed by David Bustos, §2.3.3.1, §4.1.3</td></tr><tr><td>1.0.6</td><td>2007-Jun-07</td><td>Add §4.3.4, Environment Extensibility</td></tr></table>
</div>


    <div class="clearfloats"></div>
  </div>      <div id="xdocFooter">
  
                

       <div class="doc-tags" id="xdocTags">
        Tags:
        </div>
  
  <div id="xdocAuthors">
    <div class="xdocCreation">       Created by Administrator on 2009/10/26 12:15<br/>
          </div>
    <div class="xdocLastModification">       Last modified by Renee Sommerfeld on 2009/11/19 01:33
    </div>
  </div>
</div>
<div id="xwikidata" class="layoutsubsection">
        </div>  
    </div>      </div><div id="leftPanels" class="panels left">
                  <div class="panel expanded OSNav">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSNav');">Collectives</h1>
<div class="xwikipanelcontents">
<div id="xwikinavcontainer">
<span class="wikilink"><a href="/bin/view/Main/communities">Community Groups</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/projects">Projects</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/usergroups">User Groups</a></span>
</div><p/>
<script type="text/javascript">
document.observe('xwiki:dom:loaded', function() {
var obj = {div:'xwikinav',no:$count,height:250};
var acc = createAccordion(obj);
});
</script>
</div>
</div>
                        <div class="panel expanded OSDocs">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSDocs');">Project nwam Pages</h1>
<div class="xwikipanelcontents">
<ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Foundation">Foundation</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+nwam/1%2DStoryBoards">Story Boards</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/2%2DRequirements">Requirements</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/3%2DArchitecture">Architecture</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/4%2DDesign">Design</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Phase0">Phase 0</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+nwam/llp">Interface Configuration Policy</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/prototype">Prototype</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Phase0%2D5">Phase 0.5</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Phase1EA">Phase 1 Early Access</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Phase1Repo">Phase 1 Repository</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Phase1Spec">Phase 1 Spec</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Contents">TOC</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/DraftManPages">Draft Man Pages</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Glossary">Glossary</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/UIDesign">Phase 1 GUI Design</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Phase1">GUI Spec</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/usertasks_config">User Tasks for NWAM Configuration</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/usertasks_status">User Tasks for NWAM Status Notification</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/UIResearch">GUI Research & Futures</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+nwam/ConfigUI">UI Spec &#45; Phase 2</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Sketches">UI Sketches/Prototypes</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/stateoftheart">State of the Art</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/terminology">Terminology Study: Location vs. Environment</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/userexperience">User Scenarios</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/service%2Ddiscovery">Service Discovery</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+nwam/Applications">Applications</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/mdnsd_man">mdnsd(1M)</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+nwam/nsswitch_dns">nsswitch.dns</a></span></li>
</ul></li>
</ul>
                              </div>
</div>
      </div>

  </div>
<div class="clearfloats"></div>
  </div></div><div id="footerglobal" class="layoutsection">
<div class="minwidth"></div>
<hr/>
        <div id="xwikiplatformversion">XWiki Enterprise 2.7.1.34853 - <a onclick="openURL('http://enterprise.xwiki.org/xwiki/bin/view/Main/Documentation', '_blank'); return false;" href="http://www.xwiki.org/xwiki/bin/view/Main/Documentation">Documentation</a></div>
<br/>
  
      <div id="footer">
    <p>
                <a href="https://markebrooks.github.io/bin/view/Main/tou/">Terms of Use</a>
                |
                <a href="http://www.oracle.com/html/privacy.html">Privacy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/trademark/">Trademarks</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/copyrights/">Copyright Policy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site_guidelines/">Site Guidelines</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site-map/">Site Map</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/help/">Help</a>
                <br/>Your use of this web site or any of its content or software indicates your agreement to be bound by these Terms of Use.<br/>
                &copy; 2013, Oracle Corporation and/or its affiliates.<br/><img src="https://markebrooks.github.io:443/static/images/logo_oracle_footer.gif" alt="Oracle Logo"/>
            </p>
        </div>

  
</div>

</div></div></body>
</html>
