<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
                    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
                                    <title>CEC 2006 Demo (Community Group dtrace.CEC2006) - XWiki</title>
                <meta http-equiv="Content-Script-Type" content="text/javascript" />
                        <meta http-equiv="imagetoolbar" content="no"/>
                      <link rel="alternate" type="application/x-wiki" title="Edit" href="/bin/edit/Community+Group+dtrace/CEC2006" />
                    <link rel="canonical" href="/bin/view/Community+Group+dtrace/CEC2006" />
                            <meta name="document" content="Community Group dtrace.CEC2006"/>
    <meta name="wiki" content="xwiki"/>
    <meta name="space" content="Community Group dtrace"/>
    <meta name="page" content="CEC2006"/>
    <meta name="version" content="2.1"/>
    <meta name="restURL" content="/rest/wikis/xwiki/spaces/Community+Group+dtrace/pages/CEC2006"/>
                <meta name="gwt:property" content="locale=en" />
                <meta name="revisit-after" content="7 days" />
<meta name="description" content="CEC 2006 Demo" />
<meta name="keywords" content="wiki " />
<meta name="distribution" content="GLOBAL" />
<meta name="rating" content="General" />
<meta name="author" content="Alta Elstad" />
<meta http-equiv="reply-to" content="" />
<meta name="language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="alternate" type="application/rss+xml" title="Wiki Feed RSS" href="/bin/view/Main/WebRss?xpage=rdf" />
<link rel="alternate" type="application/rss+xml" title="Blog RSS Feed" href="/bin/view/Blog/GlobalBlogRss?xpage=plain" />
<link rel="shortcut icon" href="/resources/icons/oso/icon.png">
                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
<link href="https://markebrooks.github.io/static/css/stylesheet.css" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/style.css?colorTheme=ColorThemes.Oso" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/print.css" rel="stylesheet" type="text/css" media="print" />
        <!--[if IE]>
  <link href="/bin/skin/skins/colibri/ie%2Dall.css" rel="stylesheet" type="text/css" />
<![endif]-->
<!--[if IE 6]>
  <link href="/bin/skin/skins/colibri/ie%2D6.css" rel="stylesheet" type="text/css" />
<![endif]-->
<link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Settings?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Style?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/XWiki/SharePage?language=en'/>
<link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/modalPopup.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/jumpToPage.css?language=en'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/confirmationBox.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/notification.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/skins/colibri/resources/uicomponents/viewers/tags.css'/>

    
    <link href="/bin/skin/resources/js/xwiki/suggest/ajaxSuggest.css" rel="stylesheet" type="text/css" />
<link href="/bin/skin/resources/js/xwiki/lightbox/lightbox.css" rel="stylesheet" type="text/css" />
<!--[if IE]>
  <link href="/bin/skin/resources/js/xwiki/lightbox/lightboxIE.css" rel="stylesheet" type="text/css" />
<![endif]-->












<script type="text/javascript" src="/resources/js/prototype/prototype.js"></script>
<script type="text/javascript" src="/bin/skin/resources/js/xwiki/xwiki.js"></script>
<script type="text/javascript">
// <![CDATA[
XWiki.webapppath = "";
XWiki.servletpath = "bin/";
XWiki.contextPath = "";
XWiki.mainWiki = "xwiki";
XWiki.currentWiki = "xwiki";
XWiki.currentSpace = "Community Group dtrace";
XWiki.currentPage = "CEC2006";
XWiki.editor = "";
XWiki.viewer = "";
XWiki.contextaction = "view";
XWiki.docisnew = false;
XWiki.docsyntax = "xwiki/2.0";
XWiki.blacklistedSpaces = [ "Import","Panels","Scheduler","Stats","XAppClasses","XAppSheets","XAppTemplates","XWiki","WatchCode","WatchSheets","XApp","WatchAdmin","Watch","ColorThemes","AnnotationCode" ];
XWiki.hasEdit = false;
XWiki.hasProgramming = false;
XWiki.hasBackupPackImportRights = false;
window.docviewurl = "/bin/view/Community+Group+dtrace/CEC2006";
window.docediturl = "/bin/edit/Community+Group+dtrace/CEC2006";
window.docsaveurl = "/bin/save/Community+Group+dtrace/CEC2006";
window.docgeturl = "/bin/get/Community+Group+dtrace/CEC2006";
// ]]>
</script>
<script type='text/javascript' src='/bin/skin/resources/js/scriptaculous/effects.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/modalPopup.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/jumpToPage.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmationBox.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmedAjaxRequest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/notification.js' defer='defer'></script>
<script type='text/javascript' src='/resources/uicomponents/widgets/list/xlist.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/suggest/ajaxSuggest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/skins/colibri/resources/uicomponents/viewers/tags.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/scriptaculous/scriptaculous.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/accordion/accordion.js' defer='defer'></script>

<script type='text/javascript' src='/bin/jsx/XWiki/WebDAV?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Settings?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Script?language=en' defer='defer'></script>

<script type="text/javascript" src="/resources/js/xwiki/compatibility.js" defer="defer"></script>

  </head>
  <body id="body" class="wiki-xwiki space-Community_Group_dtrace viewbody hideright">
<div id="xwikimaincontainer">
<div id="xwikimaincontainerinner">

  <div id="menuview">
    <div id="mainmenu" class="layoutsubsection actionmenu">
<strong id="xwikimenutitle" class="hidden">General Actions:</strong>
<div class="rightmenu">
      <div id="tmLogin" class="tmLogin topmenuentry ">
   <a class="tme" href="https://auth.opensolaris.org/login.action?targetUrl=http%3A%2F%2Fmarkebrooks.github.io%2Fbin%2Fview%2FCommunity%2BGroup%2Bdtrace%2FCEC2006"><strong>Log-in</strong></a>
  </div>
  </div>
<div class="leftmenu">
  <div id="tmWiki" class="tmWiki topmenuentry hasIcon">
   <a class="tme" href="/bin/view/Main/"><strong>Wiki</strong></a>
  </div>
  <div id="tmSpace" class="tmSpace topmenuentry dropdownmenuentry  hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Community+Group+dtrace/"><strong>Community Group dtrace</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
                <span class="submenuitem "><a href="/bin/view/Main/SpaceIndex?space=Community+Group+dtrace" id="tmSpaceDocumentIndex" class="tmSpaceDocumentIndex">Document Index</a></span>
    </span></div>

<div id="tmSubSites" class="tmSubSites topmenuentry dropdownmenuentry dropdownnolink hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Subsites</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem hasIcon"><a href="https://cr.opensolaris.org/" id="tmCR" class="tmCR">Code Reviews</a></span>
<span class="submenuitem hasIcon"><a href="http://repo.opensolaris.org/" id="tmRepo" class="tmRepo">SCM Management</a></span>
<span class="submenuitem hasIcon"><a href="http://pkg.opensolaris.org/" id="tmPkg" class="tmPkg">Package Search</a></span>
<span class="submenuitem hasIcon"><a href="http://bugs.opensolaris.org/" id="tmBugs" class="tmBugs">Bugster</a></span>
<span class="submenuitem hasIcon"><a href="http://defect.opensolaris.org/" id="tmDefect" class="tmDefect">Bugzilla</a></span>
<span class="submenuitem hasIcon"><a href="http://test.opensolaris.org/" id="tmTest" class="tmTest">Test Machines</a></span>
<span class="submenuitem hasIcon"><a href="http://planet.opensolaris.org/" id="tmPlanet" class="tmPlanet">Planet</a></span>
<span class="submenuitem hasIcon"><a href="http://mail.opensolaris.org/" id="tmMail" class="tmMail">Mailing Lists</a></span>
<span class="submenuitem hasIcon"><a href="http://poll.opensolaris.org/" id="tmPoll" class="tmPoll">Elections &amp; Polls</a></span>
<span class="submenuitem hasIcon"><a href="http://arc.opensolaris.org/" id="tmArc" class="tmArc">ARC Case Logs</a></span>
<span class="submenuitem hasIcon"><a href="http://jucr.opensolaris.org/" id="tmJucr" class="tmJucr">Source Juicer</a></span>
<span class="submenuitem hasIcon"><a href="http://pkgfactory.opensolaris.org/" id="tmPkgfactory" class="tmPkgfactory">Package Factory</a></span>
<span class="submenuitem hasIcon"><a href="http://auth.opensolaris.org/" id="tmAuth" class="tmAuth">Auth</a></span>
</span></div>

</div>
</div>

  </div>
 <div id="header" class="layoutsection">
<div class="minwidthb"></div>

  <div id="header">
    <table style="width: 100%;">
        <tr>
            <td style="width: 1%;">
                 <a href="https://markebrooks.github.io/bin/view/Main/"><div id="logo"></div></a>  
            </td>
            <td id="logo-text" style="width: 1%;">
                Solaris
            </td>         
            <td style="width: 98%;">
                <table id="loading-indicator">
                    <tr>
                        <td><img src="https://markebrooks.github.io:443/static/images/busy.gif"
                                 alt="Loading" title="Loading"/></td>
                        <td>Loading...</td>
                    </tr>
                </table>
            </td>
            <td style="width: 1%;">
                <table id="iconbar">
                    <tr>
                    <td><a id="collectives-icon" href="https://markebrooks.github.io/bin/view/Main/collectives">
                        Collectives</a></td>
                    <td><a id="discussions-icon" href="https://markebrooks.github.io/bin/view/Main/discussions">
                            Discussions</a></td>
                    <td><a id="documentation-icon" href="https://markebrooks.github.io/bin/view/Main/documentation">
                            Documentation</a></td>
                    <td><a id="download-icon" href="https://markebrooks.github.io/bin/view/Main/downloads">
                            Download</a></td>
                    <td><a id="source-browser-icon" href="http://src.opensolaris.org/source">
                            Source Browser</a></td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</div>

 </div> 
  <div id="globallinks">
    <form action="/bin/view/Main/Search">
      <div class="globalsearch">
        <label class="hidden" for="headerglobalsearchinput">Search</label><input class="globalsearchinput withTip" id="headerglobalsearchinput" type="text" name="text" value="search..." size="15"/><input class="button" type="image" value="Go" alt="Go" src="/resources/icons/xwiki/search.png"/>
      </div>
    </form>
  </div> <div style="float:left;">

                

   <div id="hierarchy">
                              <a href='/bin/view/Community+Group+dtrace/NetworkProvider'>DTrace Network Provider</a> <span class='separator'>&#187;</span> <span class='current'>CEC 2006 Demo</span>
                </div>

</div>
  <span class="glink" id="headerlanguages" style="float:right">
        <a href="/bin/view/Community+Group+dtrace/CEC2006?language=en" class="language-default language-current">en</a>
    </span>


<div class="contenthideright" id="contentcontainer">
<div id="contentcontainerinner">
<div class="leftsidecolumns">
  <div id="contentcolumn"> 
          <div class="main layoutsubsection">
      <div id="contentmenu" class="actionmenu">
    <strong id="xwikicontentmenutitle" class="hidden">Page Actions:</strong>
<div class="rightmenu">
</div>
<div class="leftmenu">
  <div id="tmExport" class="tmExport topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Export</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/export/Community+Group+dtrace/CEC2006?format=pdf&amp;language=en" id="tmExportPdf" class="tmExportPdf">Export as PDF</a></span>
  <span class="submenuitem "><a href="/bin/export/Community+Group+dtrace/CEC2006?format=rtf&amp;language=en" id="tmExportRtf" class="tmExportRtf">Export as RTF</a></span>
  <span class="submenuitem "><a href="/bin/export/Community+Group+dtrace/CEC2006?format=html&amp;language=en" id="tmExportHtml" class="tmExportHtml">Export as HTML</a></span>
    </span></div>

<div id="tmShow" class="tmShow topmenuentry dropdownmenuentry  " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Community+Group+dtrace/CEC2006?viewer=code&amp;language=en"><strong>View</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem "><a href="/bin/view/Community+Group+dtrace/CEC2006?viewer=comments&amp;language=en" id="tmViewComments" class="tmViewComments">Comments</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+dtrace/CEC2006?viewer=attachments&amp;language=en" id="tmViewAttachments" class="tmViewAttachments">Attachments</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+dtrace/CEC2006?viewer=history&amp;language=en" id="tmViewHistory" class="tmViewHistory">History</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+dtrace/CEC2006?viewer=information&amp;language=en" id="tmViewInformation" class="tmViewInformation">Information</a></span>
<span class="submenuitem "><a href="/bin/view/Community+Group+dtrace/CEC2006?viewer=code&amp;language=en" id="tmViewSource" class="tmViewSource">View Source</a></span>
</span></div>

  <div id="tmMoreActions" class="tmMoreActions topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>More actions</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/view/Community+Group+dtrace/CEC2006?xpage=print&amp;language=en" id="tmPrintPreview" class="tmPrintPreview">Print preview</a></span>
          </span></div>
</div>

    </div>
    <div id="mainContentArea">
      








                      
<div id="document-title"><h1>CEC 2006 Demo</h1></div>





              <div id="document-info">
    <div>
          </div>
    <div class="clearfloats"></div>
  </div>

<div id="xwikicontent">
<h1 class='hidden'>CEC 2006 Demo</h1><p>At the CEC 2006 conference in San Francisco, Bryan Cantrill and Brendan Gregg demonstrated a prototype DTrace tcp provider - part of a planned collection of DTrace network providers. The following documents the demonstrations that were performed (expanded a little further, and updated to match provider developments). These are actual screenshots from DTrace (command line output).</p><p>Last Update: 16-Oct-2006</p><ul><li><span class="wikilink"><a href="#HIntro">Intro</a></span></li><li><span class="wikilink"><a href="#HNetworkUtilisation">Network Utilisation</a></span></li><li><span class="wikilink"><a href="#HDTraceScripts28DScripts29">DTrace Scripts (D Scripts)</a></span><ul><li><span class="wikilink"><a href="#HDTT2FNet2Ftcpsnoop">DTT/Net/tcpsnoop</a></span></li><li><span class="wikilink"><a href="#Htcpaccept1.d">tcpaccept1.d</a></span></li><li><span class="wikilink"><a href="#Htcpaccept2.d">tcpaccept2.d</a></span></li><li><span class="wikilink"><a href="#Htcpio1.d">tcpio1.d</a></span></li><li><span class="wikilink"><a href="#Htcpio2.d">tcpio2.d</a></span></li><li><span class="wikilink"><a href="#Htcpio2x.d">tcpio2x.d</a></span></li><li><span class="wikilink"><a href="#HTheProbes">The Probes</a></span></li><li><span class="wikilink"><a href="#HOne-Liners">One-Liners</a></span></li><li><span class="wikilink"><a href="#Htcpbytes1.d">tcpbytes1.d</a></span></li><li><span class="wikilink"><a href="#Hunprepared-TCPbytesize">unprepared - TCP byte size</a></span></li><li><span class="wikilink"><a href="#Htcpbytes2.d">tcpbytes2.d</a></span></li><li><span class="wikilink"><a href="#Htcpnmap.d">tcpnmap.d</a></span></li><li><span class="wikilink"><a href="#Htcpstate.d">tcpstate.d</a></span></li><li><span class="wikilink"><a href="#Htcpconnlat.d">tcpconnlat.d</a></span></li><li><span class="wikilink"><a href="#Htcp1stbyte.d">tcp1stbyte.d</a></span></li></ul></li><li><span class="wikilink"><a href="#HConclusion">Conclusion</a></span></li><li><span class="wikilink"><a href="#HQuestions">Questions</a></span></li></ul><h2 id="HIntro"><span>Intro</span></h2><p>A few weeks ago, a proposed design for a DTrace Network provider was posted <span class="wikilink"><a href="/bin/view/Community+Group+dtrace/NetworkProvider">here</a></span> on OpenSolaris, and then discussed on <span class="wikiexternallink"><a href="http://mail.opensolaris.org/mailman/listinfo/dtrace-discuss">dtrace-discuss</a></span>. This design has been improved from the DTrace discuss feedback and from discoveries made when attempting to implement these providers. Last week we began putting together a prototype tcp provider (based on SDT tracing) to see how these ideas will work. This provider was first demonstrated at the CEC 2006 conference.</p><h2 id="HNetworkUtilisation"><span>Network Utilisation</span></h2><p>Lets begin with the basics. How do we measure network utilisation? That is suprisingly hard given that your network is a key resource, and while CPUs have numerous tools for per-CPU and per-process performance observability - there is little by default in Solaris for per-NIC and per-connection observabality.</p><p>Kstat solves many per-NIC observability questions, as first shown (and shown well) by the SE Toolkit. netstat -i, a Kstat consumer, only throws out packet counts - which have some value, but we really want bytes as well. Among other things, bytes allows us to calculate a per-NIC utilisation metric. <span class="wikiexternallink"><a href="http://www.brendangregg.com/k9toolkit.html#nicstat">nicstat</a></span>, an open source tool available in both Perl and C, does this:</p><pre>
# **./nicstat -i e1000g0 1**
    Time     Int   rKB/s   wKB/s   rPk/s   wPk/s    rAvs    wAvs   **%Util**    Sat
13:46:08 e1000g0   77.43   19.89   59.65   24.26  1329.3   839.7    **0.08**   0.00
13:46:09 e1000g0  1387.7   387.9  1837.2  1337.5   773.4   297.0    **1.45**   0.00
13:46:10 e1000g0  1396.1   350.5  1734.3  1188.5   824.3   302.0    **1.43**   0.00
13:46:11 e1000g0   129.6   42.62   213.2   171.5   622.7   254.5    **0.14**   0.00
13:46:12 e1000g0   196.1   66.27   279.2   219.8   719.1   308.7    **0.21**   0.00
13:46:13 e1000g0   155.7   54.13   240.6   193.1   662.5   287.1    **0.17**   0.00
13:46:14 e1000g0   122.8   58.01   229.7   201.0   547.6   295.6    **0.15**   0.00
^C
</pre><p>Ok, we see some network traffic <span>&nbsp;in this example output. If you have multiple interfaces, nicstat prints a line for each.</span></p><p>nicstat uses Kstat, and such on-going statistics are (and should) be maintained by Kstat. MIB provides similar info for SNMP. So by-NIC observability has a number of solutions, depending on what interests you.</p><p>There aren't many options for by-connection observability. We can capture and examine packets using tools such as snoop, however the overheads of promiscuous tracing can have double digit percentage perfmance costs (depending on the interface and workload). In which case, you won't want to run snoop much in production, and even if you do - the performance impact casts doubt on any derived performance metrics.</p><p>With DTrace we can safely explore the potential of per-connection and per-packet tracing, armed with the rich programming functionality that DTrace provides.</p><h2 id="HDTraceScripts28DScripts29"><span>DTrace Scripts (D Scripts)</span></h2><h3 id="HDTT2FNet2Ftcpsnoop"><span>DTT/Net/tcpsnoop</span></h3><p>&nbsp;The following is tcpsnoop from the <span class="wikilink"><a href="/bin/view/Community+Group+dtrace/dtracetoolkit">DTraceToolkit</a></span>,</p><pre>
# **./tcpsnoop**
  **UID    PID LADDR           LPORT DR RADDR           RPORT  SIZE CMD**
    0    418 192.168.1.185      79 &lt;- 192.168.1.109   55036    54 inetd
    0    418 192.168.1.185      79 -&gt; 192.168.1.109   55036    54 inetd
    0    418 192.168.1.185      79 &lt;- 192.168.1.109   55036    54 inetd
    0   3265 192.168.1.185      79 -&gt; 192.168.1.109   55036   423 in.fingerd
    0   3265 192.168.1.185      79 &lt;- 192.168.1.109   55036    54 in.fingerd
    0   3265 192.168.1.185      79 -&gt; 192.168.1.109   55036    54 in.fingerd
    0   3265 192.168.1.185      79 &lt;- 192.168.1.109   55036    54 in.fingerd
    0   3265 192.168.1.185      79 &lt;- 192.168.1.109   55036    54 in.fingerd
    0   3265 192.168.1.185      79 -&gt; 192.168.1.109   55036    54 in.fingerd
^C
</pre><p>This output shows an inbound finger connection, and shows when the connection was passed from inetd to in.fingerd. This tool was designed to show a line for each ethernet frame, along with IP addresses, TCP ports and process details. tcpsnoop was written by Brendan Gregg in July 2005, after studying the public OpenSolaris code since its release in June 2005. It uses the DTrace fbt provider (function boundary tracing), which has an unstable interface whose probes and arguments change as the kernel changes; and since it's release, tcpsnoop has indeed needed a few updates to keep up with Solaris 10 updates.</p><p>So, since DTrace exists (Dec 2004), and the fbt provider exists, and OpenSolaris provides public code access (June 2005) -- customers already have all the components needed to solve such observability needs, should they have the skills and time to do it and patience to get it right. tcpsnoop is an example of this - and it is a giant observabaility win that this is at all possible.</p><p>However writing tcpsnoop required reading through thousands of lines of kernel TCP/IP C code, something that most customers are unlikely to have the time or skills to do (especially time), nor maintain as the kernel changes. Such network observability is important and should be available to all Solaris users, in a simple and stable manner. This is a key need that the stable networking providers will fulfill.</p><h3 id="Htcpaccept1.d"><span>tcpaccept1.d</span></h3><p>The following is the first demonstration of the prototype tcp provider,</p><pre>
# ./tcpaccept1.d
dtrace: script './tcpaccept1.d' matched 1 probe
^C
192.168.1.107                                         79                1
fe80::214:4fff:fe3b:76c8                              79                1
192.168.1.107                                        513                2
192.168.1.109                                         22                2
192.168.1.109                                         79                3
192.168.1.109                                         80                8
</pre><p>This counts inbound TCP connections ("accepts") by IP address and TCP port number. The output shows 8 connections to port 80 (HTTP) from 192.168.1.109, and 1 connection to port 79 (finger) from fe80::214:4fff:fe3b:76c8 - an IPv6 connection. Great!</p><p>Also great is the source code,</p><pre>
#!/usr/sbin/dtrace -s

tcp:::accept-established {
        @num[args[1]-&gt;ip_saddr, args[2]-&gt;tcp_dport] = count();
}
</pre><p>The tcp:::accept-established probe fires for inbound TCP connections. The values that we aggregated on are:</p><ul><li>args[1]-&gt;ip_saddr - IP address as a string (both IPv4 and IPv6). args[1] is an IP observability structure, and is available for some of the TCP probes (those at the IP interface); it contains addresses, version and payload length. Full and raw IP header details must be fetched from the ip provider.</li><li>args[2]-&gt;tcp_dport - TCP destination port address. args[2] is a structure that contains the TCP header details, including a pointer to the raw structure. As with args[1], args[2] is only available for probes where the TCP header is (and should) be available - such as TCP send and receive.</li></ul><h3 id="Htcpaccept2.d"><span>tcpaccept2.d</span></h3><pre>
# ./tcpaccept2.d 
dtrace: script './tcpaccept2.d' matched 1 probe 
Tracing... Hit Ctrl-C to end.
^C
   HOSTNAME                   PORT        COUNT
   marlin6                    finger          1
   bass                       login           2
   marlin                     ssh             2
   marlin                     telnet          2
   marlin                     finger          3
</pre><p>Fantastic! Rather than print out IP addresses and port numbers, tcpaccept2.d prints out hostnames and service names. This was achieved by adding new format operators to the DTrace printf and printa functions, as can be seen in the below source of tcpaccept2.d.</p><pre>
#!/usr/sbin/dtrace -qs

dtrace:::BEGIN
{
        printf("Tracing... Hit Ctrl-C to end.\n");
}

tcp:::accept-established
{
        @num[args[1]-&gt;ip_saddr, args[2]-&gt;tcp_dport] = count();
}

dtrace:::END
{
        printf("   %-26s %-8s %8s\n", "HOSTNAME", "PORT", "COUNT");
        printa("   %-26I %-8P %@8d\n", @num);
}
</pre><p>The %I will lookup and print a hostname, and %P a service name. This is an observability feature should it be desired - some people may prefer to keep the IP addresses and port numbers as they were.</p><h3 id="Htcpio1.d"><span>tcpio1.d</span></h3><pre>
# ./tcpio1.d
dtrace: script './tcpio1.d' matched 5 probes
CPU     ID                    FUNCTION:NAME
  0  47016            tcp_rput_data:receive   192.168.1.109:53816  -&gt;    192.168.1.185:23
  0  46929               tcp_send_data:send   192.168.1.185:23     -&gt;    192.168.1.109:53816
  0  47017         tcp_conn_request:receive   192.168.1.109:37879  -&gt;    192.168.1.185:79
  0  46929               tcp_send_data:send   192.168.1.185:79     -&gt;    192.168.1.109:37879
  0  47016            tcp_rput_data:receive   192.168.1.109:37879  -&gt;    192.168.1.185:79
  0  47016            tcp_rput_data:receive   192.168.1.109:37879  -&gt;    192.168.1.185:79
  0  46929               tcp_send_data:send   192.168.1.185:79     -&gt;    192.168.1.109:37879
  0  46929               tcp_send_data:send   192.168.1.185:79     -&gt;    192.168.1.109:37879
  0  47016            tcp_rput_data:receive   192.168.1.109:37879  -&gt;    192.168.1.185:79
  0  46929               tcp_send_data:send   192.168.1.185:79     -&gt;    192.168.1.109:37879
  0  47016            tcp_rput_data:receive   192.168.1.109:37879  -&gt;    192.168.1.185:79
  0  47016            tcp_rput_data:receive   192.168.1.109:37879  -&gt;    192.168.1.185:79
  0  46929               tcp_send_data:send   192.168.1.185:79     -&gt;    192.168.1.109:37879
^C
</pre><p>The above output shows the tcpio1.d script snooping an inbound finger connection. By examining the IP addresses and direction of packets, we can see where the initial TCP SYN/SYN-ACK/ACK 3-way handshake would be. The output is fairly raw, it contains the DTrace default fields - this demonstration is more about the source of the D-script tcpio1.d,</p><pre>
#!/usr/sbin/dtrace -s

tcp:::send,
tcp:::receive
{
        printf("%15s:%-5d  -&gt;  %15s:%-5d",
            args[1]-&gt;ip_saddr, args[2]-&gt;tcp_sport,
            args[1]-&gt;ip_daddr, args[2]-&gt;tcp_dport);
}
</pre><p>&nbsp;This could not get any easier. For TCP send and receive packets, print out the source IP address and source TCP port, and the destination IP address and destination IP port.</p><p>The next demonstration spends a few more lines in our D-script to improve the output.</p><h3 id="Htcpio2.d"><span>tcpio2.d</span></h3><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:79     &lt;-    192.168.1.109:56145      0 (SYN)
   192.168.1.185:79     -&gt;    192.168.1.109:56145      0 (SYN|ACK)
   192.168.1.185:79     &lt;-    192.168.1.109:56145      0 (ACK)
   192.168.1.185:79     &lt;-    192.168.1.109:56145      2 (PUSH|ACK)
   192.168.1.185:79     -&gt;    192.168.1.109:56145      0 (ACK)
   192.168.1.185:79     -&gt;    192.168.1.109:56145    126 (PUSH|ACK)
   192.168.1.185:79     &lt;-    192.168.1.109:56145      0 (ACK)
   192.168.1.185:79     -&gt;    192.168.1.109:56145      0 (FIN|ACK)
   192.168.1.185:79     &lt;-    192.168.1.109:56145      0 (ACK)
   192.168.1.185:79     &lt;-    192.168.1.109:56145      0 (FIN|ACK)
   192.168.1.185:79     -&gt;    192.168.1.109:56145      0 (ACK)
^C
</pre><p>The tcpio2.d script prints headers, TCP payload bytes and TCP flags. Now we can clearly see where the TCP SYN/SYN-ACK/ACK handshake is, right down to the final FINs. Rather than always having the source address on the left and the destination on the right, we now print the local address on the left (LADDR) and the remote address on the right (RADDR); the arrow changes so that we know which direction the packet travelled.</p><p>The script for tcpio2.d did get a little longer, but it is still fairly straightforward,</p><pre>
#!/usr/sbin/dtrace -s

#pragma D option quiet
#pragma D option switchrate=10hz

dtrace:::BEGIN
{
        printf(" %15s:%-5s      %15s:%-5s %6s %s\n",
            "LADDR", "PORT", "RADDR", "PORT", "BYTES", "FLAGS");
}

tcp:::send
{
        this-&gt;length = args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset;
        printf(" %15s:%-5d  -&gt;  %15s:%-5d %6d (",
            args[1]-&gt;ip_saddr, args[2]-&gt;tcp_sport,
            args[1]-&gt;ip_daddr, args[2]-&gt;tcp_dport, this-&gt;length);
}

tcp:::receive
{
        this-&gt;length = args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset;
        printf(" %15s:%-5d  &lt;-  %15s:%-5d %6d (",
            args[1]-&gt;ip_daddr, args[2]-&gt;tcp_dport,
            args[1]-&gt;ip_saddr, args[2]-&gt;tcp_sport, this-&gt;length);
}

tcp:::send,
tcp:::receive
{
        printf("%s", args[2]-&gt;tcp_flags &amp; TH_FIN ? "FIN|" : "");
        printf("%s", args[2]-&gt;tcp_flags &amp; TH_SYN ? "SYN|" : "");
        printf("%s", args[2]-&gt;tcp_flags &amp; TH_RST ? "RST|" : "");
        printf("%s", args[2]-&gt;tcp_flags &amp; TH_PUSH ? "PUSH|" : "");
        printf("%s", args[2]-&gt;tcp_flags &amp; TH_ACK ? "ACK|" : "");
        printf("%s", args[2]-&gt;tcp_flags &amp; TH_URG ? "URG|" : "");
        printf("%s", args[2]-&gt;tcp_flags &amp; TH_ECE ? "ECE|" : "");
        printf("%s", args[2]-&gt;tcp_flags &amp; TH_CWR ? "CWR|" : "");
        printf("%s", args[2]-&gt;tcp_flags == 0 ? "null " : "");
        printf("\b)\n");
}
</pre><p>The last section prints out each of the flags as a string, if they are set. Note that we can directly match args[2]-&gt;tcp_flags using bitwise and with meaningful TCP flag names - TH_FIN, TH_SYN, etc (TH is transport header).</p><p>This also allows us to match TCP traffic with particular flags in a DTrace predicate, so that scripts could identify and measure different TCP events.</p><h3 id="Htcpio2x.d"><span>tcpio2x.d</span></h3><p>Now the tcpio2.d script is made a little wider, so that IPv6 addresses look neat and tidy,</p><pre>
# ./tcpio2x.d
C                     LADDR:PORT                           RADDR:PORT   BYTES FLAGS
0    fe80::214:4fff:fe2a:64:79     &lt;-   fe80::214:4fff:fe3b:76c8:61706      0 (SYN)
0    fe80::214:4fff:fe2a:64:79     -&gt;   fe80::214:4fff:fe3b:76c8:61706      0 (SYN|ACK)
0    fe80::214:4fff:fe2a:64:79     &lt;-   fe80::214:4fff:fe3b:76c8:61706      0 (ACK)
0    fe80::214:4fff:fe2a:64:79     &lt;-   fe80::214:4fff:fe3b:76c8:61706      2 (PUSH|ACK)
0    fe80::214:4fff:fe2a:64:79     -&gt;   fe80::214:4fff:fe3b:76c8:61706      0 (ACK)
0    fe80::214:4fff:fe2a:64:79     -&gt;   fe80::214:4fff:fe3b:76c8:61706    126 (PUSH|ACK)
0    fe80::214:4fff:fe2a:64:79     &lt;-   fe80::214:4fff:fe3b:76c8:61706      0 (ACK)
0    fe80::214:4fff:fe2a:64:79     -&gt;   fe80::214:4fff:fe3b:76c8:61706      0 (FIN|ACK)
0    fe80::214:4fff:fe2a:64:79     &lt;-   fe80::214:4fff:fe3b:76c8:61706      0 (ACK)
0    fe80::214:4fff:fe2a:64:79     &lt;-   fe80::214:4fff:fe3b:76c8:61706      0 (FIN|ACK)
0    fe80::214:4fff:fe2a:64:79     -&gt;   fe80::214:4fff:fe3b:76c8:61706      0 (ACK)
^C
</pre><p>Perhaps more exciting is the ability to examine loopback traffic,</p><pre>
# ./tcpio2x.d
C                     LADDR:PORT                           RADDR:PORT   BYTES FLAGS
0                 127.0.0.1:47335  -&gt;                  127.0.0.1:79         0 (SYN)
0                 127.0.0.1:79     &lt;-                  127.0.0.1:47335      0 (SYN)
0                 127.0.0.1:79     -&gt;                  127.0.0.1:47335      0 (SYN|ACK)
0                 127.0.0.1:47335  &lt;-                  127.0.0.1:79         0 (SYN|ACK)
0                 127.0.0.1:47335  -&gt;                  127.0.0.1:79         0 (ACK)
0                 127.0.0.1:79     &lt;-                  127.0.0.1:47335      0 (ACK)
0                 127.0.0.1:79     -&gt;                  127.0.0.1:47335      0 (FIN|ACK)
0                 127.0.0.1:47335  &lt;-                  127.0.0.1:79         0 (FIN|ACK)
0                 127.0.0.1:47335  -&gt;                  127.0.0.1:79         0 (ACK)
0                 127.0.0.1:79     &lt;-                  127.0.0.1:47335      0 (ACK)
0                 127.0.0.1:47335  -&gt;                  127.0.0.1:79         0 (FIN|ACK)
0                 127.0.0.1:79     &lt;-                  127.0.0.1:47335      0 (FIN|ACK)
0                 127.0.0.1:79     -&gt;                  127.0.0.1:47335      0 (ACK)
0                 127.0.0.1:47335  &lt;-                  127.0.0.1:79         0 (ACK)

0                       ::1:51380  -&gt;                        ::1:79         0 (SYN)
0                       ::1:79     &lt;-                        ::1:51380      0 (SYN)
0                       ::1:79     -&gt;                        ::1:51380      0 (SYN|ACK)
0                       ::1:51380  &lt;-                        ::1:79         0 (SYN|ACK)
0                       ::1:51380  -&gt;                        ::1:79         0 (ACK)
0                       ::1:79     &lt;-                        ::1:51380      0 (ACK)
0                       ::1:79     -&gt;                        ::1:51380      0 (FIN|ACK)
0                       ::1:51380  &lt;-                        ::1:79         0 (FIN|ACK)
0                       ::1:51380  -&gt;                        ::1:79         0 (ACK)
0                       ::1:79     &lt;-                        ::1:51380      0 (ACK)
0                       ::1:51380  -&gt;                        ::1:79         0 (FIN|ACK)
0                       ::1:79     &lt;-                        ::1:51380      0 (FIN|ACK)
0                       ::1:79     -&gt;                        ::1:51380      0 (ACK)
0                       ::1:51380  &lt;-                        ::1:79         0 (ACK)
^C
</pre><p>The traffic appears duplicated - this is because the source and destination are on the same host, localhost, and we can trace both the send and the receive of the same packet.</p><p>So far this is sufficient to see which loopback connections are being made, what the destination ports are, and the rate of connections; however note that the BYTES column is always zero. Due to performance reasons, once loopback connections are established their data transfers bypass costly TCP code (the session becomes "fused"), and the regular tcp:::send and tcp:::receive probes don't fire. It is still possible to trace this traffic, and we plan to do so, we just haven't added the probes yet.</p><p>The first column in the previous output is the CPU id. For DTrace reasons, when tracing events as they occur - the output can become shuffled as data is collected from each CPU in turn. So a CPU column is handy to have - if you are on a multi-CPU server, and you are printing events as they occur, and you expect them to appear in the correct order. A different tactic can be to print out a timestamp, and use a tool to post-process and sort the output.</p><h3 id="HTheProbes"><span>The Probes</span></h3><p>So far we have seen probes with intuitive names - accept-established, send, receive. The entire list of probenames so far is as follows,</p><pre>
# dtrace -lP tcp | awk '{ print $5 }' | sort -u
NAME
accept-established
accept-refused
connect-established
connect-refused
connect-request
receive
send
state-bound
state-close-wait
state-closed
state-closing
state-established
state-fin-wait1
state-fin-wait2
state-idle
state-last-ack
state-listen
state-syn-received
state-syn-sent
state-time-wait
</pre><p>The accept-* probes are high-level events for inbound traffic; connect- probes are similar events for outbound traffic. send and receive are for all TCP traffic, including ACKs and exotic port scans. The state-* probes allow us to trace state changes in tcp by connection.</p><p>This collection of probes opens the door to a huge number of tracing possibilities. More probes have been imagined, however due to concerns for maintainability of the tcp code these may not be implemented. At the very least, send and receive allows all traffic to be examined.</p><h3 id="HOne-Liners"><span>One-Liners</span></h3><p>Another way to appreciate a provider is to see what one-liners are possible. Here is a collection that now work with this prototype tcp provider:</p><pre>
DTrace Network Providers One-Liners
~-----------------------------------

# Watch inbound TCP connections by remote address,
**dtrace -n 'tcp:::accept-established { trace(args[1]-&gt;ip_saddr); }'**

# Inbound TCP connections by remote address summary,
**dtrace -n 'tcp:::accept-established { @addr[args[1]-&gt;ip_saddr] = count(); }'**

# Inbound TCP connections by destination port summary,
**dtrace -n 'tcp:::accept-established { @port[args[2]-&gt;tcp_dport] = count(); }'**

# Outbound TCP connections by destination port summary,
**dtrace -n 'tcp:::connect-established { @port[args[2]-&gt;tcp_dport] = count(); }'**

# Inbound TCP refused connections by destination port summary (port scan?),
**dtrace -n 'tcp:::accept-refused { @port[args[2]-&gt;tcp_dport] = count(); }'**

# Outbound TCP refused connections by destination port summary,
**dtrace -n 'tcp:::connect-refused { @port[args[2]-&gt;tcp_dport] = count(); }'**

# Inbound TCP packets by remote address summary,
**dtrace -n 'tcp:::receive { @addr[args[1]-&gt;ip_saddr] = count(); }'**

# Outbound TCP packets by remote address summary,
**dtrace -n 'tcp:::send { @addr[args[1]-&gt;ip_daddr] = count(); }'**

# Inbound TCP packets by destination port summary,
**dtrace -n 'tcp:::receive { @port[args[2]-&gt;tcp_dport] = count(); }'**

# Outbound TCP packets by destination port summary,
**dtrace -n 'tcp:::send { @port[args[2]-&gt;tcp_dport] = count(); }'**

# sent TCP bytes summary,
**dtrace -n 'tcp:::send { @b = sum(args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset); }'**

# TCP events by type summary,
**dtrace -n 'tcp::: { @event[probename] = count(); }'**
</pre><p>For this short demonstration we won't each one by one - but from the descriptions and code we can get a feeling for what is possible.</p><h3 id="Htcpbytes1.d"><span>tcpbytes1.d</span></h3><p>Back to the scripts. Here we create summaries of by-byte traffic,</p><pre>
# ./tcpbytes1.d
dtrace: script './tcpbytes1.d' matched 5 probes
^C

  192.168.1.107                                        513               87
  fe80::214:4fff:fe3b:76c8                              79              128
  192.168.1.109                                         79              256
  192.168.1.109                                         22             9128
  192.168.1.109                                        514         21380483
</pre><p>The tcpbytes1.d script adds sent and received bytes, by IP address and by destination port. Here we can see that 192.168.1.109 transferred 9128 bytes to port 22 on our server. The source to tcpbytes1.d is as follows,</p><pre>
#!/usr/sbin/dtrace -s

tcp:::receive
{
        @bytes[args[1]-&gt;ip_saddr, args[2]-&gt;tcp_dport] =
            sum(args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset);
}

tcp:::send
{
        @bytes[args[1]-&gt;ip_daddr, args[2]-&gt;tcp_sport] =
            sum(args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset);
}
</pre><p>The bytes are found by adding the payload length from the IP observability info structure (args[1] - which is based on the IP header), and then subtracting the TCP header length (args[2]-&gt;tcp_offset - from the TCP header). Both these values return a byte count for convienence, whereas the RFCs specify that these would be the number of 32-bit words (of course, the raw TCP header will be made available if people want it; args[2] provides a endian-correct processed form for convienence).</p><h3 id="Hunprepared-TCPbytesize"><span>unprepared - TCP byte size</span></h3><p>About this point in the demonstration, someone in the audience asked Brendan if the size in bytes of the TCP I/O could be quantized. Yes - that's a great idea! Brendan ran the following while Bryan generated some test traffic,</p><pre>
# dtrace -n 'tcp:::send { @q = quantize(args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset); }'
^C

           value  ~------------- Distribution ~------------- count
              -1 |                                         0
               0 |@@@@@                                    227
               1 |@                                        24
               2 |                                         4
               4 |                                         0
               8 |                                         1
              16 |                                         1
              32 |                                         6
              64 |                                         1
             128 |                                         0
             256 |                                         2
             512 |                                         2
            1024 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@       1501
            2048 |                                         0
</pre><p>To start with, lets feed the byte size into a single quantize. We'll do sent traffic, adding a receive probe as well would be no problem. The above one-liner does quantizes by byte size, and we can see that our TCP traffic is in the 0 byte to 2047 byte range (which we can assume is bounded by MTU). There is a large spike in the 1024 to 2047 byte bucket, which sounds like a data transfer from someone..</p><p>By adding keys to our aggregate, we can find out who the IP addresses are that are receiving bytes from us, and what port they are receiving from,</p><pre>
# dtrace -n 'tcp:::send { @q[args[1]-&gt;ip_daddr, args[2]-&gt;tcp_sport] =
     quantize(args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset); }'
dtrace: description 'tcp:::send ' matched 2 probes
^C

  192.168.1.107                                         79
           value  ~------------- Distribution ~------------- count
              -1 |                                         0
               0 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         4
               1 |                                         0
               2 |                                         0
               4 |                                         0
               8 |                                         0
              16 |                                         0
              32 |                                         0
              64 |                                         0
             128 |@@@@@@@@                                 1
             256 |                                         0

  192.168.1.109                                         22
           value  ~------------- Distribution ~------------- count
              -1 |                                         0
               0 |@@                                       5
               1 |                                         0
               2 |                                         0
               4 |                                         0
               8 |                                         0
              16 |                                         1
              32 |@@@@@@@@@@@@@@@@@                        38
              64 |@@@@@@@@@@@@@@@@@                        37
             128 |                                         1
             256 |@@                                       4
             512 |                                         1
            1024 |                                         0

  192.168.1.109                                        514
           value  ~------------- Distribution ~------------- count
              -1 |                                         0
               0 |                                         5
               1 |                                         2
               2 |                                         1
               4 |                                         0
               8 |                                         0
              16 |                                         1
              32 |                                         1
              64 |                                         0
             128 |                                         0
             256 |                                         0
             512 |                                         0
            1024 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 1499
            2048 |                                         0
</pre><p>Superb! This immediatly shows that our spike of large packets (this time 1499 packets in the 1024 to 2047 byte bucket) belongs to 192.168.1.109 connecting to port 514. Port 22 (ssh) from the same host is responsible for some medium sized traffic - mostly 32 to 128 bytes in size; and most of the TCP traffic to port 79 wil zero sized (ACKs).</p><p>Now if only we could remember who 192.168.1.109 was, and what port 514 was for...</p><pre>
# dtrace -qn 'tcp:::send { @q[args[1]-&gt;ip_daddr, args[2]-&gt;tcp_sport] = 
    quantize(args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset); } END { printa("   %-32I %21P %@d", @q); }'
^C
   marlin                                           shell
           value  ~------------- Distribution ~------------- count
              -1 |                                         0
               0 |                                         5
               1 |                                         3
               2 |                                         1
               4 |                                         0
               8 |                                         0
              16 |                                         1
              32 |                                         1
              64 |                                         0
             128 |                                         0
             256 |                                         0
             512 |                                         0
            1024 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 1499
            2048 |                                         0
</pre><p>We are now using the enhanced printf format characters to fetch the hostname and service name - so it was marlin connecting to our shell port, probably doing an rcp. (We need to run DTrace on marlin to check).</p><h3 id="Htcpbytes2.d"><span>tcpbytes2.d</span></h3><p>Back to the scripts we brought to the demonstration; this one is tcpbytes2.d,</p><pre>
# ./tcpbytes2.d

   HOST                                      BYTES/s
   192.168.1.109                            21210735

   HOST                                      BYTES/s
   192.168.1.109                            16511328

   HOST                                      BYTES/s
   192.168.1.109                            26249638

   HOST                                      BYTES/s
   192.168.1.107                                  54

   HOST                                      BYTES/s
   192.168.1.109                                 418

   HOST                                      BYTES/s
   fe80::214:4fff:fe3b:76c8                      209

   HOST                                      BYTES/s
^C
</pre><p>Per second, tcpbytes2.d prints a report of TCP payload byte transfers by IP address. In the output we can see that 192.168.1.109 began transferring at around 20 Mbytes/sec. The source was,</p><pre>
#!/usr/sbin/dtrace -s

#pragma D option quiet

tcp:::receive
{
        @bytes[args[1]-&gt;ip_saddr, args[2]-&gt;tcp_dport] =
            sum(args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset);
}

tcp:::send
{
        @bytes[args[1]-&gt;ip_daddr, args[2]-&gt;tcp_sport] =
            sum(args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset);
}

profile:::tick-1sec
{
        printf("\n   %-32s %16s\n", "HOST", "BYTES/s");
        printa("   %-32s %@16d\n", @bytes);
        trunc(@bytes);
}
</pre><p>This can be customised as desired, and provides a quick summary of who is transferring data to our host.</p><h3 id="Htcpnmap.d"><span>tcpnmap.d</span></h3><p>Since the tcp provider allows us to easily match on TCP flags - it will be possible to write numerous tools that use this capability to look for certain packets. Here is a demonstration that is more about the D-script that it is about practicality. Long term defense against port scans includes the installation of NIDS (Network Intrusion Detection Systems); for example, snort.</p><p>The <span class="wikiexternallink"><a href="http://insecure.org/nmap/index.html">nmap</a></span> port scanner is a popular and powerful security tool for host vulnerability and remote identification analysis. By using flags, various exotic scans can be performed, including Xmas and null scans. The tcpnmap.d tool examines these flags to find traffic that is <em>possible</em> scan evets - however (as with the connect() scan) they may also be normal traffic. The differentiator (left to the user) is the volume of these suspicious events.</p><pre>
# ./tcpnmap.d
Tracing for possible nmap scans... Hit Ctrl-C to end.
^C
Possible scan events,

   TYPE                     HOST                            COUNT
   TCP_null_scan            192.168.1.109                     208
   TCP_Xmas_scan            192.168.1.109                     304
   TCP_connect()_scan       192.168.1.109                     388
</pre><p>Here all our scan types had counts of more than 100, which (for this 10 second sample), is evidence of scanning.</p><p>The tcpnmap.d script was,</p><pre>
#!/usr/sbin/dtrace -s

#pragma D option quiet

dtrace:::BEGIN
{
        printf("Tracing for possible nmap scans... Hit Ctrl-C to end.\n");
}

tcp:::accept-refused
{
        @num["TCP_connect()_scan", args[1]-&gt;ip_daddr] = count();
}

tcp:::receive
/args[2]-&gt;tcp_flags == 0/
{
        @num["TCP_null_scan", args[1]-&gt;ip_saddr] = count();
}

tcp:::receive
/args[2]-&gt;tcp_flags == (TH_URG|TH_PUSH|TH_FIN)/
{
        @num["TCP_Xmas_scan", args[1]-&gt;ip_saddr] = count();
}

dtrace:::END
{
        printf("Possible scan events,\n\n");
        printf("   %-24s %-28s %8s\n", "TYPE", "HOST", "COUNT");
        printa("   %-24s %-28s %@8d\n", @num);
}
</pre><p>Null and Xmas scans were identified by matching on the TCP flags. Connect scans were matched simply by examining accept-refused events - an inbound SYN to a closed port. This means that we will see the connect() scans to closed ports, however we will miss them to open ones. Wait! We can in fact measure connect() scans to open ports by checking if accept-established events were immediatly closed with a RST - which is what nmap does. In fact, I just verified it by using the tcpio2.d script! Hey - this is really cool - sorry, I didn't do this at CEC, but check this out:</p><p><strong>nmap connect() to an open port</strong></p><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:22     &lt;-    192.168.1.109:60631      0 (SYN)
   192.168.1.185:22     -&gt;    192.168.1.109:60631      0 (SYN|ACK)
   192.168.1.185:22     &lt;-    192.168.1.109:60631      0 (ACK)
   192.168.1.185:22     &lt;-    192.168.1.109:60631      0 (RST)
</pre><p><strong>nmap connect() to a closed port</strong></p><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:26     &lt;-    192.168.1.109:47113      0 (SYN)
   192.168.1.185:26     -&gt;    192.168.1.109:47113      0 (RST|ACK)
</pre><p><strong>nmap TCP Xmas to an open port</strong></p><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:22     &lt;-    192.168.1.109:43968      0 (FIN|PUSH|URG)
</pre><p><strong>nmap TCP Xmas to a closed port</strong></p><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:26     &lt;-    192.168.1.109:33466      0 (FIN|PUSH|URG)
</pre><p><strong>nmap TCP Null to an open port</strong></p><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:22     &lt;-    192.168.1.109:53034      0 (null)
</pre><p><strong>nmap TCP Null to a closed port</strong></p><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:26     &lt;-    192.168.1.109:61054      0 (null)
</pre><p><strong>nmap TCP Stealth to an open port</strong></p><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:22     &lt;-    192.168.1.109:39438      0 (SYN)
   192.168.1.185:22     -&gt;    192.168.1.109:39438      0 (SYN|ACK)
   192.168.1.185:22     &lt;-    192.168.1.109:39438      0 (RST)
</pre><p><strong>nmap TCP Stealth to a closed port</strong></p><pre>
# ./tcpio2.d
           LADDR:PORT                 RADDR:PORT   BYTES FLAGS
   192.168.1.185:26     &lt;-    192.168.1.109:57433      0 (SYN)
   192.168.1.185:26     -&gt;    192.168.1.109:57433      0 (RST|ACK)
</pre><p>Very, very cool. Bryan commented that this script needs to be used at Universities when teaching TCP - you can probably see why!</p><p>Note that Solaris doesn't respond to null or Xmas scans -- good Solaris! :-)</p><h3 id="Htcpstate.d"><span>tcpstate.d</span></h3><p>A TCP connection changes between well defined states (see RFC 793), which are highly useful to observe. The following script simply prints out when a state has changed, including the previous and the new state,</p><pre>
# ./tcpstate.d
C   PREV                    NEW
0   state-established    -&gt; state-idle
0   state-idle           -&gt; state-bound
0   state-bound          -&gt; state-syn-sent
0   state-syn-sent       -&gt; state-established
0   state-established    -&gt; state-close-wait
0   state-close-wait     -&gt; state-last-ack
0   state-last-ack       -&gt; state-closed
^C
</pre><p>And the script was,</p><pre>
#!/usr/sbin/dtrace -s

#pragma D option quiet

dtrace:::BEGIN
{
        printf("%s   %-20s    %-20s\n", "C", "PREV", "NEW");
}

tcp:::state-bound,
tcp:::state-close-wait,
tcp:::state-closed,
tcp:::state-closing,
tcp:::state-established,
tcp:::state-fin-wait1,
tcp:::state-fin-wait2,
tcp:::state-idle,
tcp:::state-last-ack,
tcp:::state-listen,
tcp:::state-syn-received,
tcp:::state-syn-sent,
tcp:::state-time-wait
{
        printf("%d   %-20s -&gt; %-20s\n", cpu, args[2]-&gt;ts_prevstr, probename);
}
</pre><p>All TCP probes as arg0 provide a connection-ID, similar to a process-ID, so that we can uniquely identify TCP connections. If we can (it may not make sense for all contexts), we will make it available as the variable cid. Apart from the old and new states, these state probes will also provide the cid. They will not, however, provide IP or TCP header information - such as IP addresses or ports - as such header information is not in a stable state when these probes fire. Not a great problem - the cid will allow us to associate IP and TCP header details to the state events, by caching them when they are available.</p><p>About cids: If we had a system with sudden CPU load, and suspected a runaway process, we are of the mentality to go hunting for the PID responsible. What about a server that has network load? We need a similar mechanism to refer to established network connections, so that tools can be written to associate cid data and present it. The kernel already has such a mechanism, the struct conn_s *, and we plan to make the cid be an integer form of that pointer (it's unique, it's valid for the session, and it works for both TCP and UDP). Perhaps years form now we will take for granted a wide range of by-cid tools (powered by DTrace) for network connection observability, just as we currently have a range of by-pid tools (powered by procfs).. (either that or I invent my own filesystem - /connfs ;-) - Brendan)</p><p>These state probes should allow some really amazing scripts to be written - watch this space!</p><h3 id="Htcpconnlat.d"><span>tcpconnlat.d</span></h3><p>The tcp provider gives us the means to measure numerous new and useful latency metrics. To begin with, there is latency incurred for the TCP 3-way handshake to complete for outbound connections. The tcpconnlat.d script measures this.</p><pre>
# ./tcpconnlat.d
dtrace: script './tcpconnlat.d' matched 2 probes
^C

  Connect Latency (ns)                                192.168.1.109
           value  ~------------- Distribution ~------------- count
           65536 |                                         0
          131072 |@@@@@@@@@@@@@@@@@@@@@@@@                 3
          262144 |@@@@@@@@@@@@@@@@                         2
          524288 |                                         0

  Connect Latency (ns)                                72.5.124.61
           value  ~------------- Distribution ~------------- count
         4194304 |                                         0
         8388608 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           3
        16777216 |@@@@@@@@@@                               1
        33554432 |                                         0
</pre><p>192.168.1.109 is a host on the same subnet, 72.5.124.61 is www.sun.com. This measures an outbound SYN to the final ACK in the 3 way handshake. So a nearby host was connecting in less than 0.3 ms, while www.sun.com was connecting in around 10 ms. This latency includes network hop latency, and the time for the remote kernel to create a new TCP session and reply.</p><p>This example is much more interesting than what we could do at the CEC conference, where we only had two laptops and a crossover cable!</p><p>The source for tcpconnlat.d is,</p><pre>
#!/usr/sbin/dtrace -s

tcp:::connect-request
{
        start[arg0] = timestamp;
}

tcp:::connect-established
/start[arg0]/
{
        @latency["Connect Latency (ns)", args[1]-&gt;ip_daddr] =
            quantize(timestamp - start[arg0]);
        start[arg0] = 0;
}
</pre><h3 id="Htcp1stbyte.d"><span>tcp1stbyte.d</span></h3><p>Another useful latency metric is the time from when an outbound connection is established to the when first application data arrives - which we can call "1st byte latency". The tcp1stbyte.d script measures this,</p><pre>
# ./tcp1stbyte.d
dtrace: script './tcp1stbyte.d' matched 4 probes
^C

  1st Byte Latency (ns)                               192.168.1.109
           value  ~------------- Distribution ~------------- count
         8388608 |                                         0
        16777216 |@@@@@@@@@@@@@@@@@@@@@@@@@@@              2
        33554432 |@@@@@@@@@@@@@                            1
        67108864 |                                         0

  1st Byte Latency (ns)                               72.5.124.61
           value  ~------------- Distribution ~------------- count
         8388608 |                                         0
        16777216 |@@@@@@                                   1
        33554432 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@       6
        67108864 |                                         0
</pre><p>This is the time for the first TCP data byte to be received, and includes both network latency and application latency. Now www.sun.com is mostly in the 32 to 64 ms bucket, and these times are much larger. We would usually expect this application latency to be large, as it is the time for the application to be scheduled, read the request, process it and respond - which is likely to be much slower than a streamlined kernel TCP handshake.</p><p>The source for tcp1stbyte.d is,</p><pre>
#!/usr/sbin/dtrace -s

tcp:::connect-established
{
        start[arg0] = timestamp;
}

tcp:::receive
/start[arg0] &amp;&amp; (args[1]-&gt;ip_plength - args[2]-&gt;tcp_offset) &gt; 0/
{
        @latency["1st Byte Latency (ns)", args[1]-&gt;ip_saddr] =
            quantize(timestamp - start[arg0]);
        start[arg0] = 0;
}
</pre><h2 id="HConclusion"><span>Conclusion</span></h2><p>Hopefully these short demonstrations of this prototype tcp provider will help convey what we are trying to achieve. This is by no means a certain addition to Solaris, and there are many challenges ahead, including:</p><ul><li>Extensive testing. Test that every packet is matched correctly, including those with exotic flags.</li><li>Minimising the kernel code changes, and reworking the probes and arguments if needed for maintainability.</li><li>Gaining the support of the kernel engineers and the customers. If enough people (especially customers) want this, it can happen. Let us know on <span class="wikiexternallink"><a href="http://mail.opensolaris.org/mailman/listinfo/dtrace-discuss">dtrace-discuss</a></span>.</li></ul><h2 id="HQuestions"><span>Questions</span></h2><p><strong>Q: Where can I get a BFU archive so I can help by testing this?</strong><br/><strong>A:</strong> We'll put something together and post on DTrace-discuss.</p>
</div>


    <div class="clearfloats"></div>
  </div>      <div id="xdocFooter">
  
                

       <div class="doc-tags" id="xdocTags">
        Tags:
        </div>
  
  <div id="xdocAuthors">
    <div class="xdocCreation">       Created by admin on 2009/10/26 12:07<br/>
          </div>
    <div class="xdocLastModification">       Last modified by Alta Elstad on 2009/10/26 23:38
    </div>
  </div>
</div>
<div id="xwikidata" class="layoutsubsection">
        </div>  
    </div>      </div><div id="leftPanels" class="panels left">
                  <div class="panel expanded OSNav">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSNav');">Collectives</h1>
<div class="xwikipanelcontents">
<div id="xwikinavcontainer">
<span class="wikilink"><a href="/bin/view/Main/communities">Community Groups</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/projects">Projects</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/usergroups">User Groups</a></span>
</div><p/>
<script type="text/javascript">
document.observe('xwiki:dom:loaded', function() {
var obj = {div:'xwikinav',no:$count,height:250};
var acc = createAccordion(obj);
});
</script>
</div>
</div>
                        <div class="panel expanded OSDocs">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSDocs');">Community Group dtrace Pages</h1>
<div class="xwikipanelcontents">
<ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+dtrace/ChangeLog">Change Log</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+dtrace/NetworkProvider">DTrace Network Provider</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Community+Group+dtrace/CEC2006">CEC 2006 Demo</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+dtrace/dexplorer">DExplorer</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+dtrace/dtest">DTrace Test Suite</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+dtrace/dtracetoolkit">DTraceToolkit</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Community+Group+dtrace/shells">Providers for Various Shells</a></span></li>
</ul>
                              </div>
</div>
      </div>

  </div>
<div class="clearfloats"></div>
  </div></div><div id="footerglobal" class="layoutsection">
<div class="minwidth"></div>
<hr/>
        <div id="xwikiplatformversion">XWiki Enterprise 2.7.1.34853 - <a onclick="openURL('http://enterprise.xwiki.org/xwiki/bin/view/Main/Documentation', '_blank'); return false;" href="http://www.xwiki.org/xwiki/bin/view/Main/Documentation">Documentation</a></div>
<br/>
  
      <div id="footer">
    <p>
                <a href="https://markebrooks.github.io/bin/view/Main/tou/">Terms of Use</a>
                |
                <a href="http://www.oracle.com/html/privacy.html">Privacy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/trademark/">Trademarks</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/copyrights/">Copyright Policy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site_guidelines/">Site Guidelines</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site-map/">Site Map</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/help/">Help</a>
                <br/>Your use of this web site or any of its content or software indicates your agreement to be bound by these Terms of Use.<br/>
                &copy; 2013, Oracle Corporation and/or its affiliates.<br/><img src="https://markebrooks.github.io:443/static/images/logo_oracle_footer.gif" alt="Oracle Logo"/>
            </p>
        </div>

  
</div>

</div></div></body>
</html>
