<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
                    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
                                    <title>MEMORANDUM (Project ksh93-integration.memorandum) - XWiki</title>
                <meta http-equiv="Content-Script-Type" content="text/javascript" />
                        <meta http-equiv="imagetoolbar" content="no"/>
                      <link rel="alternate" type="application/x-wiki" title="Edit" href="/bin/edit/Project+ksh93%2Dintegration/memorandum" />
                    <link rel="canonical" href="/bin/view/Project+ksh93%2Dintegration/memorandum" />
                            <meta name="document" content="Project ksh93-integration.memorandum"/>
    <meta name="wiki" content="xwiki"/>
    <meta name="space" content="Project ksh93-integration"/>
    <meta name="page" content="memorandum"/>
    <meta name="version" content="1.1"/>
    <meta name="restURL" content="/rest/wikis/xwiki/spaces/Project+ksh93-integration/pages/memorandum"/>
                <meta name="gwt:property" content="locale=en" />
                <meta name="revisit-after" content="7 days" />
<meta name="description" content="MEMORANDUM" />
<meta name="keywords" content="wiki " />
<meta name="distribution" content="GLOBAL" />
<meta name="rating" content="General" />
<meta name="author" content="admin" />
<meta http-equiv="reply-to" content="" />
<meta name="language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="alternate" type="application/rss+xml" title="Wiki Feed RSS" href="/bin/view/Main/WebRss?xpage=rdf" />
<link rel="alternate" type="application/rss+xml" title="Blog RSS Feed" href="/bin/view/Blog/GlobalBlogRss?xpage=plain" />
<link rel="shortcut icon" href="/resources/icons/oso/icon.png">
                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
<link href="https://markebrooks.github.io/static/css/stylesheet.css" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/style.css?colorTheme=ColorThemes.Oso" rel="stylesheet" type="text/css" media="all" />
<link href="/bin/skin/skins/colibri/print.css" rel="stylesheet" type="text/css" media="print" />
        <!--[if IE]>
  <link href="/bin/skin/skins/colibri/ie%2Dall.css" rel="stylesheet" type="text/css" />
<![endif]-->
<!--[if IE 6]>
  <link href="/bin/skin/skins/colibri/ie%2D6.css" rel="stylesheet" type="text/css" />
<![endif]-->
<link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Settings?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/AnnotationCode/Style?language=en'/><link rel='stylesheet' type='text/css' href='/bin/ssx/XWiki/SharePage?language=en'/>
<link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/modalPopup.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/js/xwiki/widgets/jumpToPage.css?language=en'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/confirmationBox.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/notification.css'/><link rel='stylesheet' type='text/css' href='/bin/skin/resources/uicomponents/widgets/fullScreen.css'/>

    
    <link href="/bin/skin/resources/js/xwiki/suggest/ajaxSuggest.css" rel="stylesheet" type="text/css" />
<link href="/bin/skin/resources/js/xwiki/lightbox/lightbox.css" rel="stylesheet" type="text/css" />
<!--[if IE]>
  <link href="/bin/skin/resources/js/xwiki/lightbox/lightboxIE.css" rel="stylesheet" type="text/css" />
<![endif]-->












<script type="text/javascript" src="/resources/js/prototype/prototype.js"></script>
<script type="text/javascript" src="/bin/skin/resources/js/xwiki/xwiki.js"></script>
<script type="text/javascript">
// <![CDATA[
XWiki.webapppath = "";
XWiki.servletpath = "bin/";
XWiki.contextPath = "";
XWiki.mainWiki = "xwiki";
XWiki.currentWiki = "xwiki";
XWiki.currentSpace = "Project ksh93-integration";
XWiki.currentPage = "memorandum";
XWiki.editor = "";
XWiki.viewer = "";
XWiki.contextaction = "view";
XWiki.docisnew = false;
XWiki.docsyntax = "xwiki/2.0";
XWiki.blacklistedSpaces = [ "Import","Panels","Scheduler","Stats","XAppClasses","XAppSheets","XAppTemplates","XWiki","WatchCode","WatchSheets","XApp","WatchAdmin","Watch","ColorThemes","AnnotationCode" ];
XWiki.hasEdit = false;
XWiki.hasProgramming = false;
XWiki.hasBackupPackImportRights = false;
window.docviewurl = "/bin/view/Project+ksh93%2Dintegration/memorandum";
window.docediturl = "/bin/edit/Project+ksh93%2Dintegration/memorandum";
window.docsaveurl = "/bin/save/Project+ksh93%2Dintegration/memorandum";
window.docgeturl = "/bin/get/Project+ksh93%2Dintegration/memorandum";
// ]]>
</script>
<script type='text/javascript' src='/bin/skin/resources/js/scriptaculous/effects.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/modalPopup.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/js/xwiki/widgets/jumpToPage.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmationBox.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/confirmedAjaxRequest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/notification.js' defer='defer'></script>
<script type='text/javascript' src='/resources/uicomponents/widgets/list/xlist.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/suggest/ajaxSuggest.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/viewers/code.js' defer='defer'></script>
<script type='text/javascript' src='/bin/skin/resources/uicomponents/widgets/fullScreen.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/scriptaculous/scriptaculous.js' defer='defer'></script>
<script type='text/javascript' src='/resources/js/xwiki/accordion/accordion.js' defer='defer'></script>

<script type='text/javascript' src='/bin/jsx/XWiki/WebDAV?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Settings?language=en' defer='defer'></script>
<script type='text/javascript' src='/bin/jsx/AnnotationCode/Script?language=en' defer='defer'></script>

<script type="text/javascript" src="/resources/js/xwiki/compatibility.js" defer="defer"></script>

  </head>
  <body id="body" class="wiki-xwiki space-Project_ksh93-integration viewbody hideright">
<div id="xwikimaincontainer">
<div id="xwikimaincontainerinner">

  <div id="menuview">
    <div id="mainmenu" class="layoutsubsection actionmenu">
<strong id="xwikimenutitle" class="hidden">General Actions:</strong>
<div class="rightmenu">
      <div id="tmLogin" class="tmLogin topmenuentry ">
   <a class="tme" href="https://auth.opensolaris.org/login.action?targetUrl=http%3A%2F%2Fmarkebrooks.github.io%2Fbin%2Fview%2FProject%2Bksh93%252Dintegration%2Fmemorandum%3Fviewer%3Dcode%26%2338%3Blanguage%3Den"><strong>Log-in</strong></a>
  </div>
  </div>
<div class="leftmenu">
  <div id="tmWiki" class="tmWiki topmenuentry hasIcon">
   <a class="tme" href="/bin/view/Main/"><strong>Wiki</strong></a>
  </div>
  <div id="tmSpace" class="tmSpace topmenuentry dropdownmenuentry  hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Project+ksh93%2Dintegration/"><strong>Project ksh93-integration</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
                <span class="submenuitem "><a href="/bin/view/Main/SpaceIndex?space=Project+ksh93%2Dintegration" id="tmSpaceDocumentIndex" class="tmSpaceDocumentIndex">Document Index</a></span>
    </span></div>

<div id="tmSubSites" class="tmSubSites topmenuentry dropdownmenuentry dropdownnolink hasIcon" onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Subsites</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem hasIcon"><a href="https://cr.opensolaris.org/" id="tmCR" class="tmCR">Code Reviews</a></span>
<span class="submenuitem hasIcon"><a href="http://repo.opensolaris.org/" id="tmRepo" class="tmRepo">SCM Management</a></span>
<span class="submenuitem hasIcon"><a href="http://pkg.opensolaris.org/" id="tmPkg" class="tmPkg">Package Search</a></span>
<span class="submenuitem hasIcon"><a href="http://bugs.opensolaris.org/" id="tmBugs" class="tmBugs">Bugster</a></span>
<span class="submenuitem hasIcon"><a href="http://defect.opensolaris.org/" id="tmDefect" class="tmDefect">Bugzilla</a></span>
<span class="submenuitem hasIcon"><a href="http://test.opensolaris.org/" id="tmTest" class="tmTest">Test Machines</a></span>
<span class="submenuitem hasIcon"><a href="http://planet.opensolaris.org/" id="tmPlanet" class="tmPlanet">Planet</a></span>
<span class="submenuitem hasIcon"><a href="http://mail.opensolaris.org/" id="tmMail" class="tmMail">Mailing Lists</a></span>
<span class="submenuitem hasIcon"><a href="http://poll.opensolaris.org/" id="tmPoll" class="tmPoll">Elections &amp; Polls</a></span>
<span class="submenuitem hasIcon"><a href="http://arc.opensolaris.org/" id="tmArc" class="tmArc">ARC Case Logs</a></span>
<span class="submenuitem hasIcon"><a href="http://jucr.opensolaris.org/" id="tmJucr" class="tmJucr">Source Juicer</a></span>
<span class="submenuitem hasIcon"><a href="http://pkgfactory.opensolaris.org/" id="tmPkgfactory" class="tmPkgfactory">Package Factory</a></span>
<span class="submenuitem hasIcon"><a href="http://auth.opensolaris.org/" id="tmAuth" class="tmAuth">Auth</a></span>
</span></div>

</div>
</div>

  </div>
 <div id="header" class="layoutsection">
<div class="minwidthb"></div>

  <div id="header">
    <table style="width: 100%;">
        <tr>
            <td style="width: 1%;">
                 <a href="https://markebrooks.github.io/bin/view/Main/"><div id="logo"></div></a>
            </td>
            <td style="width: 99%;">
                <table id="loading-indicator">
                    <tr>
                        <td><img src="https://markebrooks.github.io:443/static/images/busy.gif"
                                 alt="Loading" title="Loading"/></td>
                        <td>Loading...</td>
                    </tr>
                </table>
            </td>
            <td style="width: 1%;">
                <table id="iconbar">
                    <tr>
                    <td><a id="collectives-icon" href="https://markebrooks.github.io/bin/view/Main/collectives">
                        Collectives</a></td>
                    <td><a id="discussions-icon" href="https://markebrooks.github.io/bin/view/Main/discussions">
                            Discussions</a></td>
                    <td><a id="documentation-icon" href="https://markebrooks.github.io/bin/view/Main/documentation">
                            Documentation</a></td>
                    <td><a id="download-icon" href="https://markebrooks.github.io/bin/view/Main/downloads">
                            Download</a></td>
                    <td><a id="source-browser-icon" href="http://src.opensolaris.org/source">
                            Source Browser</a></td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</div>

 </div> 
  <div id="globallinks">
    <form action="/bin/view/Main/Search">
      <div class="globalsearch">
        <label class="hidden" for="headerglobalsearchinput">Search</label><input class="globalsearchinput withTip" id="headerglobalsearchinput" type="text" name="text" value="search..." size="15"/><input class="button" type="image" value="Go" alt="Go" src="/resources/icons/xwiki/search.png"/>
      </div>
    </form>
  </div> <div style="float:left;">

                

   <div id="hierarchy">
                                                      <a href='/bin/view/Project+ksh93%2Dintegration/docs'>Documentation</a> <span class='separator'>&#187;</span> <a href='/bin/view/Project+ksh93%2Dintegration/ksh93r'>ksh93r docs</a> <span class='separator'>&#187;</span> <a href='/bin/view/Project+ksh93%2Dintegration/general'>General</a> <span class='separator'>&#187;</span> <span class='current'>MEMORANDUM</span>
                            </div>

</div>
  <span class="glink" id="headerlanguages" style="float:right">
        <a href="/bin/view/Project+ksh93%2Dintegration/memorandum?language=en" class="language-default language-current">en</a>
    </span>


<div class="contenthideright" id="contentcontainer">
<div id="contentcontainerinner">
<div class="leftsidecolumns">
  <div id="contentcolumn"> 
        <div class="main layoutsubsection">
      <div id="contentmenu" class="actionmenu">
    <strong id="xwikicontentmenutitle" class="hidden">Page Actions:</strong>
<div class="rightmenu">
</div>
<div class="leftmenu">
  <div id="tmExport" class="tmExport topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>Export</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/export/Project+ksh93%2Dintegration/memorandum?format=pdf&amp;language=en" id="tmExportPdf" class="tmExportPdf">Export as PDF</a></span>
  <span class="submenuitem "><a href="/bin/export/Project+ksh93%2Dintegration/memorandum?format=rtf&amp;language=en" id="tmExportRtf" class="tmExportRtf">Export as RTF</a></span>
  <span class="submenuitem "><a href="/bin/export/Project+ksh93%2Dintegration/memorandum?format=html&amp;language=en" id="tmExportHtml" class="tmExportHtml">Export as HTML</a></span>
    </span></div>

<div id="tmShow" class="tmShow topmenuentry dropdownmenuentry  " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme" href="/bin/view/Project+ksh93%2Dintegration/memorandum?viewer=code&amp;language=en"><strong>View</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
<span class="submenuitem "><a href="/bin/view/Project+ksh93%2Dintegration/memorandum?viewer=comments&amp;language=en" id="tmViewComments" class="tmViewComments">Comments</a></span>
<span class="submenuitem "><a href="/bin/view/Project+ksh93%2Dintegration/memorandum?viewer=attachments&amp;language=en" id="tmViewAttachments" class="tmViewAttachments">Attachments</a></span>
<span class="submenuitem "><a href="/bin/view/Project+ksh93%2Dintegration/memorandum?viewer=history&amp;language=en" id="tmViewHistory" class="tmViewHistory">History</a></span>
<span class="submenuitem "><a href="/bin/view/Project+ksh93%2Dintegration/memorandum?viewer=information&amp;language=en" id="tmViewInformation" class="tmViewInformation">Information</a></span>
<span class="submenuitem "><a href="/bin/view/Project+ksh93%2Dintegration/memorandum?viewer=code&amp;language=en" id="tmViewSource" class="tmViewSource">View Source</a></span>
</span></div>

  <div id="tmMoreActions" class="tmMoreActions topmenuentry dropdownmenuentry dropdownnolink " onmouseover="showsubmenu(this);" onmouseout="hidesubmenu(this);">
<span class="tme-extensible">
   <a class="tme"><strong>More actions</strong></a>
    <span class="hidden menucolon">: </span>
</span><span class="submenu hidden">
  <span class="submenuitem "><a href="/bin/view/Project+ksh93%2Dintegration/memorandum?xpage=print&amp;language=en" id="tmPrintPreview" class="tmPrintPreview">Print preview</a></span>
          <span class="submenuitem "><a href="/bin/view/Project+ksh93%2Dintegration/memorandum?xpage=copy" id="tmActionCopy" class="tmActionCopy">Copy</a></span>
      </span></div>
</div>

    </div>
    <div id="mainContentArea">
      


<div id="document-title"><h1>Wiki source code of <a href="/bin/view/Project+ksh93%2Dintegration/memorandum">MEMORANDUM</a></h1></div>
                <div id="document-info">
    <div>
                      <span id="contentshortcut"><a href="/bin/view/Project+ksh93%2Dintegration/memorandum?viewer=content">Content</a></span>
          </div>
    <div class="clearfloats"></div>
  </div>







<div>
  <a href="/bin/view/Project+ksh93%2Dintegration/memorandum?viewer=code&amp;showlinenumbers=0&amp;language=en" id="toggleLineNumbers">Hide line numbers</a>
                                        <textarea readonly="readonly" class="wiki-code" rows="25" cols="80">
   1: {{{
   2: 
   3:       sIntroduction to ksh-93                       datDecember 21, 1993
   4:        Charge Case 311466-6713
   5:        File Case 61175                              froDavid G. Korn
   6:                                                        MH 11267
   7:                                                        3C-526B x7975
   8:                                                        (research!dgk)
   9: 
  10:                                                        TM
  11: 
  12:                            MEMORANDUM FOR FILE
  13: 
  14:        1.  INTRODUCTION
  15: 
  16:        The term &quot;shell&quot; is used to describe a program that provides
  17:        a command language interface.   Because  the  UNIX*   system
  18:        shell is a user level program, and not part of the operating
  19:        system itself, anyone can write a new  shell  or  modify  an
  20:        existing  one.   This has caused an evolutionary progress in
  21:        the design and implementation of  shells,  with  the  better
  22:        ones  surviving.   The  most  widely  available  UNIX system
  23:        shells are the Bourne shell[7], written by Steve  Bourne  at
  24:        AT&amp;T  Bell Laboratories, the C shell[8], written by Bill Joy
  25:        at the University of California, Berkeley, and the KornShell
  26:        language   [9],   written   by   David  Korn  at  AT&amp;T  Bell
  27:        Laboratories.  The Bourne shell is available on  almost  all
  28:        versions  of the UNIX system.  The C Shell is available with
  29:        all Berkeley Software Distribution (BSD) UNIX systems and on
  30:        many  other systems.  The KornShell is available on System V
  31:        Release 4 systems.  In addition, it  is  available  on  many
  32:        other  systems.   The  source  for the KornShell language is
  33:        available from the AT&amp;T Toolchest,  an  electronic  software
  34:        distribution  system.   It runs on all known versions of the
  35:        UNIX system and on many UNIX system look-alikes.
  36: 
  37:        There have been several articles comparing the  UNIX  system
  38:        shells.    Jason  Levitt[10]  highlights  some  of  the  new
  39:        features  introduced  by  the  KornShell   language.    Rich
  40:        Bilancia[11]  explains  some  of the advantages of using the
  41:        KornShell language.  John Sebes[12] provides a more detailed
  42:        comparison  of  the three shells, both as a command language
  43:        and as a programming language.
  44: 
  45:        The KornShell language is a superset of  the  Bourne  shell.
  46:        The  KornShell  language  has  many  of  the popular C shell
  47:        features, plus additional features of its own.  Its  initial
  48:        popularity  stems  primarily  from  its  improvements  as  a
  49:        command language.  The primary interactive  benefit  of  the
  50: 
  51:        {{{____________________}}}
  52: 
  53:        *  UNIX is a registered trademark of USL
  54: 
  55:        KornShell  command  language is a visual command line editor
  56:        that allows you to make corrections to your current  command
  57:        line  or  to earlier command lines, without having to retype
  58:        them.
  59: 
  60:        However, in  the  long  run,  the  power  of  the  KornShell
  61:        language  as a high-level programming language, as described
  62:        by Dolotta and  Mashey[13],  may  prove  to  be  of  greater
  63:        significance.   ksh-93  provides  the  programming  power of
  64:        several other interpretive languages such as awk, FIT, PERL,
  65:        and  tcl.  An application that was originally written in the
  66:        C  programming  language  was  rewritten  in  the  KornShell
  67:        language.   More  than  20,000 lines of C code were replaced
  68:        with KornShell scripts totaling fewer than  700  lines.   In
  69:        most  instances  there  was  no  perceptible  difference  in
  70:        performance between the two versions of the code.
  71: 
  72:        The KornShell language  has  been  embedded  into  windowing
  73:        systems  allowing  graphical user interfaces to be developed
  74:        in shell rather than having to build applications that  need
  75:        to  be  compiled.  The wksh program[14] provides a method of
  76:        developing OpenLook or Motif applications as ksh scripts.
  77: 
  78:        This memo is an introduction to  ksh-93,  the  program  that
  79:        implements  an  enhanced  version of the KornShell language.
  80:        It is referred to as ksh in the rest of this memo.  The memo
  81:        describes  the  KornShell  language based on the features of
  82:        the 12/28/93 release of ksh.  This memo is not  a  tutorial,
  83:        only  an  introduction.  The second edition of reference [9]
  84:        gives a more complete treatment of the KornShell language.
  85: 
  86:        A concerted effort has been made to achieve  both  System  V
  87:        Bourne  shell  compatibility and IEEE POSIX compatibility so
  88:        that scripts written for either  of  these  shells  can  run
  89:        without modification with ksh.  In addition, ksh-93 attempts
  90:        to be compatible with older versions of ksh.  When there are
  91:        conflicts  between versions of the shell, ksh-93 selects the
  92:        behavior  dictated  by  the  IEEE   POSIX   standard.    The
  93:        description of features in this memo assumes that the reader
  94:        is already familiar with the Bourne shell.
  95: 
  96:        2.  COMMAND LANGUAGE
  97: 
  98:        There is no separate command language.  All features of  the
  99:        language,  except  job  control,  can  be used both within a
 100:        script and interactively from a terminal.  However, features
 101:        that  are  more  likely  to  be  used while running commands
 102:        interactively from a terminal are presented here.
 103: 
 104:        2.1  Setting Options
 105: 
 106:        By convention, UNIX  commands  consist  of  a  command  name
 107:        followed by options and other arguments.  Options are either
 108:        of the form -letter, or -letter value.  In the former  case,
 109:        several  options  may  be  grouped  after  a  single -.  The
 110:        argument ~-- signifies an end to the option list and is  only
 111:        required when the first non-option argument begins with a -.
 112:        Most commands print  an  error  message  which  shows  which
 113:        options  are  permitted  when given incorrect arguments.  In
 114:        addition, the option sequence -?  causes  most  commands  to
 115: 
 116:        print a usage message which lists the valid options.
 117: 
 118:        Ordinarily, ksh executes a command by using the command name
 119:        to locate a program to run and by running the program  as  a
 120:        separate  process.  Some commands, referred to as built-ins,
 121:        are carried out by ksh itself, without creating  a  separate
 122:        process.   The  reasons  that some commands are built-in are
 123:        presented  later.   In  nearly  all  cases  the  distinction
 124:        between  a  command  that is built-in and one that is not is
 125:        invisible to the user.  However, nearly  all  commands  that
 126:        are built-in follow command line conventions.
 127: 
 128:        ksh  has  several  options  that  can  be set by the user as
 129:        command line arguments at invocation and as option arguments
 130:        to  the  set  command.  Most other options can be set with a
 131:        single letter option or  as  a  name  that  follows  the  -o
 132:        option.   Use set -o to display the current option settings.
 133:        Some of these options, such as interactive and monitor  (see
 134:        Job  Control  below),  are enabled automatically by ksh when
 135:        the shell is connected to a terminal device.  Other options,
 136:        such  as  noclobber  and ignoreeof, are normally placed in a
 137:        startup file.  The noclobber option causes ksh to  print  an
 138:        error  message  when  you use &gt; to redirect output to a file
 139:        that already exists.  If you want to redirect to an existing
 140:        file,  then  you  have  to  use &gt;| to override the noclobber
 141:        option.  The ignoreeof option is used to prevent the end-of-
 142:        file  character,  normally ^D (Control- d), from exiting the
 143:        shell and possibly logging you out.  You must type  exit  to
 144:        log  out.  Most of the options are described in this memo as
 145:        appropriate.
 146: 
 147:        2.2  Command Aliases
 148: 
 149:        Command aliases provide a mechanism of associating a command
 150:        name and arguments with a shorter name.  Aliases are defined
 151:        with the alias built-in.   The  form  of  an  alias  command
 152:        definition is:
 153:                              alias name=value
 154:        As  with  most  other shell assignments, no space is allowed
 155:        before or after the =.  The  characters  of  an  alias  name
 156:        cannot  be  characters  that  are special to the shell.  The
 157:        replacement string,  value,  can  contain  any  valid  shell
 158:        script,  including  meta-characters such as pipe symbols and
 159:        i/o-redirection provided that they are quoted.  Unlike  csh,
 160:        aliases  in  ksh  cannot  take  arguments.   The  equivalent
 161:        functionality of aliases with arguments can be achieved with
 162:        shell functions, described later.
 163: 
 164:        As  a  command  is  being  read, the command name is checked
 165:        against a list of alias names.  If it is found, the name  is
 166:        replaced  by  the  alias value associated with the alias and
 167:        then rescanned.  When rescanning the  value  for  an  alias,
 168:        alias  substitutions  are performed except for an alias that
 169:        is currently being processed.  This prevents infinite  loops
 170:        in  alias  substitutions.   For  example  with  the aliases,
 171:        alias l=ls 'ls=ls -C', the command name l becomes ls,  which
 172:        becomes  ls -C.   Ordinarily,  only the command name word is
 173:        processed for alias substitution.  However, if the value  of
 174:        an  alias ends in a space, then the word following the alias
 175:        is also checked  for  alias  substitution.   This  makes  it
 176:        possible to define an alias whose first argument is the name
 177: 
 178:        of a command and have alias substitution performed  on  this
 179:        argument, for example nohup='nohup '.
 180: 
 181:        Aliases  can  be  used to redefine built-in commands so that
 182:        the alias,
 183:                             alias test=./test
 184:        can be used  to  look  for  test  in  your  current  working
 185:        directory  rather  than  using  the  built-in  test command.
 186:        Reserved words such as for and while cannot  be  changed  by
 187:        aliasing.  The command alias, without arguments, generates a
 188:        list of aliases and corresponding alias values.  The unalias
 189:        command removes the name and text of an alias.
 190: 
 191:        Aliases  are  used to save typing and to improve readability
 192:        of scripts.  Several aliases are  predefined  by  ksh.   For
 193:        example, the predefined alias
 194:                         alias integer='typeset -i'
 195:        allows  the  integer  variables  i  and j to be declared and
 196:        initialized with the command
 197:                              integer i=0 j=1
 198: 
 199:        While  aliases  can  be  defined  in  scripts,  it  is   not
 200:        recommended.   The  location  of  an  alias  command  can be
 201:        important since aliases are only processed when a command is
 202:        read.   A  .   procedure (the shell equivalent of an include
 203:        file) is read all at once (unlike start up files  which  are
 204:        read  a command at a time) so that any aliases defined there
 205:        will not effect any commands within this script.  Predefined
 206:        aliases do not have this problem.
 207: 
 208:        2.3  Command Re-entry
 209: 
 210:        When run interactively, ksh saves the commands you type at a
 211:        terminal in a file.  If the variable HISTFILE is set to  the
 212:        name  of a file to which the user has write access, then the
 213:        commands are stored in this  history  file.   Otherwise  the
 214:        file  $HOME/.sh_history  is  checked for write access and if
 215:        this fails an unnamed file  is  used  to  hold  the  history
 216:        lines.    Commands   are   always  appended  to  this  file.
 217:        Instances of ksh that run  concurrently  and  use  the  same
 218:        history  file name, share access to the history file so that
 219:        a command entered in one shell will be available for editing
 220:        in  another  shell.   The  file  may  be  truncated when ksh
 221:        determines that no other shell is using  the  history  file.
 222:        The  number of commands accessible to the user is determined
 223:        by the value of the HISTSIZE variable at the time the  shell
 224:        is  invoked.   The  default  value is 128.  Each command may
 225:        consist of one or more lines since  a  compound  command  is
 226:        considered  one  command.   If  the  character  !  is placed
 227:        within the primary prompt string, PS1, then it  is  replaced
 228:        by the command number each time the prompt is given.
 229: 
 230:        A  built-in  command  named hist is used to list and/or edit
 231:        any of these saved commands.   The  option  -l  is  used  to
 232:        specify  listing  of  previous  commands.   The  command can
 233:        always be specified with a range of one  or  more  commands.
 234:        The  range  can  be  specified by giving the command number,
 235:        relative or absolute, or by giving the  first  character  or
 236:        characters  of  the  command.  When given without specifying
 237:        the range, the last 16 commands are listed, each preceded by
 238:        the command number.
 239: 
 240:        If  the  listing  option  is not selected, then the range of
 241:        commands specified, or the  last  command  if  no  range  is
 242:        given,  is  passed  to  an  editor  program before being re-
 243:        executed by ksh.  The editor to be  used  may  be  specified
 244:        with  the  option  -e and following it with the editor name.
 245:        If this option is not specified,  the  value  of  the  shell
 246:        variable  HISTEDIT  is  used  as  the  name  of  the editor,
 247:        providing that this variable has a non-null value.  If  this
 248:        variable  is  not set, or is null, and the -e option has not
 249:        been selected, then /bin/ed is used.  When editing has  been
 250:        complete,  the  edited  text automatically becomes the input
 251:        for ksh.  As this text is read by ksh, it is echoed onto the
 252:        terminal.
 253: 
 254:        The -s option causes the editing to be bypassed and just re-
 255:        executes the command.  In this case only  a  single  command
 256:        can  be  specified  as the range and an optional argument of
 257:        the form old=new may be added which requests a simple string
 258:        substitution prior to evaluation.  A convenient alias,
 259:                             alias r='hist -s'
 260:        has  been pre-defined so that the single key-stroke r can be
 261:        used to re-execute the previous command and  the  key-stroke
 262:        sequence,  r abc=def c  can  be  used to re-execute the last
 263:        command that  starts  with  the  letter  c  with  the  first
 264:        occurrence  of  the string abc replaced with the string def.
 265:        Typing  r c &gt; file  re-executes  the  most  recent   command
 266:        starting  with the letter c, with standard output redirected
 267:        to file.
 268: 
 269:        2.4  In-line editing
 270: 
 271:        Lines typed from a terminal  frequently  need  changes  made
 272:        before entering them.  With the Bourne shell the only method
 273:        to fix up commands is by backspacing or  killing  the  whole
 274:        line.   ksh offers options that allow the user to edit parts
 275:        of the current command line before submitting  the  command.
 276:        The in-line edit options make the command line into a single
 277:        line screen edit window.  When the command  is  longer  than
 278:        the  width of the terminal, only a portion of the command is
 279:        visible.  Moving within the line  automatically  makes  that
 280:        portion  visible.   Editing  can be performed on this window
 281:        until the return key is pressed.   The  editing  modes  have
 282:        editing  directives  that  access  the history file in which
 283:        previous commands are saved.  A user can  copy  any  of  the
 284:        most  recent HISTSIZE commands from this file into the input
 285:        edit window.  You can locate commands  by  searching  or  by
 286:        position.
 287: 
 288:        The  in-line  editing  options  do  not  use  the termcap or
 289:        terminfo databases.  They work on most  standard  terminals.
 290:        They  only  require  that  the backspace character moves the
 291:        cursor left and the space character overwrites  the  current
 292:        character  on  the screen and moves the cursor to the right.
 293:        Very few terminals or terminal emulators do  not  have  this
 294:        behavior.
 295: 
 296:        There  is  a choice of editor options.  The emacs, gmacs, or
 297:        vi option is selected by turning on the corresponding option
 298:        of  the  set  command.  If the value of the EDITOR or VISUAL
 299:        variables ends with any of these suffixes the  corresponding
 300: 
 301:        option  is  turned  on.   A  large  subset  of each of these
 302:        editors' features is available within the shell.  Additional
 303:        functions,  such  as  file  name  completion, have also been
 304:        added.
 305: 
 306:        In the emacs or gmacs mode the user positions the cursor  to
 307:        the  point  needing  correction  and  inserts,  deletes,  or
 308:        replaces characters as needed.  The only difference  between
 309:        these two modes is the meaning of the directive ^T.  Control
 310:        keys and escape sequences are used  for  cursor  positioning
 311:        and  control functions.  The available editing functions are
 312:        listed in the manual page.
 313: 
 314:        The vi editing mode starts in insert mode and enters control
 315:        mode when the user types ESC ( 033 ).  The return key, which
 316:        submits the current command for processing, can  be  entered
 317:        from  either  mode.  The cursor can be anywhere on the line.
 318:        A  subset  of  commonly  used  vi  editing  directives   are
 319:        available.  The k and j directives that normally move up and
 320:        down by one line, move  up  and  down  one  command  in  the
 321:        history  file,  copying  the  command  into  the  input edit
 322:        window.  For reasons of efficiency, the terminal is kept  in
 323:        canonical  mode  until  an ESC is typed.  On some terminals,
 324:        and on earlier versions of the UNIX operating  system,  this
 325:        doesn't work correctly.  The viraw option, which always uses
 326:        raw or cbreak mode, must be used in this case.
 327: 
 328:        Most of the code for the editing options does  not  rely  on
 329:        the ksh code and can be used in a stand-alone mode with most
 330:        any command to add in-line edit  capability.   However,  all
 331:        versions  of the in-line editors have some features that use
 332:        some shell specific code.  For example, with all edit modes,
 333:        the ESC-= directive applied to command words (the first word
 334:        on the line, or the first word after a ;, |, (, or &amp;)  lists
 335:        all  aliases,  functions, or commands that match the portion
 336:        of the given current word.  When  applied  to  other  words,
 337:        this  directive  prints  the  names  of files that match the
 338:        current word.  The ESC-* directive adds the expanded list of
 339:        matching  files  to the command line.  A trailing * is added
 340:        to the word if it doesn't contain any file pattern  matching
 341:        characters  before  the expansion.  In emacs and gmacs mode,
 342:        ESC-ESC indicates command completion when applied to command
 343:        names,  otherwise  it  indicates  pathname completion.  With
 344:        command or pathname completion, the list  generated  by  the
 345:        ESC-=  directive  is  examined  to  find  the longest common
 346:        prefix.  With command completion, only the last component of
 347:        the  pathname is used to compute the longest command prefix.
 348:        If the longest common prefix is a complete match,  then  the
 349:        word  is  replaced  by  the pathname, and a / is appended if
 350:        pathname is a directory, otherwise a space is added.  In  vi
 351:        mode, \ from control mode gives the same behavior.
 352: 
 353:        2.5  Key Binding
 354: 
 355:        It  is  possible  to  intercept keys as they are entered and
 356:        apply new meanings or  bindings.   A  trap  named  KEYBD  is
 357:        evaluated  each  time  ksh processes characters entered from
 358:        the keyboard, other than those typed while entering a search
 359:        string  or an argument to an edit directive such as r in vi-
 360:        mode.  The action associated with this trap can  change  the
 361:        value  of  the  entered  key  to  cause the key to perform a
 362: 
 363:        different operation.
 364: 
 365:        When the KEYBD trap  is  entered,  the  .sh.edtext  variable
 366:        contains  the  contents  of  the  current input line and the
 367:        .sh.edcol variable gives the current cursor position  within
 368:        this   line.   The  .sh.edmode  variable  contains  the  ESC
 369:        character when the trap is  entered  from  vi  insert  mode.
 370:        Otherwise,  this  value  is  null.   The .sh.edchar variable
 371:        contains the character or escape sequence  that  caused  the
 372:        trap.   A  key  sequence  is  either a single character, ESC
 373:        followed by a single character, or ESC[ followed by a single
 374:        character.   In  the  vi edit mode, the characters after the
 375:        ESC must be entered within half a second after the ESC.  The
 376:        value  of  .sh.edchar at the end of the trap will be used as
 377:        the input sequence.
 378: 
 379:        Using the associative array facility of ksh described later,
 380:        and  the  function  facility  of  ksh, it is easy to write a
 381:        single trap so that keys  can  be  bound  dynamically.   For
 382:        example,
 383: 
 384:             typeset -A Keytable
 385:             trap 'eval &quot;${Keytable[${.sh.edchar}]}&quot;' KEYBD
 386:             function keybind # key action
 387:             {
 388:                     typeset key=$(print -f &quot;%q&quot; &quot;$2&quot;)
 389:                     case $# in
 390:                     2)      Keytable[$1]='.sh.edchar=${.sh.edmode}'&quot;$key&quot;
 391:                             ;;
 392:                     1)      unset Keytable[$1]
 393:                             ;;
 394:                     *)      print -u2 &quot;Usage: $0 key [action]&quot;
 395:                             ;;
 396:                     esac
 397:             }
 398: 
 399:        2.6  Job Control
 400: 
 401:        The job control mechanism is almost identical to the version
 402:        introduced in csh of the  Berkeley  UNIX  operating  system,
 403:        version  4.1  and later.  The job control feature allows the
 404:        user to stop and restart programs, and to move  programs  to
 405:        and  from  the  foreground and the background.  It will only
 406:        work on systems that provide  support  for  these  features.
 407:        However,  even  systems  without  job control have a monitor
 408:        option which, when enabled,  will  report  the  progress  of
 409:        background  jobs  and  enable  the  user to kill jobs by job
 410:        number or job name.
 411: 
 412:        An interactive shell associates a  job  with  each  pipeline
 413:        typed  in  from  the terminal and assigns it a small integer
 414:        number  called  the  job  number.   If  the   job   is   run
 415:        asynchronously,  the  job number is printed at the terminal.
 416:        At any given time, only one job  owns  the  terminal,  i.e.,
 417:        keyboard  signals are only sent to the processes in one job.
 418:        When ksh creates a foreground job, it gives it ownership  of
 419:        the  terminal.  If you are running a job and wish to stop it
 420:        you hit the key ^Z (control-Z) which sends a STOP signal  to
 421:        all  processes  in  the  current  job.   The  shell receives
 422:        notification that the processes have stopped and takes  back
 423: 
 424:        control of the terminal.
 425: 
 426:        There  are  commands  to continue programs in the foreground
 427:        and background.  There are several ways to  refer  to  jobs.
 428:        The  character  %  introduces  a job name.  You can refer to
 429:        jobs by name or number as described in the manual page.  The
 430:        built-in  command  bg  allows  you  to continue a job in the
 431:        background, while the built-in  command  fg  allows  you  to
 432:        continue  a  job  in the foreground even though you may have
 433:        started it in the background.
 434: 
 435:        A job being run in the background will stop if it  tries  to
 436:        read  from  the  terminal.   It  is  also  possible  to stop
 437:        background jobs that try to write on the terminal by setting
 438:        the terminal options appropriately.
 439: 
 440:        There  is  a  built-in command jobs that lists the status of
 441:        all running and stopped jobs.  In addition, you are informed
 442:        of   the  change  of  state  (running  or  stopped)  of  any
 443:        background jobs just before each prompt.  If you want to  be
 444:        notified  about  background  job completions as soon as they
 445:        occur without waiting for a  prompt,  then  use  the  notify
 446:        option.   When  you  try  to  exit  the shell while jobs are
 447:        stopped or running, you will receive a message from ksh.  If
 448:        you  ignore  this message and try to exit again, all stopped
 449:        processes  will  be  terminated.   In  addition,  for  login
 450:        shells,  the  HUP signal will be sent to all background jobs
 451:        unless the job has been disowned with the disown command.
 452: 
 453:        A built-in version of kill makes  it  possible  to  use  job
 454:        numbers  as targets for signals.  Signals can be selected by
 455:        number or name.  The name of the signal is the name found in
 456:        the  include  file /usr/include/sys/signal.h with the prefix
 457:        SIG removed.  The -l option of kill provides a means to  map
 458:        individual  signal  names  to  and  from  signal number.  In
 459:        addition, if no signal name  or  number  is  given,  kill -l
 460:        generates a list of valid signal names.
 461: 
 462:        2.7  Changing Directories
 463: 
 464:        By  default, ksh maintains a logical view of the file system
 465:        hierarchy  which  makes  symbolic  links  transparent.   For
 466:        systems that have symbolic links, this means that if /bin is
 467:        a symbolic link to /usr/bin  and  you  change  directory  to
 468:        /bin,  pwd will indicate that you are in /bin, not /usr/bin.
 469:        pwd -P  generates  the  physical  pathname  of  the  present
 470:        working  directory  by resolving all the symbolic links.  By
 471:        default, the cd command will take you where you expect to go
 472:        even if you cross symbolic links.  A subsequent cd .. in the
 473:        example above will place you in /,  not  /usr.   On  systems
 474:        with   symbolic  links,  cd -P  causes  ..   to  be  treated
 475:        physically.
 476: 
 477:        ksh remembers your last directory in  the  variable  OLDPWD.
 478:        The  cd  built-in  can be given with argument - to return to
 479:        the previous directory and print the name of the  directory.
 480:        Note  that  cd -  done  twice  returns  you  to the starting
 481:        directory, not the second previous directory.   A  directory
 482:        stack  manager  has  been written as shell functions to push
 483:        and pop directories from the stack.
 484: 
 485:        2.8  Prompts
 486: 
 487:        When ksh reads commands from a terminal, it issues a  prompt
 488:        whenever it is ready to accept more input and then waits for
 489:        the user to respond.  The TMOUT variable can be  set  to  be
 490:        the  number  of  seconds  that the shell will wait for input
 491:        before terminating.  A 60 second warning message is  printed
 492:        before terminating.
 493: 
 494:        The  shell uses two prompts.  The primary prompt, defined by
 495:        the value of the PS1 variable, is issued  at  the  start  of
 496:        each command.  The secondary prompt, defined by the value of
 497:        the PS2 variable, is issued when more  input  is  needed  to
 498:        complete a command.
 499: 
 500:        ksh   allows  the  user  to  specify  a  list  of  files  or
 501:        directories to check before issuing  the  PS1  prompt.   The
 502:        variable  MAILPATH  is  a colon ( : ) separated list of file
 503:        names to be checked for changes periodically.  The  user  is
 504:        notified  before the next prompt.  Each of the names in this
 505:        list can be followed by a ?  and a message to be given  when
 506:        a  change has been detected in the file.  The prompt will be
 507:        evaluated for parameter expansion, command substitution  and
 508:        arithmetic   expansion   which  are  described  later.   The
 509:        parameter $_ within a mail message will evaluate to the name
 510:        of  the  file  that has changed.  The parameter MAILCHECK is
 511:        used to specify the minimal interval in seconds  before  new
 512:        mail is checked for.
 513: 
 514:        In  addition  to  replacing  each  !  in the prompt with the
 515:        command number, ksh expands the value of  the  PS1  variable
 516:        for parameter expansions, arithmetic expansions, and command
 517:        substitutions as described below  to  generate  the  prompt.
 518:        The  expansion  characters  that  are to be applied when the
 519:        prompt is issued must be quoted to  prevent  the  expansions
 520:        from  occurring  when  assigning  the  value  to  PS1.   For
 521:        example, PS1=&quot;$PWD&quot; causes PS1 to be set to the value of PWD
 522:        at  the time of the assignment whereas PS1='$PWD' causes PWD
 523:        to be expanded at the time the prompt is issued.
 524: 
 525:        Command substitution  may  require  a  separate  process  to
 526:        execute  and  cause  the prompt display to be somewhat slow,
 527:        especially when the return key is pressed several times in a
 528:        row.   Therefore,  its  use within PS1 is discouraged.  Some
 529:        variables are maintained by ksh so that their values can  be
 530:        used  with PS1.  The PWD variable stores the pathname of the
 531:        current working directory.  The value of SECONDS variable is
 532:        the  value  of  the  most recent assignment plus the elapsed
 533:        time.  By default, the time is  measured  in  milli-seconds,
 534:        but  since  SECONDS is a floating point variable, the number
 535:        of places after the decimal point in the expanded value  can
 536:        be specified with typeset -Fplaces SECONDS.  In a roundabout
 537:        way, this variable can be used to generate a time stamp into
 538:        the  PS1  prompt  without creating a process at each prompt.
 539:        The following code explains how you can do this on System V.
 540:        On  BSD,  you  need  a  different  command to initialize the
 541:        SECONDS variable.
 542: 
 543:             # . this script and use $TIME as part of your PS1 string to
 544:             # get the time of day in your prompt
 545:             typeset -RZ2  _x1 _x2 _x3
 546: 
 547:             (( SECONDS=$(date  '+3600*%H+60*%M+%S') ))
 548:             _s='_x1=(SECONDS/3600)%24,_x2=(SECONDS/60)%60,_x3=SECONDS%60,0'
 549:             TIME='&quot;${_d[_s]}$_x1:$_x2:$_x3&quot;'
 550:             # PS1=${TIME}whatever
 551: 
 552:        2.9  Tilde substitution
 553: 
 554:        The character ~ at the  beginning  of  a  word  has  special
 555:        meaning  to  ksh.   If  the characters after the ~ up to a /
 556:        match a user login name in the password database, then the ~
 557:        and  the  name  are replaced by that user's login directory.
 558:        If no match is found, the original word is unchanged.   A  ~
 559:        by  itself,  or in front of a /, is replaced by the value of
 560:        the HOME parameter.  A ~ followed by a + or - is replaced by
 561:        the value of $PWD or $OLDPWD respectively.
 562: 
 563:        2.10  Output formats
 564: 
 565:        The  output  of  built-in  commands  and  traces have values
 566:        quoted so that they can be  re-input  to  the  shell.   This
 567:        makes it easy to cut and paste shell output on systems which
 568:        use a pointing device such as a mouse.  In addition,  output
 569:        can be saved in a file for reuse.
 570: 
 571:        2.11  The ENV file
 572: 
 573:        When  an  interactive  ksh  starts,  it  evaluates  the $ENV
 574:        variable to arrive at a file name.  If  this  value  is  not
 575:        null, ksh attempts to read and process commands in a file by
 576:        this name.  Earlier versions of ksh read the  ENV  file  for
 577:        all  invocations  of  the  shell primarily to allow function
 578:        definitions to be available for all shell invocations.   The
 579:        function search path, FPATH, described later, eliminated the
 580:        primary need for this capability and it was removed  because
 581:        the high performance cost was no longer deemed acceptable.
 582: 
 583:        3.  PROGRAMMING LANGUAGE
 584: 
 585:        The  KornShell  vastly  extends the set of applications that
 586:        can be implemented efficiently at the shell level.  It  does
 587:        this  by providing simple yet powerful mechanisms to perform
 588:        arithmetic,  pattern  matching,  substring  generation,  and
 589:        arrays.   Users can write applications as separate functions
 590:        that can be defined in the same file  or  in  a  library  of
 591:        functions stored in a directory and loaded on demand.
 592: 
 593:        3.1  String Processing
 594: 
 595:        The  shell  is  primarily  a string processing language.  By
 596:        default, variables hold variable length strings.  There  are
 597:        no  limits  to the length of strings.  Storage management is
 598:        handled by the shell automatically.   Declarations  are  not
 599:        required.  With most programming languages, string constants
 600:        are designated by enclosing characters in single  quotes  or
 601:        double  quotes.  Since most of the words in the language are
 602:        strings, the  shell  requires  quotes  only  when  a  string
 603:        contains characters that are normally processed specially by
 604:        the shell, but their literal meaning is intended.   However,
 605: 
 606:        since  the  shell  is a string processing language, and some
 607:        characters  can  occur   as   literals   and   as   language
 608:        metacharacters,   quoting   is  an  important  part  of  the
 609:        language.
 610: 
 611:        There are four quoting mechanisms in ksh.  The  simplest  is
 612:        to  enclose  a  sequence of characters inside single quotes.
 613:        All characters between a pair of single  quotes  have  their
 614:        literal meaning; the single quote itself cannot appear.  A $
 615:        immediately preceding a single quoted string causes all  the
 616:        characters until the matching single quote to be interpreted
 617:        as  an  ANSI-C  language  string.   Thus,  '\n'   represents
 618:        characters  \  and n, whereas, $'\n' represents the new-line
 619:        character.  Double quoted strings remove the special meaning
 620:        of  all  characters  except  $,  `, and \, so that parameter
 621:        expansion  and  command  substitution  (defined  below)  are
 622:        performed.   The  final mechanism for quoting a character is
 623:        by preceding it with the escape character \.  This mechanism
 624:        works outside of quoted strings and for the characters $, `,
 625:        &quot;, and \ in double quoted strings.
 626: 
 627:        Variables  are  designated  by  one  or  more   strings   of
 628:        alphanumeric   characters   beginning   with  an  alphabetic
 629:        character separated by a ..  Upper and lower case characters
 630:        are  distinct,  so  that  the  variable A and a are names of
 631:        different variables.  There is no limit to the length of the
 632:        name  of  a variable.  You do not have to declare variables.
 633:        You can assign a value to a variable by writing the name  of
 634:        the  variable,  followed  by  an  equal  sign, followed by a
 635:        character string that represents its  value.   To  create  a
 636:        variable  whose  name  contains a ., the variable whose name
 637:        consists of the characters before the last .   must  already
 638:        exist.   You reference a variable by putting the name inside
 639:        curly braces and preceding the braces with  a  dollar  sign.
 640:        The braces may be omitted when the name is alphanumeric.  If
 641:        x and y are two  shell  variables,  then  to  define  a  new
 642:        variable,  z, whose value is the concatenation of the values
 643:        of x and y, you just say z=$x$y.  It is that easy.
 644: 
 645:        The $ can be thought of as meaning &quot;value of.&quot;  You can also
 646:        capture   the  output  of  any  command  with  the  notation
 647:        $(command).  This is referred to  as  command  substitution.
 648:        For  example,  x=$(date)  assigns  the  output from the date
 649:        command to the variable  x.   Command  substitution  in  the
 650:        Bourne  shell  is  denoted  by enclosing the command between
 651:        backquotes,  (``).   This   notation   suffers   from   some
 652:        complicated  quoting  rules.   Thus, it is hard to write sed
 653:        patterns  which  contains  back   slashes   within   command
 654:        substitution.   Putting  the  pattern in single quotes is of
 655:        little  help.   ksh  accepts  the   Bourne   shell   command
 656:        substitution   syntax   for   backward  compatibility.   The
 657:        $(command) notation allows the  command  itself  to  contain
 658:        quoted strings even if the substitution occurs within double
 659:        quotes. Nesting is legal.
 660: 
 661:        The special command substitution of the form $(cat file) can
 662:        be  replaced  by  $(&lt; file), which is faster because the cat
 663:        command doesn't have to run.
 664: 
 665:        3.2  Shell Parameters and Variables
 666: 
 667:        There are three types of parameters  used  by  ksh,  special
 668:        parameters,  positional  parameters,  and  named  parameters
 669:        which are called variables.  ksh defines  the  same  special
 670:        parameters,  0,  *,  @,  #, ?, $, !, and -, as in the Bourne
 671:        shell.
 672: 
 673:        Positional parameters are set when the shell is invoked,  as
 674:        arguments  to  the  set  built-in, and by calls to functions
 675:        (see below) and .  procedures.  They are  named  by  numbers
 676:        starting at 1.
 677: 
 678:        The  third  type  of  parameter is a variable.  As mentioned
 679:        earlier, ksh uses variables whose names consist  of  one  or
 680:        more  alpha-numeric  strings  separated by a ..  There is no
 681:        need to specify the type of a variable in the shell because,
 682:        by  default, variables store strings of arbitrary length and
 683:        values will automatically be converted to numbers when  used
 684:        in  an  arithmetic context.  However, ksh variables can have
 685:        one  or  more   attributes   that   control   the   internal
 686:        representation  of  the  variable,  the  way the variable is
 687:        printed, and its access or scope.  In addition,  ksh  allows
 688:        variables  to  represent  arrays of values and references to
 689:        other  variables.   The  typeset  built-in  command  of  ksh
 690:        assigns  attributes  to  variables.   Two of the attributes,
 691:        readonly and export, are  available  in  the  Bourne  shell.
 692:        Most  of  the  remaining attributes are discussed here.  The
 693:        complete list of attributes  appears  in  the  manual.   The
 694:        unset  built-in  of  ksh  removes  values  and attributes of
 695:        variables.  When a variable  is  exported,  certain  of  its
 696:        attributes are also exported.
 697: 
 698:        Whenever  a  value  is  assigned to a variable, the value is
 699:        transformed according to the  attributes  of  the  variable.
 700:        Changing  the  attribute of a variable can change its value.
 701:        The attributes -L and  -R  are  for  left  and  right  field
 702:        justification  respectively.   They  are useful for aligning
 703:        columns in a report.  For each of these attributes, a  width
 704:        can  be  defined  explicitly or else it is defined the first
 705:        time an assignment is made to the variable.  Each assignment
 706:        causes  justification of the field, truncating if necessary.
 707:        Assignment to fixed sized  variables  provides  one  way  to
 708:        generate  a  substring  consisting  of  a  fixed  number  of
 709:        characters from the beginning or end  of  a  string.   Other
 710:        methods are discussed later.
 711: 
 712:        The  attributes  -u and -l are used for upper case and lower
 713:        case formatting, respectively.  Since it makes no  sense  to
 714:        have both attributes on simultaneously, turning on either of
 715:        these attributes turns the other off.  The following script,
 716:        using  read and print which are described later, provides an
 717:        example of the use of shell variables with attributes.  This
 718:        script  reads a file of lines each consisting of five fields
 719:        separated by : and prints fields 4 and 2 in  upper  case  in
 720:        columns  1-15,  left  justified,  and  columns  20-25 right-
 721:        justified respectively.
 722: 
 723:             typeset -uL15 f4                # 15 character left justified
 724:             typeset -uR6 f2                 # 6 character right justified
 725:             IFS=:                           # set field separator to :
 726:             while   read -r f1 f2 f3 f4 f5  # read line, split into fields
 727: 
 728:             do      print -r ~-- &quot;$f4  $f2&quot;  # print fields 4 and 2
 729:             done
 730: 
 731:        The -i,  -E,  and  -F,  attributes  are  used  to  represent
 732:        numbers.   Each can be followed by a decimal number.  The -i
 733:        attribute causes the value to be represented as  an  integer
 734:        and  it can be followed by a number representing the numeric
 735:        base when expanding its value.  Whenever a value is assigned
 736:        to  an  integer  variable,  it is evaluated as an arithmetic
 737:        expression and then truncated to an integer.
 738: 
 739:        The -E attribute causes  the  value  to  be  represented  in
 740:        scientific  notation  whenever  its  value is expanded.  The
 741:        number following the -E determines the number of significant
 742:        figures,  and  defaults  to  6.  The -F attribute causes the
 743:        value to be represented with a fixed number of places  after
 744:        the  decimal point.  Assignments to variables with the -E or
 745:        -F attributes cause the evaluation of the right hand side of
 746:        the assignment.
 747: 
 748:        ksh  allows  one-dimensional  arrays  in  addition to simple
 749:        variables.  There  are  two  types  of  arrays;  associative
 750:        arrays and indexed arrays.  The subscript for an associative
 751:        array is an arbitrary string, whereas the subscript  for  an
 752:        indexed  array is an arithmetic expression that is evaluated
 753:        to yield an integer  index.   Any  variable  can  become  an
 754:        indexed  array by referring to it with an integer subscript.
 755:        All elements of an array need  not  exist.   Subscripts  for
 756:        arrays  must  evaluate  to  an  integer  between  0 and some
 757:        maximum value, otherwise  an  error  results.   The  maximum
 758:        value  may  vary from one machine to another but is at least
 759:        4095.  Evaluation of subscripts is  described  in  the  next
 760:        section.  Attributes apply to the whole array.
 761: 
 762:        Assignments  to  array  variables  can be made to individual
 763:        elements via parameter assignment commands  or  the  typeset
 764:        built-in.  Additionally, values can be assigned sequentially
 765:        with compound assignment as described below, or  by  the  -A
 766:        name  option of the set command.  Referencing of subscripted
 767:        variables requires the character $, but also requires braces
 768:        around  the  array  element  name.  The braces are needed to
 769:        avoid conflicts with the  file  name  generation  mechanism.
 770:        The form of any array element reference is:
 771:                             ${name[subscript]}
 772:        Subscript  values  of  *  and  @ can be used to generate all
 773:        elements of an array, as they  are  used  for  expansion  of
 774:        positional   parameters.   The  list  of  currently  defined
 775:        subscripts for  a  given  variable  can  be  generated  with
 776:        ${!name[@]}, or ${!name[*]}.
 777: 
 778:        The  -n  or  nameref  attribute  causes  the  variable to be
 779:        treated as a reference to the variable defined by its value.
 780:        Once  this attribute is set, all references to this variable
 781:        become references to the variable named by the value of this
 782:        variable.    For  example,  if  foo=bar,  then  setting  the
 783:        reference  attribute  on  foo  will  cause  all   subsequent
 784:        references  to  foo  to behave as the variable whose name is
 785:        $foo was referenced, which in this case is the variable bar.
 786:        Unsetting  this attribute breaks the association.  Reference
 787:        variables are usually used inside functions whose  arguments
 788: 
 789:        are  the  names of shell variables.  The names for reference
 790:        variables cannot contain a ..  Whenever a shell variable  is
 791:        referenced,  the  portion  of the variable up to the first .
 792:        is checked to see whether it matches the name of a reference
 793:        variable.   If  it  does,  then  the  name  of  the variable
 794:        actually used consists of the concatenation of the  name  of
 795:        the  variable  defined  by  the reference plus the remaining
 796:        portion of the original variable name.  For  example,  using
 797:        the predefined alias, alias nameref='typeset -n',
 798: 
 799:             .bar.home.bam=&quot;hello world&quot;
 800:             nameref foo=.bar.home
 801:             print ${foo.bam}
 802:             hello world
 803: 
 804:        3.3  Compound Assignment
 805: 
 806:        Compound assignments are used to assign values to arrays and
 807:        compound  data  structures.   The  syntax  for  a   compound
 808:        assignment  is name=(assignment-list) where name is the name
 809:        of the variable to which you  want  to  assign  values.   No
 810:        space  is  permitted between the variable name and the = but
 811:        can appear between the = and  the  open  parenthesis.   New-
 812:        lines can appear between the parentheses.
 813: 
 814:        The  assignment-list  can  be  in  several  different  forms
 815:        yielding different results.  If assignment-list is simply  a
 816:        list of words, then the words are processed as they are with
 817:        the for command and  assigned  sequentially  as  an  indexed
 818:        array.  For example,
 819:                                 foo=( * )
 820:        creates  an  indexed array foo and assigns the file names in
 821:        the current directory to each index starting at zero.
 822: 
 823:        The second form for assignment-list is a list of assignments
 824:        of  the  special  form  [word]=word.   No space is permitted
 825:        before or after the =.  In this case, the variable given  by
 826:        name  becomes  an associative array with the given arguments
 827:        as subscripts.  For example,
 828:                      bar=( [color]=red [shape]=box )
 829:        creates an associate array named bar  whose  subscripts  are
 830:        color and shape.
 831: 
 832:        The  third  form  for  assignment-list  is  a list of normal
 833:        assignments,   including   compound   assignments.     These
 834:        assignments cause sub-variables to be assigned corresponding
 835:        to the given assignments.  In addition to  assignments,  the
 836:        assignment-list  can  contain typeset commands.  In addition
 837:        to  creating  sub-variables,  the  effect  of   a   compound
 838:        assignment  is to make the value of the original variable be
 839:        a parenthesized assignment  list  of  its  components.   For
 840:        example, the assignment
 841: 
 842:             foo=(
 843:                     left=bar
 844:                     typeset -i count=3
 845:                     point=(
 846:                             x=50
 847:                             y=60
 848:                     )
 849: 
 850:                     colors=( red green yellow )
 851:                     right=bam
 852:             )
 853: 
 854:        is equivalent to the assignments
 855: 
 856:             foo.left=bar
 857:             foo.count=3
 858:             foo.point.x=50
 859:             foo.point.y=60
 860:             foo.colors=( red green yellow )
 861:             foo.right=bam
 862: 
 863:        In addition, the value of &quot;$foo&quot; is
 864: 
 865:             (
 866:                     colors=( red green yellow )
 867:                     left=bar
 868:                     typeset -i count=3
 869:                     point=(
 870:                             y=60
 871:                             x=50
 872:                     )
 873:                     right=bam
 874:             )
 875: 
 876:        3.4  Substring Generation
 877: 
 878:        The  expansion of a variable or parameter can be modified so
 879:        that only a portion of  the  value  results.   It  is  often
 880:        necessary  to  extract  a  portion  of a shell variable or a
 881:        portion of an array.  There are several parameter  expansion
 882:        operators  that  can  do  this.   One  method  to generate a
 883:        substring   is   with   an    expansion    of    the    form
 884:        ${name:offset:length}   where   offset   is   an  arithmetic
 885:        expression that defines the offset of  the  first  character
 886:        starting from 0, and length is an arithmetic expression that
 887:        defines the length of the substring.  If :length is omitted,
 888:        the  length of the value of name starting at offset is used.
 889:        The :offset:length operators can also be  applied  to  array
 890:        expansions and to parameters * and @ to generate portions of
 891:        an     array.      For     example,      the      expansion,
 892:        ${name[@]:offset:length},  yields  up  to length elements of
 893:        the array name starting at the element offset.
 894: 
 895:        The other parameter expansion modifiers use  shell  patterns
 896:        to  describe portions of the string to modify and delete.  A
 897:        description of shell  patterns  is  contained  below.   When
 898:        these modifiers are applied to special parameters @ and * or
 899:        to  array  parameters  given  as  name[@]  or  name[*],  the
 900:        operation  is  performed  on  each  element.  There are four
 901:        parameter expansion modifiers that  strip  off  leading  and
 902:        trailing  substrings  during parameter expansion by removing
 903:        the characters matching a given pattern.   An  expansion  of
 904:        the form ${name#pattern} causes the smallest matching prefix
 905:        of the value of name to  be  removed.   The  largest  prefix
 906:        matching  pattern  is  removed  by  using  ##  instead of #.
 907:        Similarly, an expansion of the form  ${name%pattern}  causes
 908:        the  smallest  matching  substring  at the end of name to be
 909:        removed.  Again, using %% instead of %, causes  the  largest
 910: 
 911:        matching  trailing substring to be deleted.  For example, if
 912:        the shell variable file has value foo.c, then the expression
 913:        ${file%.c}.o has value foo.o.
 914: 
 915:        The  value  of  an  expansion can be changed by specifying a
 916:        pattern that matches the part that needs to be changed after
 917:        the the parameter expansion modifier /.  An expansion of the
 918:        form ${name/pattern/string}  replaces  the  first  match  of
 919:        pattern  with  the  value  of  variable name to string.  The
 920:        second  /  is  not  necessary  when  string  is  null.   The
 921:        expansion ${name//pattern/string} changes all occurrences of
 922:        the pattern into string.  The parameter expansion  modifiers
 923:        /#  and  /% cause the matching pattern to be anchored to the
 924:        beginning and end respectively.
 925: 
 926:        Finally, there are parameter expansion modifiers that  yield
 927:        the name of the variable, the string length of the value, or
 928:        the number of elements of an  array.   ${!name}  yields  the
 929:        name  of  the variable which will be name itself except when
 930:        name is a reference variable.  In this case  it  will  yield
 931:        the  name  of the variable it refers to.  When applied to an
 932:        array variable, ${!name[@]}  and  ${!name[*]}  generate  the
 933:        names  of  all  subscripts.   ${#name} will be the length in
 934:        bytes of $name.  For an array variable ${#name[*]} gives the
 935:        number of elements in the array.
 936: 
 937:        3.5  Arithmetic Evaluation
 938: 
 939:        For  the  most  part,  the  shell  is  a  string  processing
 940:        language.  However, the need for arithmetic  has  long  been
 941:        obvious.   Many  of  the  characters that are special to the
 942:        Bourne shell are needed as arithmetic  operators.   To  make
 943:        arithmetic  easy  to use, and to maintain compatibility with
 944:        the Bourne shell, ksh uses matching (( and ))  to  delineate
 945:        arithmetic expressions.  While single parentheses might have
 946:        been more desirable, these already  mean  subshell  so  that
 947:        another  notation  was  required.  The arithmetic expression
 948:        inside the  double  parentheses  follows  the  same  syntax,
 949:        associativity  and  precedence as the ANSI-C[15] programming
 950:        language.   The  characters  between  the  matching   double
 951:        parentheses  are  processed  with  the  same  rules used for
 952:        double quotes so that spaces can be used to aid  readability
 953:        without additional quoting.
 954: 
 955:        All   arithmetic  evaluations  are  performed  using  double
 956:        precision  floating  point   arithmetic.    Floating   point
 957:        constants  follow  the  same rules as the ANSI-C programming
 958:        language.  Integer arithmetic constants are written as
 959:                                base#number,
 960:        where base is a decimal integer between two  and  sixty-four
 961:        and  number  is  any  non-negative number.  Base ten is used
 962:        when no base is specified.  The digits  are  represented  by
 963:        the characters 0-9a-zA-Z_@.  For bases less than or equal to
 964:        36,  upper  and  lower   case   characters   can   be   used
 965:        interchangeably to represent the digits from 10 thru 35.
 966: 
 967:        Arithmetic  expressions  are made from constants, variables,
 968:        and operators.  Parentheses may be used for  grouping.   The
 969:        contents  inside  the  double parentheses are processed with
 970:        the same expansions as occurs in a double quoted string,  so
 971:        that all $ expansions are performed before the expression is
 972: 
 973:        evaluated.  However, there is usually no need to use  the  $
 974:        to  get  the  value  of  a  variable  because the arithmetic
 975:        evaluator replaces the name of the  variable  by  its  value
 976:        within  an arithmetic expression.  The $ cannot be used when
 977:        the variable is the subject of assignment  or  an  increment
 978:        operation.   As a rule it is better not to use $ in front of
 979:        variables in an arithmetic expression.
 980: 
 981:        An arithmetic command of the form (( ...  ))  is  a  command
 982:        that  evaluates  the  enclosed  arithmetic  expression.  For
 983:        example, the command
 984:                                 (( x++ ))
 985:        can be used to increment the variable  x,  assuming  that  x
 986:        contains  some  numerical  value.  The arithmetic command is
 987:        true (return value 0), when the resulting expression is non-
 988:        zero,  and  false  (return  value  1)  when  the  expression
 989:        evaluates to zero.  This makes the command easy to use  with
 990:        the if and while compound commands.
 991: 
 992:        The  for  compound  command  has  been  extended  for use in
 993:        arithmetic contexts.  The syntax,
 994:                       for (( expr1; expr2 ; expr3 ))
 995:        can be used as the first line of a for loop  with  the  same
 996:        semantics  as  the  for  statement in the ANSI-C programming
 997:        language.
 998: 
 999:        Arithmetic evaluations can also be performed as part of  the
1000:        evaluation of a command line.  The syntax $(( ... )) expands
1001:        to the value of the enclosed  arithmetic  expression.   This
1002:        expansion   can   occur   wherever  parameter  expansion  is
1003:        performed.   For  example  using  the  ksh   command   print
1004:        (described later)
1005:                               print $((2+2))
1006:        prints the number 4.
1007: 
1008:        The  following  script  prints  the  first  n  lines  of its
1009:        standard input onto its standard  output,  where  n  can  be
1010:        supplied  as an optional argument whose default value is 20.
1011: 
1012:             integer n=${1-20}                       # set n
1013:             while   (( n~-- &gt;=0 )) &amp;&amp; read -r line   # at most n lines
1014:             do      print -r ~-- &quot;$line&quot;
1015:             done
1016: 
1017:        3.6  Shell Expansions
1018: 
1019:        The commands you enter from the terminal or  from  a  script
1020:        are  divided  into  words  and  each  word undergoes several
1021:        expansions to generate the command name and  its  arguments.
1022:        This  is  done  in  two  phases.  The first phase recognizes
1023:        reserved words, spaces and operators to decide where command
1024:        boundaries  lie.  Alias substitutions take place during this
1025:        phase.   The  second  phase  performs  expansions   in   the
1026:        following order:
1027: 
1028:           o Tilde  substitution,  parameter  expansion,  arithmetic
1029:             expansion, and command substitution are performed  from
1030:             left to right.  The option -u or nounset, will cause an
1031:             error to occur when any variable that  is  not  set  is
1032:             expanded.
1033: 
1034:           o The characters that result from parameter expansion and
1035:             command  substitution  above  are  checked   with   the
1036:             characters  in  the  IFS  variable  for  possible field
1037:             splitting.  (See a description of read below to see how
1038:             IFS is used.)  Setting IFS to a null value causes field
1039:             splitting to be skipped.
1040: 
1041:           o Pathname generation (as described below)  is  performed
1042:             on  each of the fields.  Any field that doesn't match a
1043:             pathname is left alone.  The option, -f or  noglob,  is
1044:             used to disable pathname generation.
1045: 
1046:        3.7  Pattern Matching
1047: 
1048:        The shell is primarily a string processing language and uses
1049:        patterns for matching file names as  well  as  for  matching
1050:        strings.  The characters ?, *, and [ are processed specially
1051:        by the shell when not quoted.  These characters are used  to
1052:        form  patterns that match strings.  Patterns are used by the
1053:        shell to match pathnames, to  specify  substrings,  and  for
1054:        case  commands.  The character ?  matches any one character.
1055:        The character  *  matches  zero  or  more  characters.   The
1056:        character  sequence  [...]  defines  a  character class that
1057:        matches any character  contained  within  [].   A  range  of
1058:        characters can be specified by putting a - between the first
1059:        and last character of the range.  An  exclamation  mark,  !,
1060:        immediately  after  the [, means match all characters except
1061:        the  characters  specified.   For   example,   the   pattern
1062:        a?c*.[!a-z]  matches  any  string beginning with an a, whose
1063:        third character is a c, and that ends in .   (dot)  followed
1064:        by  any  character  except the lower case letters, a-z.  The
1065:        sequence [:alpha:] inside a character class, matches any set
1066:        of   characters  in  the  ANSI-C  alpha  class.   Similarly,
1067:        [:class:] matches each of the characters in the given  class
1068:        for   all   the  ANSI-C  character  classes.   For  example,
1069:        [[:alnum:]_] matches  any  alpha-numeric  character  or  the
1070:        character _.
1071: 
1072:        ksh  treats  strings  of  the  form  (pattern-list  ), where
1073:        pattern-list is a list of one or more patterns separated  by
1074:        a  |,  specially  when  preceded  by  *, ?, +, @, or !.  A ?
1075:        preceding  (pattern-list)  means  that  the   pattern   list
1076:        enclosed  in () is optional.  An @(pattern-list) matches any
1077:        pattern  in  the  list  of  patterns  enclosed  in  ().    A
1078:        *(pattern-list)  matches  any  string  that contains zero or
1079:        more of each of the enclosed  patterns,  whereas  +(pattern-
1080:        list)  requires  a  match of one or more of any of the given
1081:        patterns.  For instance, the pattern  +([0-9])?(.)   matches
1082:        one  or  more  digits  optionally  followed  by a .(dot).  A
1083:        !(pattern-list) matches anything except  any  of  the  given
1084:        patterns.  For example, print !(*.o) displays all file names
1085:        in the current directory that do not end in .o.
1086: 
1087:        When patterns are used to generate pathnames when  expanding
1088:        commands  several  other  rules  apply.  A separate match is
1089:        made for each file name component  of  the  pathname.   Read
1090:        permission  is required for any portion of the pathname that
1091:        contains any special pattern character.   Search  permission
1092:        is required for every component except possibly the last.
1093: 
1094:        By  default,  file names in each directory that begin with .
1095:        are skipped when performing a match.  If the pattern  to  be
1096:        matched  starts  with a leading ., then only files beginning
1097:        with a ., are examined when reading each directory  to  find
1098:        matching  files.   If the FIGNORE variable is set, then only
1099:        files that do not match this pattern are  considered.   This
1100:        overrides  the  special  meaning of .  in a pattern and in a
1101:        file name.
1102: 
1103:        If the markdirs option is set, each matching  pathname  that
1104:        is  the name of a directory has a trailing / appended to the
1105:        name.
1106: 
1107:        3.8  Conditional Expressions
1108: 
1109:        The Bourne shell uses the test command, or the equivalent  [
1110:        command, to test files for attributes and to compare strings
1111:        or numbers.  The problem with test is  that  the  shell  has
1112:        expanded  the  words of the test command and split them into
1113:        arguments  before  test  begins  execution.    test   cannot
1114:        distinguish  between  operators and operands.  In most cases
1115:        test &quot;$1&quot;  will  test  whether  argument  1   is   non-null.
1116:        However,  if argument 1 is -f, then test will treat -f as an
1117:        operator and yield a syntax error.  One of the most frequent
1118:        errors  with  test  occurs  when its operands are not within
1119:        double quotes.  In this case, the  argument  may  expand  to
1120:        more  than  a  single argument or to no argument at all.  In
1121:        either case this will likely cause  a  syntax  error.   What
1122:        makes   this   most  insidious  is  that  these  errors  are
1123:        frequently data dependent.  A script  that  appears  to  run
1124:        correctly may abort if given unexpected data.
1125: 
1126:        To get around these problems, ksh has a compound command for
1127:        conditional expression testing as part of the language.  The
1128:        reserved  words  [[ and ]] delimit the range of the command.
1129:        Because they are reserved words,  not  operator  characters,
1130:        they  require  spaces  to separate them from arguments.  The
1131:        words  between  [[  and  ]]  are  not  processed  for  field
1132:        splitting  or  for  pathname generation.  In addition, since
1133:        ksh determines the  operators  before  parameter  expansion,
1134:        expansions  that  yield  no  argument cause no problem.  The
1135:        operators within [[...]] are almost the same  as  those  for
1136:        the  test  command.   All  unary  operators  are of the form
1137:        -letter and are followed by a single operand.  Instead of -a
1138:        and  -o,  [[...]] uses &amp;&amp; and || to indicate &quot;and&quot; and &quot;or&quot;.
1139:        Parentheses are used without quoting for grouping.
1140: 
1141:        The right hand side of the string  comparison  operators  ==
1142:        and  !=  takes  a  pattern  and  tests whether the left hand
1143:        operand matches this pattern.  Quoting the  pattern  results
1144:        is  a  string comparison rather than the pattern match.  The
1145:        operators &lt; and &gt; within [[...]]  designate  lexicographical
1146:        comparison.
1147: 
1148:        In   addition   there   are  several  other  new  comparison
1149:        primitives.  The binary operators -ot and  -nt  compare  the
1150:        modification  times  of two files to see which file is older
1151:        than or newer than the other.  The binary operator -ef tests
1152:        whether  two  files  have the same device and i-node number,
1153:        i. e., a link to the same file.
1154: 
1155:        The unary operator -L returns  true  if  its  operand  is  a
1156:        symbolic  link.   The unary operator -O (-G) returns true if
1157:        the owner (or group) of the file operand matches that of the
1158:        caller.  The unary operator -o returns true when its operand
1159:        is the name of an option that is currently on.
1160: 
1161:        The  following  script  illustrates  some  of  the  uses  of
1162:        [[...]].  The reference manual contains the complete list of
1163:        operators.
1164: 
1165:             for i
1166:             do      # execute foo for numeric directory
1167:                     if      [[ -d $i &amp;&amp; $i == +([0-9]) ]]
1168:                     then    foo
1169:                     # otherwise if writable or executable file and not mine
1170:                     elif    [[ (-w $i||-x $i) &amp;&amp; ! -O $i ]]
1171:                     then    bar
1172:                     fi
1173:             done
1174: 
1175:        3.9  Input and Output
1176: 
1177:        ksh has extended I/O capabilities to enhance the use of  the
1178:        shell  as a programming language.  As with the Bourne shell,
1179:        you use the I/O redirection operator, &lt;,  to  control  where
1180:        input  comes  from,  and the I/O redirection operator, &gt;, to
1181:        control where output goes to.  Each of these  operators  can
1182:        be  preceded  with a single digit that specifies a file unit
1183:        number to associate with the file  stream.   Ordinarily  you
1184:        specify  these  I/O  redirection  operators  with a specific
1185:        command to which it applies.  However, if  you  specify  I/O
1186:        redirections  with  the  exec  command,  and  don't  specify
1187:        arguments to exec, then the I/O redirection applies  to  the
1188:        current  program.   For  example,  the command exec &lt; foobar
1189:        opens file foobar for reading.  The  exec  command  is  also
1190:        used  to  close files.  A file descriptor unit can be opened
1191:        as a copy of an  existing  file  descriptor  unit  by  using
1192:        either  of  the  &lt;&amp;  or  &gt;&amp;  operators  and putting the file
1193:        descriptor unit of the original file  after  the  &amp;.   Thus,
1194:        2&gt;&amp;1 means open standard error (file descriptor 2) as a copy
1195:        of standard output (file descriptor 1).  A  file  descriptor
1196:        value  of  -  after  the &amp; indicates that the file should be
1197:        closed.  To close file unit 5, specify exec 5&lt;&amp;-.  There are
1198:        two  additional redirection operators with ksh and the POSIX
1199:        shell that are  not  part  of  the  Bourne  shell.   The  &gt;|
1200:        operator  overrides  the  effect  of  the  noclobber  option
1201:        described earlier.  The &lt;&gt; operator  causes  a  file  to  be
1202:        opened for both reading and writing.
1203: 
1204:        ksh  recognizes certain pathnames and treats them specially.
1205:        Pathnames of the form /dev/fd/n are treated as equivalent to
1206:        the  file  defined  by file descriptor n.  These name can be
1207:        used as the  script  argument  to  ksh  and  in  conditional
1208:        testing  as  described  above.   On  underlying systems that
1209:        support /dev/fd in the  file  system,  these  names  can  be
1210:        passed   to   other   commands.    Pathnames   of  the  form
1211:        /dev/tcp/hostid/port and /dev/udp/hostid/port can be used to
1212:        create  tcp  and  udp  connections  to services given by the
1213:        hostid number  and  port  number.   The  hostid  cannot  use
1214:        symbolic  values.  In  practice  these numbers are typically
1215: 
1216:        generated   by   command   substitution.     For    example,
1217:        exec 5&gt; /dev/tcp/$(service name)  would open file descriptor
1218:        5 for sending messages to hostid and port number defined  by
1219:        the output of service name.
1220: 
1221:        The  Bourne  shell  has  a built-in command read for reading
1222:        lines from standard input (file descriptor 0) and  splitting
1223:        it into fields based on the value of the IFS variable, and a
1224:        command echo to write strings to standard output.  (On  some
1225:        systems,   echo   is  not  a  built-in  command  and  incurs
1226:        considerable overhead to use.)   Unfortunately,  neither  of
1227:        these  commands  is  able  to perform some very basic tasks.
1228:        For example.  with  the  Bourne  shell,  the  read  built-in
1229:        cannot read a single line that ends in \.  With ksh the read
1230:        built-in has a -r option to remove the special meaning for \
1231:        which  allows it to be treated as a regular character rather
1232:        than the  line  continuation  character.   With  the  Bourne
1233:        shell,  there  is  no  simple way to have more than one file
1234:        open at any time for reading.  ksh has options on  the  read
1235:        command  to  specify the file descriptor for the input.  The
1236:        fields that are read from a  line  can  be  stored  into  an
1237:        indexed  array  with  the  -A option to read.  This allows a
1238:        line to be split into an arbitrary number of fields.
1239: 
1240:        The way the Bourne shell uses  the  IFS  variable  to  split
1241:        lines  into  fields  greatly limits its utility.  Often data
1242:        files consist of lines that use a character  such  as  :  to
1243:        delimit  fields  with  two adjacent delimiters that denote a
1244:        null field.  The Bourne shell treats adjacent delimiters  as
1245:        a  single  field  delimiter.   With ksh, delimiters that are
1246:        considered white space characters have the behavior  of  the
1247:        Bourne  shell,  but  other adjacent delimiters separate null
1248:        fields.
1249: 
1250:        The read command is often used in scripts that interact with
1251:        the  user  by  prompting  the  user and then requesting some
1252:        input.  With the Bourne shell two commands are  needed;  one
1253:        to prompt the user, the other to read the reply.  ksh allows
1254:        these two commands to be combined.  The  first  argument  of
1255:        the read command can be followed by a ?  and a prompt string
1256:        which is used whenever  the  input  device  is  a  terminal.
1257:        Because the prompt is associated with the read built-in, the
1258:        built-in command line editors will be able to re-output  the
1259:        prompt  whenever the line needs to be refreshed when reading
1260:        from a terminal device.
1261: 
1262:        With the Bourne shell, there is no way to set a  time  limit
1263:        for waiting for the user response to read.  The -t option to
1264:        read takes a floating point argument that gives the time  in
1265:        seconds,  or fractions of seconds that the shell should wait
1266:        for a reply.
1267: 
1268:        The version of the echo command in System V  treats  certain
1269:        sequences beginning with \ as control sequences.  This makes
1270:        it hard to output strings without interpretation.  Most  BSD
1271:        derived  systems  do  not  interpret  \  control  sequences.
1272:        Unfortunately, the BSD versions of echo accepts a -n  option
1273:        to  prevent a trailing new-line, but has no way to cause the
1274:        string -n to be  printed.   Neither  of  these  versions  is
1275:        adequate.  Also,  because  they are incompatible, it is very
1276:        hard to write portable shell scripts using  echo.   The  ksh
1277: 
1278:        built-in,  print, outputs characters to the terminal or to a
1279:        file and subsumes the functions of  all  versions  of  echo.
1280:        Ordinarily,  escape  sequences in arguments beginning with \
1281:        are processed the same as for the  System  V  echo  command.
1282:        However  print  follows the standard conventions for options
1283:        and has options that make  print  very  versatile.   The  -r
1284:        option  can  be  used  to  output  the arguments without any
1285:        special meaning.  The -n option can be used here to suppress
1286:        the  trailing new-line that is ordinarily appended.  As with
1287:        read, it is possible to specify the file  descriptor  number
1288:        as  an  option  to  the  command  to  avoid  having  to  use
1289:        redirection operators with each occurrence of the command.
1290: 
1291:        The IEEE POSIX shell and utilities  standard  committee  was
1292:        unable to reconcile the differences between the System V and
1293:        BSD versions of echo.  They introduced a new  command  named
1294:        printf  which  takes  an  ANSI-C format string and a list of
1295:        options and outputs the strings using the ANSI-C  formatting
1296:        rules.   Since  ksh  is POSIX conforming, it accepts printf.
1297:        However, there is a -f options to print that can be used  to
1298:        specify  a  format  string which processes the arguments the
1299:        same way that printf does.
1300: 
1301:        The format processing for print and printf has been extended
1302:        slightly.  There are three additional formatting directives.
1303:        The %b format causes the \ escape sequences to  be  expanded
1304:        as  they  are with the System V echo command.  The %q format
1305:        causes quotes to be placed on the output as required so that
1306:        it  can  be  used as shell input.  Special characters in the
1307:        output of most ksh built-in commands and in the output  from
1308:        an execution trace are quoted in an equivalent fashion.  The
1309:        %P format causes an extended regular expression string to be
1310:        converted  into a shell pattern.  This is useful for writing
1311:        shell applications that have to accept  regular  expressions
1312:        as  input.  Finally, the escape sequence \E which expands to
1313:        the terminal escape character (octal 033) has been added.
1314: 
1315:        The shell is frequently used as a programming  language  for
1316:        interactive  dialogues.  The select statement has been added
1317:        to the language to make it easier to present menu  selection
1318:        alternatives  to  the user and evaluate the reply.  The list
1319:        of alternatives is numbered and  put  in  columns.   A  user
1320:        settable  prompt,  PS3,  is  issued  and  if the answer is a
1321:        number corresponding to one of the alternatives, the  select
1322:        loop  variable is set to this value.  In any case, the REPLY
1323:        variable is used to store the user entered reply.  The shell
1324:        variables  LINES  and COLUMNS are used to control the layout
1325:        of select lists.
1326: 
1327:        3.10  Option Parsing
1328: 
1329:        The getopts built-in command can be used to process  command
1330:        arguments  in  a manner consistent with the way ksh does for
1331:        its own built-in commands.
1332: 
1333:        The getopts built-in allows  users  to  specify  options  as
1334:        separate  arguments  or  to  group  options that do not take
1335:        arguments together.  Options that require arguments  do  not
1336:        require  space  to  separate  them from the option argument.
1337:        The OPTARG variable stores the value of the option  argument
1338:        after finding a variable that takes an argument.  The OPTIND
1339: 
1340:        variable holds the index of the  current  options  argument.
1341:        After processing options, the arguments should be shifted by
1342:        OPTIND-1 to make the remaining arguments be &quot;$@&quot;.
1343: 
1344:        The   getopts   argument   description   allows   additional
1345:        information  to  be specified along with the options that is
1346:        used to generate usage messages for incorrect arguments  and
1347:        for  the  option  argument  -?.  The example in the APPENDIX
1348:        uses getopts to process its arguments.
1349: 
1350:        3.11  Co-process
1351: 
1352:        ksh can spawn a co-process by adding a |&amp; after  a  command.
1353:        This  process  will  be  run with its standard input and its
1354:        standard  output  connected  to  the  shell.   The  built-in
1355:        command  print  with  the  -p  option  will  write  into the
1356:        standard input of this process and the built-in command read
1357:        with  the  -p  option  will  read  from  the  output of this
1358:        process.
1359: 
1360:        In addition, the I/O redirection operators &lt;&amp; and &gt;&amp; can  be
1361:        used to move the input or output pipe of the co-process to a
1362:        numbered file descriptor.  Use exec 3&gt;&amp; p to move the  input
1363:        of  the  co-process  to  file  descriptor 3.  After you have
1364:        connected to file descriptor 3, you can direct the output of
1365:        any command to the co-process by running command &gt;&amp;3.  Also,
1366:        by  moving  the  input  of  the  co-process  to  a  numbered
1367:        descriptor,  it is possible to run a second co-process.  The
1368:        output of both co-processes  will  be  the  file  descriptor
1369:        associated  with  read -p.   You can use exec 4&lt;&amp; p to cause
1370:        the output of these co-processes to go to file descriptor  4
1371:        of the shell.  Once you have moved the pipe to descriptor 4,
1372:        it is possible to connect a  server  to  the  co-process  by
1373:        running  command 4&lt;&amp; p  or to close the co-process pipe with
1374:        exec 4&lt;&amp; -.
1375: 
1376:        3.12  Functions
1377: 
1378:        Function definitions are of the form
1379: 
1380:             function name
1381:             {
1382:                     any shell script
1383:             }
1384: 
1385:        A function whose name contains a .  is called  a  discipline
1386:        function.   The portion of the name after the last .  is the
1387:        name of the discipline.   Discipline  functions  named  get,
1388:        set,  and unset can be assigned to any variable to intercept
1389:        lookups, assignments and unsetting of the  variable  defined
1390:        by  the portion of the name before the last ..  Applications
1391:        can create additional disciplines  for  variables  that  are
1392:        created  as  part of user defined built-ins.  The portion of
1393:        the name before the last .  must refer to  the  name  of  an
1394:        existing  variable.  Thus, if p is a reference to PATH, then
1395:        the function name p.get  and  PATH.get  refer  to  the  same
1396:        function.
1397: 
1398:        The  function  is  invoked  either by specifying name as the
1399:        command name and optionally following it with  arguments  or
1400:        by  using  it  as  an  option  to  the  .  built-in command.
1401: 
1402:        Positional parameters are saved before  each  function  call
1403:        and  restored when completed.  The arguments that follow the
1404:        function  name  on  the  calling  line   become   positional
1405:        parameters  inside the function.  The return built-in can be
1406:        used to cause  the  function  to  return  to  the  statement
1407:        following the point of invocation.
1408: 
1409:        Functions can also be defined with the System V notation,
1410: 
1411:             name ()
1412:             {
1413:                     any shell script
1414:             }
1415: 
1416:        Functions  defined  with  this  syntax cannot be used as the
1417:        first argument to a . procedure.  ksh accepts this  notation
1418:        for  compatibility  only.   There  is  no  need  to use this
1419:        notation when writing ksh scripts.
1420: 
1421:        Functions defined with the function name syntax and  invoked
1422:        by  name  are  executed in the current shell environment and
1423:        can  share  named  variables  with  the   calling   program.
1424:        Options,  other  than execution trace -x, set by the calling
1425:        program are passed down to a function.  The options are  not
1426:        shared  with  the  function so that any options set within a
1427:        function  are  restored  when  the  function  exits.   Traps
1428:        ignored  by  the  caller are ignored within the function and
1429:        cannot be enabled.  Traps caught by the calling program  are
1430:        reset  to their default action within the function.  In most
1431:        instances, the default action is to cause  the  function  to
1432:        terminate.   A  trap  on  EXIT  defined  within  a  function
1433:        executes after the function completes but before the  caller
1434:        resumes.    Therefore,  any  variable  assignments  and  any
1435:        options set as part of a trap action will be effective after
1436:        the caller resumes.
1437: 
1438:        By  default,  variables  are  inherited  by the function and
1439:        shared by  the  calling  program.   However,  for  functions
1440:        defined  with  the  function name syntax that are invoked by
1441:        name, environment substitutions preceding the function  call
1442:        apply  only  to  the  scope  of  the  function  call.  Also,
1443:        variables whose names do not contain a .  that  are  defined
1444:        with  the typeset built-in command are local to the function
1445:        that they are declared in.  Thus, for the function defined
1446: 
1447:             function  name
1448:             {
1449:                  typeset -i x=10
1450:                  let z=x+y
1451:                  print $z
1452:             }
1453: 
1454:        invoked as y=13 name, x  and  y  are  local  variables  with
1455:        respect to the function name while z is global.
1456: 
1457:        Functions  defined  with  the  name()  syntax, and functions
1458:        invoked as an argument to the .  command,  share  everything
1459:        other   than   positional   parameters   with   the  caller.
1460:        Assignments that precede the call remain in effect after the
1461:        function completes.
1462: 
1463:        Alias  and  function  names  are  not  passed  down to shell
1464:        scripts or carried across separate invocations of ksh.   The
1465:        $FPATH  variable gives a colon separated list of directories
1466:        that is searched for function  definitions  when  trying  to
1467:        resolve the command name.  Whenever a file name contained in
1468:        $FPATH is found, the complete file is read and all functions
1469:        contained within become defined.
1470: 
1471:        Calls that reference functions can be recursive.  Except for
1472:        special  built-ins,  function  names  take  precedence  over
1473:        built-in  names  and  names of programs when used as command
1474:        names.  To write a replacement  function  that  invokes  the
1475:        command  that  you  wish to replace, you can use the command
1476:        built-in command.  The arguments to command are the name and
1477:        arguments  of  the program you want to execute.  For example
1478:        to write a cd  function  which  changes  the  directory  and
1479:        prints out the directory name, you can write
1480: 
1481:             function  cd
1482:             {
1483:                  if      command cd  &quot;$@&quot;
1484:                  then    print  -r ~-- $PWD
1485:                  fi
1486:             }
1487: 
1488:        The  FPATH  variable is a colon separated list that ksh uses
1489:        to search for function definitions.  When ksh encounters  an
1490:        autoload  function,  it  runs  the  .  command on the script
1491:        containing the function, and then executes the function.
1492: 
1493:        For interactive shells, function  definitions  may  also  be
1494:        placed  in  the ENV file.  However, this causes the shell to
1495:        take longer to begin executing.
1496: 
1497:        3.13  Process Substitution
1498: 
1499:        This feature is only  available  on  versions  of  the  UNIX
1500:        operating  system  which  support  the /dev/fd directory for
1501:        naming open  files.   Each  command  argument  of  the  form
1502:        &lt;(list)  or  &gt;(list)  will  run  process list asynchronously
1503:        connected to some file in the /dev/fd directory.   The  name
1504:        of  this  file  will become the argument to the command.  If
1505:        the form with &gt; is selected then writing on this  file  will
1506:        provide  input for list.  If &lt; is used, then the file passed
1507:        as an argument will contain the output of the list  process.
1508:        For example,
1509: 
1510:             paste  &lt;(cut -f1 file1)  &lt;(cut -f2 file2) | tee &gt;(process1)  &gt;(process2)
1511: 
1512:        extracts  fields  1  and  3  from  the files file1 and file2
1513:        respectively, places the results side by side, and sends  it
1514:        to  the  processes process1 and process2, as well as putting
1515:        it onto the standard output.  Note that the  file  which  is
1516:        passed  as  an  argument  to  the  command  is a UNIX system
1517:        pipe(2) so that the programs that expect to lseek(2) on  the
1518:        file will not work.
1519: 
1520:        3.14  Finding Commands
1521: 
1522:        The  addition  of aliases, functions, and more built-ins has
1523: 
1524:        made it substantially more difficult to know  what  a  given
1525:        command name really means.
1526: 
1527:        Commands that begin with reserved words are an integral part
1528:        of the  shell  language  itself  and  typically  define  the
1529:        control  flow  of  the language.  Some control flow commands
1530:        are not reserved words  in  the  language  but  are  special
1531:        built-ins.    Special   built-ins  are  built-ins  that  are
1532:        considered a part of the language rather than user definable
1533:        commands.   The  best  examples  of  commands  that fit this
1534:        description are break and continue.  Because  they  are  not
1535:        reserved  words,  they can be the result of shell expansions
1536:        and are not effected by quoting.  These  commands  have  the
1537:        following special properties:
1538: 
1539:           o Assignments  that  precede  them  apply  to the current
1540:             shell process, not just to the given command.
1541: 
1542:           o An error in the format of these commands cause a  shell
1543:             script or function that contains them to abort.
1544: 
1545:           o They cannot be overridden by shell functions.
1546: 
1547:        Other  commands  are  built-in  because  they  perform  side
1548:        effects on the current  environment  that  would  be  nearly
1549:        impossible to implement otherwise.  Built-ins such as cd and
1550:        read are examples of such built-ins.   These  built-ins  are
1551:        semantically  equivalent  to  commands that are not built-in
1552:        except that they don't take a path search to locate.
1553: 
1554:        A third reason to have a command built-in is so that it will
1555:        be  unaffected  by  the  setting  of the PATH variable.  The
1556:        print  command fits this category.  Scripts that  use  print
1557:        will be portable to all sites that run ksh.
1558: 
1559:        The  final  reason for having a command be a built-in is for
1560:        performance.  On most systems it is more than  an  order  of
1561:        magnitude faster to initiate a command that is built-in than
1562:        to create a separate process to run the  command.   Examples
1563:        that fit this category are test and pwd.
1564: 
1565:        Given  a  command  name  ksh decides what it means using the
1566:        following order:
1567: 
1568:           o Reserved words define commands that form  part  of  the
1569:             shell grammar.  They cannot be quoted.
1570: 
1571:           o Alias  substitutions occur first as part of the reading
1572:             of commands.  Using quotes in  the  command  name  will
1573:             prevent alias substitutions.
1574: 
1575:           o Special built-ins.
1576: 
1577:           o Functions.
1578: 
1579:           o Commands that are built-in that are not associated with
1580:             a pathname such as cd and print.
1581: 
1582:           o If the command name contains a /, the program or script
1583:             corresponding to the given name is executed.
1584: 
1585:           o A path search locates the pathname corresponding to the
1586:             command.  If the pathname where it is found matches the
1587:             pathname associated with a built-in command, the built-
1588:             in command is executed.  If  the  directory  where  the
1589:             command  is  found is listed in the FPATH variable, the
1590:             file is read into the shell like a dot  script,  and  a
1591:             function  by  that name is invoked.  Once a pathname is
1592:             found, ksh  remembers  its  location  and  only  checks
1593:             relative  directories in PATH the next time the command
1594:             name is used.  Assigning a value to PATH causes ksh  to
1595:             forget the location of all command names.
1596: 
1597:           o The  FPATH  variable  is  searched  and files found are
1598:             treated as described above.
1599: 
1600:        The  first  argument  of  the  command  built-in,  described
1601:        earlier,  skips  the  checks  for  reserved  words  and  for
1602:        function definitions.  In all other  ways,  command  behaves
1603:        like  a built-in that is not associated with a pathname.  As
1604:        a result, if the first argument  of  command  is  a  special
1605:        built-in,  the  special  properties  of this built-in do not
1606:        apply.  For  example,  whereas,  exec 3&lt; foo  will  cause  a
1607:        script   containing   it   to   abort  if  the  open  fails,
1608:        command exec 3&lt; foo results in a non-zero  exit  status  but
1609:        does not abort the script.
1610: 
1611:        You can get a complete list of the special built-in commands
1612:        with builtin -s.   In  addition  builtin  without  arguments
1613:        gives  a list of the current built-ins and the pathname that
1614:        they are associated  with.   A  built-in  can  be  bound  to
1615:        another  pathname  by  giving the pathname for the built-in.
1616:        The basename of this path must be the name  of  an  existing
1617:        built-in  for  this  to succeed.  Specifying the name of the
1618:        built-in without a pathname causes this built-in to be found
1619:        before  a  path search.  A built-in can be deleted  with the
1620:        -d option.
1621: 
1622:        On systems with run  time  loading  of  libraries,  built-in
1623:        commands  can  be  added  with  the  builtin  command.  Each
1624:        command that is to be  built-in  must  be  written  as  a  C
1625:        function whose name is of the form b_name, where name is the
1626:        name of the built-in that is to be added.  The function  has
1627:        the  same  argument  calling  convention as main.  The lower
1628:        eight bits of the return value become the  exit  status  for
1629:        this   built-in.   Builtins  are  added  by  specifying  the
1630:        pathname of the library as an argument to the -f  option  of
1631:        builtin.
1632: 
1633:        The  built-in command, whence, when used with the -v option,
1634:        tells how a given command is bound.  A line is  printed  for
1635:        each  argument  to  whence telling what would happen if this
1636:        argument were  used  as  a  command  name.   It  reports  on
1637:        reserved  words,  aliases, built-ins, and functions.  If the
1638:        command is none of the above, it  follows  the  path  search
1639:        rules  and  prints  the full path-name, if any, otherwise it
1640:        prints an error message.
1641: 
1642:        3.15  Symbolic Names
1643: 
1644:        To  avoid  implementation  dependencies,  ksh  accepts   and
1645:        generates  symbolic  names  for built-ins that use numerical
1646: 
1647:        values in the Bourne shell.  The  -S  option  of  the  umask
1648:        built-in  command accepts and displays default file creation
1649:        permissions  symbolically.   It  uses  the   same   symbolic
1650:        notation as the chmod command.
1651: 
1652:        The  trap and kill built-in commands allows the signal names
1653:        to be given symbolically.  The names of  signals  and  traps
1654:        corresponding  to  signals  are  the same as the signal name
1655:        with the SIG prefix removed.  The trap 0 is named EXIT.
1656: 
1657:        3.16  Additional Variables
1658: 
1659:        In addition to the  variables  discussed  earlier,  ksh  has
1660:        other  variables  that  it  handles specially.  The variable
1661:        RANDOM produces a random number in the range 0 to 32767 each
1662:        time it is referenced.  Assignment to this variable sets the
1663:        seed for the random number generator.
1664: 
1665:        The parameter PPID is used to generate the process id of the
1666:        process which invoked this shell.
1667: 
1668:        3.17  Added Traps
1669: 
1670:        A  new  trap named ERR has been added.  This trap is invoked
1671:        whenever the shell would exit if the  -e  option  were  set.
1672:        This  trap  is used by Fourth Generation Make[16] which runs
1673:        ksh as a co-process.
1674: 
1675:        A trap named DEBUG gets executed after each  command.   This
1676:        trap can be used for debugging and other purposes.
1677: 
1678:        The KEYBD trap was described earlier.
1679: 
1680:        3.18  Debugging
1681: 
1682:        The  primary method for debugging Bourne shell scripts is to
1683:        use the -x option to enable the execution trace.  After  all
1684:        the  expansions have been performed, but before each command
1685:        is executed, the trace writes to standard error the name and
1686:        arguments  of each command preceded by a +.  While the trace
1687:        is very useful, there is no way to find  out  what  line  of
1688:        source  a given trace line corresponds to.  With ksh the PS4
1689:        variable  is  evaluated  for  parameter  expansion  and   is
1690:        displayed before each command, instead of the +.
1691: 
1692:        The  LINENO  variable  is  set  to  the  current line number
1693:        relative to the beginning of the current script or function.
1694:        It is most useful as part of the PS4 prompt.
1695: 
1696:        The  DEBUG  trap  can  be  used to write a break point shell
1697:        debugger  in  ksh.   An  example  of  such  a  debugger   is
1698:        kshdb.[17]
1699: 
1700:        3.19  Timing Commands
1701: 
1702:        Finding  the  time  it  takes to execute commands has been a
1703:        serious problem with  the  Bourne  shell.   Since  the  time
1704:        command  is  not  part  of  the language, it is necessary to
1705:        write a script in order to time a for or  while  loop.   The
1706:        extra  time  in invoking the shell and processing the script
1707:        is accumulated along with the time to execute the script.
1708: 
1709:        More seriously, the Bourne shell does not give correct times
1710:        for  pipelines.   The  reason for this is that the times for
1711:        some members of a pipeline are not  counted  when  computing
1712:        the time.  As an extreme example, running time on the script
1713:                   cat &lt; /dev/null | sort -u bigfile | wc
1714:        with the Bourne shell will show very little user and  system
1715:        time no matter how large bigfile is.
1716: 
1717:        To  correct  these  problems,  a reserved word time has been
1718:        added to replace the time command.  Any function, command or
1719:        pipeline  can  be  preceded  by this reserved word to obtain
1720:        information about  the  elapsed,  user,  and  system  times.
1721:        Since  I/O  redirections  bind  to the command, not to time,
1722:        parentheses  should  be  used   to   redirect   the   timing
1723:        information  which is normally printed on file descriptor 2.
1724: 
1725:        4.  SECURITY
1726: 
1727:        There are several documented problems  associated  with  the
1728:        security  of  shell  procedures[18].   These  security holes
1729:        occur  primarily  because  a   user   can   manipulate   the
1730:        environment   to  subvert  the  intent  of  a  setuid  shell
1731:        procedure.  Sometimes, shell procedures are  initiated  from
1732:        binary  programs, without the author's awareness, by library
1733:        routines which invoke shells to carry out their tasks.  When
1734:        the  binary  program  is run setuid then the shell procedure
1735:        runs with the permissions  afforded  to  the  owner  of  the
1736:        binary file.
1737: 
1738:        In the Bourne shell, the IFS parameter is used to split each
1739:        word into separate command arguments.  If a user knows  that
1740:        some  setuid  program  will run sh -c /bin/pwd (or any other
1741:        command in /bin) then  the  user  sets  and  exports  IFS=/.
1742:        Instead  of running /bin/pwd the shell will run bin with pwd
1743:        as an argument.  The user puts his or her  own  bin  program
1744:        into  the current directory.  This program can create a copy
1745:        of the shell, make this  shell  setuid,  and  then  run  the
1746:        /bin/pwd  program  so that the original program continues to
1747:        run successfully.  This kind of penetration is not  possible
1748:        with  ksh since the IFS parameter only splits arguments that
1749:        result from command or parameter substitution.
1750: 
1751:        Some setuid programs run  programs  using  system()  without
1752:        giving  the  full  pathname.   If  the  user  sets  the PATH
1753:        variable so that the desired command will be found in his or
1754:        her  local  bin, then the same technique described above can
1755:        be employed to compromise the security of  the  system.   To
1756:        close  up  this  and  other  security  holes, ksh resets the
1757:        effective user id to the real  user  id  and  the  effective
1758:        group  id  to the real group id unless the privileged option
1759:        (-p)  is  specified  at  invocation.   In  this  mode,   the
1760:        privileged   mode,  the  .profile  and  ENV  files  are  not
1761:        processed.  Instead, the file /etc/suid_profile is read  and
1762:        executed.   This  gives  an  administrator  control over the
1763:        environment to set the PATH variable or to log setuid  shell
1764:        invocations.   Clearly security of the system is compromised
1765:        if /etc or this file is publicly writable.
1766: 
1767:        Some versions of the UNIX  operating  system  look  for  the
1768: 
1769:        characters  #!  as the first two characters of an executable
1770:        file.  If these characters are found, then the next word  on
1771:        this  line  is  taken  as the interpreter to invoke for this
1772:        command and the interpreter is execed with the name  of  the
1773:        script  as argument zero and argument one.  If the setuid or
1774:        setgid bits are on for this file, then  the  interpreter  is
1775:        run with the effective uid and/or gid set accordingly.  This
1776:        scheme has three major drawbacks.  First of all, putting the
1777:        pathname of the interpreter into the script makes the script
1778:        less portable since the interpreter may be  installed  in  a
1779:        different  directory on another system.  Secondly, using the
1780:        #!  notation forces an exec of the interpreter even when the
1781:        call  is  invoked  from  the interpreter which it must exec.
1782:        This is inefficient since ksh can handle a failed exec  much
1783:        faster than starting up again.  More importantly, setuid and
1784:        setgid procedures provide an easy target for intrusion.   By
1785:        linking  a  setuid  or  setgid procedure to a name beginning
1786:        with a - the interpreter is fooled into thinking that it  is
1787:        being  invoked  with  a  command line option rather than the
1788:        name of a file.  When the interpreter is the shell, the user
1789:        gets  a  privileged interactive shell.  There is code in ksh
1790:        to guard against this simple form of intrusion.
1791: 
1792:        A more reliable way to handle setuid and  setgid  procedures
1793:        is  provided  with  ksh.  The technique does not require any
1794:        changes  to  the  operating  system  and   provides   better
1795:        security.   Another advantage to this method is that it also
1796:        allows scripts which have execute  permission  but  no  read
1797:        permission  to  run.   Taking  away  read  permission  makes
1798:        scripts more secure.
1799: 
1800:        The method relies on a setuid root program  to  authenticate
1801:        the request and exec the shell with the correct mode bits to
1802:        carry  out  the  task.   This  shell  is  invoked  with  the
1803:        requested  file  already  open  for reading.  A script which
1804:        cannot be opened for reading or which has its setuid  and/or
1805:        setgid bits turned on causes this setuid root program to get
1806:        execed.  For security reasons, this  program  is  given  the
1807:        full   pathname   /etc/suid_exec.    A  description  of  the
1808:        implementation of the /etc/suid_exec program can be found in
1809:        a separate paper[19].
1810: 
1811:        5.  CODE CHANGES
1812: 
1813:        ksh  is  written  in ANSI-C as a reusable library.  The code
1814:        can be compiled with C++ and older K&amp;R C as well.  The  code
1815:        uses  the  IEEE  POSIX  1003.1  and  ISO 9945-1 standard[20]
1816:        wherever possible so that ksh should be able to run  on  any
1817:        POSIX  compliant  system.   In  addition,  it is possible to
1818:        compile ksh for older systems.
1819: 
1820:        Unlike earlier version of the Bourne shell, ksh treats eight
1821:        bit  characters  transparently  without  stripping  off  the
1822:        leading bit.  There is also a compile time switch to  enable
1823:        handling multi-byte and multi-width characters sets.
1824: 
1825:        On  systems  with  dynamic  libraries, it is possible to add
1826:        built-in commands at run time   with  the  built-in  command
1827:        builtin described earlier.  It is also possible to embed ksh
1828:        in applications in a manner analogous to tcl.
1829: 
1830:        6.  EXAMPLE
1831: 
1832:        An example of a ksh script  is  included  in  the  Appendix.
1833:        This  one  page  program  is  a  variant  of the UNIX system
1834:        grep(1) program.  Pattern matching for this version of  grep
1835:        means shell patterns.
1836: 
1837:        The  first  half uses the getopts command to find the option
1838:        flags.  Nearly  all  options  have  been  implemented.   The
1839:        second  half goes through each line of each file to look for
1840:        a pattern match.
1841: 
1842:        This program is not intended to serve as a  replacement  for
1843:        grep  which  has been highly tuned for performance.  It does
1844:        illustrate the programming  power  of  ksh.   Note  that  no
1845:        auxiliary  processes  are  spawned  by  this script.  It was
1846:        written and debugged in under two hours.  While  performance
1847:        is acceptable for small files, this program runs at only one
1848:        tenth the speed of grep for large files.
1849: 
1850:        7.  PERFORMANCE
1851: 
1852:        ksh executes many scripts faster than the  System  V  Bourne
1853:        shell;  in  some  cases  more  than  10  times as fast.  The
1854:        primary reason for this is that ksh creates fewer processes.
1855:        The  time to execute a built-in command or a function is one
1856:        or two orders of magnitude faster than performing  a  fork()
1857:        and   exec()   to   create   a  separate  process.   Command
1858:        substitution and commands inside parentheses  are  performed
1859:        without   creating  another  process,  unless  necessary  to
1860:        preserve correct behavior.
1861: 
1862:        Another reason for improved performance is the  use  of  the
1863:        sfio[21], library for I/O.  The sfio library buffers all I/O
1864:        and buffers are flushed only when required.  The  algorithms
1865:        used  in  sfio  perform  better than traditional versions of
1866:        standard I/O so that programs that spend most of their  time
1867:        formatting  output may actually perform better than versions
1868:        written in C.
1869: 
1870:        Several of the internal algorithms have been changed so that
1871:        the  number  of  subroutine  calls  has  been  substantially
1872:        reduced.  ksh uses variable sized hash tables for variables.
1873:        Scripts  that  rely heavily on referencing variables execute
1874:        faster.  More processing  is  performed  while  reading  the
1875:        script  so that execution time is saved while running loops.
1876:        These changes are not noticeable for scripts that fork() and
1877:        run  processes,  but  they  reduce the time that it takes to
1878:        interpret commands by more than a factor of two.
1879: 
1880:        Most  importantly,   ksh   provide   mechanisms   to   write
1881:        applications  that  do  not  require as many processes.  The
1882:        arithmetic provided by the shell eliminates the need for the
1883:        expr   command.    The   pattern   matching   and  substring
1884:        capabilities eliminate the need to use sed or awk to process
1885:        strings.
1886: 
1887:        The  architecture  of  ksh  makes  it  easy to make commands
1888: 
1889:        built-ins without changing the semantics  at  all.   Systems
1890:        that  have  run-time binding of libraries allow applications
1891:        to be sped up by supplying the critical  programs  as  shell
1892:        built-in commands.  Implementations on other systems can add
1893:        built-in  commands  at  compile  time.   The  procedure  for
1894:        writing  built-in commands that can be loaded at run time is
1895:        in a separate document.[22],
1896: 
1897:        8.  CONCLUSION
1898: 
1899:        The 1988 version of ksh has tens  of  thousands  of  regular
1900:        users  and  is  a suitable replacement for the Bourne shell.
1901:        The 1993 version of ksh  is  essentially  upward  compatible
1902:        with  both  the 1988 version of ksh and with the recent IEEE
1903:        POSIX and ISO shell standard.  The 1993 version offers  many
1904:        advantages  for  programming  applications,  and it has been
1905:        rewritten so that it can be used in  embedded  applications.
1906:        It also offers improved performance.
1907: 
1908:        MH-11267-DGK-dgk              David G. Korn
1909: 
1910:                                  APPENDIX
1911: 
1912:                                 REFERENCES
1913: 
1914:          7. S.  R.  Bourne, An Introduction to the UNIX Shell, Bell
1915:             System Technical Journal, Vol. 57, No. 6, Part  2,  pp.
1916:             1947-1972, July 1978.
1917: 
1918:          8. W.  Joy,  An Introduction to the C Shell, Unix Program-
1919:             mer's Manual, Berkeley Software Distribution, Universi-
1920:             ty of California, Berkeley, 1980.
1921: 
1922:          9. Morris Bolsky and David Korn, The KornShell Command and
1923:             Programming Language, Prentice Hall, 1989.
1924: 
1925:         10. Jason Levitt, The Korn  Shell:  An  Emerging  Standard,
1926:             UNIX/World, pp. 74-81, September 1986.
1927: 
1928:         11. Rich Bilancia, Proficiency and Power are Yours With the
1929:             Korn Shell, UNIX/World, pp. 103-107, September 1987.
1930: 
1931:         12. John Sebes, Comparing UNIX Shells, UNIX Papers,  Edited
1932:             by the Waite Group, Howard W. Sams &amp; Co., 1987.
1933: 
1934:         13. T.  A.  Dolotta  and J. R. Mashey, Using the shell as a
1935:             Primary Programming Tool,  Proc.  2nd.  Int.  Conf.  on
1936:             Software Engineering, 1976, pages 169-176.
1937: 
1938:         14. J.  S.  Pendergrast,  WKSH  - Korn Shell with X-Windows
1939:             Support, USL. 1991.
1940: 
1941:         15. American National Standard for  Information  Systems  -
1942:             Programming Language - C, ANSI X3.159-1989.
1943: 
1944:         16. G.  S.  Fowler, The Fourth Generation Make, Proceedings
1945:             of the Portland USENIX meeting, pp. 159-174, 1985.
1946: 
1947:         17. Bill Rosenblatt, Debugging Shell  Scripts  with  kshdb,
1948:             Unix World, Volume X, No. 5, 1993.
1949: 
1950:         18. F.  T.  Grampp  and R. H. Morris, UNIX Operating System
1951:             Security, AT&amp;T Bell Labs Tech. Journal, Vol. 63, No. 8,
1952:             Part 2, pp. 1649-1671, 1984.
1953: 
1954:         19. D. G Korn Parlez-vous Kanji?  TM-59554-860602-03, 1986.
1955: 
1956:         20. POSIX - Part 1: System Application  Program  Interface,
1957:             IEEE Std 1003.1-1990, ISO/IEC 9945-1:1990.
1958: 
1959:         21. David  Korn  and  Kiem-Phong  Vo,  SFIO  -  A Safe/Fast
1960:             String/File I/O, Proceedings of the Summer Usenix,  pp.
1961:             235-255, 1991.
1962: 
1963:         22. David Korn, Guidelines for writing ksh-93 built-in com-
1964:             mands, to be published, 1994.
1965: 
1966: }}}
</textarea>
</div>

    <div class="clearfloats"></div>
  </div>    </div>      </div><div id="leftPanels" class="panels left">
                  <div class="panel expanded OSNav">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSNav');">Collectives</h1>
<div class="xwikipanelcontents">
<div id="xwikinavcontainer">
<span class="wikilink"><a href="/bin/view/Main/communities">Community Groups</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/projects">Projects</a></span><br/>
<span class="wikilink"><a href="/bin/view/Main/usergroups">User Groups</a></span>
</div><p/>
<script type="text/javascript">
document.observe('xwiki:dom:loaded', function() {
var obj = {div:'xwikinav',no:$count,height:250};
var acc = createAccordion(obj);
});
</script>
</div>
</div>
                        <div class="panel expanded OSDocs">
<h1 class="xwikipaneltitle" onclick="XWiki.togglePanelVisibility(this.parentNode, 'XWiki.XWikiGuest_Panels.OSDocs');">Project ksh93-integration Pages</h1>
<div class="xwikipanelcontents">
<ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/docs">Documentation</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/ksh93r">ksh93r docs</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/ksh93s">ksh93s+ docs</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/downloads">Downloads</a></span><ul class="star">
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2006%2D07%2D12">2006&#45;07&#45;12: ksh93 addon tarball for B37/i386</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2006%2D08%2D05">2006&#45;08&#45;05: ksh93 add&#45;on tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2006%2D08%2D27">2006&#45;08&#45;27: ksh93 add&#45;on tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2006%2D09%2D14">2006&#45;09&#45;14: ksh93 add&#45;on tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2006%2D12%2D14">2006&#45;12&#45;14: ksh93 add&#45;on tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2007%2D03%2D18">2007&#45;03&#45;18: ksh93 add&#45;on tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2007%2D04%2D19">2007&#45;04&#45;19: ksh93 add&#45;on tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2007%2D07%2D14">2007&#45;07&#45;14: ksh93 add&#45;on tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2007%2D10%2D31">2007&#45;10&#45;31: ksh93 add&#45;on tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2007%2D11%2D05">2007&#45;11&#45;05: ksh93 update tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2008%2D02%2D29">2008&#45;02&#45;29: ksh93 update tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2008%2D06%2D17">2008&#45;06&#45;17: ksh93 update tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2008%2D06%2D24">2008&#45;06&#45;24: ksh93 update tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2008%2D07%2D02">2008&#45;07&#45;02: ksh93 update tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2008%2D08%2D10">2008&#45;08&#45;10: ksh93 update tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2008%2D11%2D14">2008&#45;11&#45;14: ksh93 update tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D03%2D31">2009&#45;03&#45;31: ksh93 update tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D04%2D20">2009&#45;04&#45;20: ksh93 update 2 tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D05%2D11">2009&#45;05&#45;11: ksh93&#45;integration update 2 tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D05%2D27">2009&#45;05&#45;27: ksh93&#45;integration update 2 tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D06%2D16">2009&#45;06&#45;16: ksh93&#45;integration update 2 tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D07%2D02">2009&#45;07&#45;02: ksh93&#45;integration update 2 tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D08%2D22">2009&#45;08&#45;22: ksh93&#45;integration update 2 tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D09%2D16">2009&#45;09&#45;16: ksh93&#45;integration update 2 tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D09%2D22">2009&#45;09&#45;22: ksh93&#45;integration update 2 tarballs for OpenSolaris</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/2009%2D10%2D18">2009&#45;10&#45;18: ksh93&#45;integration update 2 tarballs for OpenSolaris</a></span></li>
</ul></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/osdevconf2007">OpenSolaris Developer Conference 2007</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/screenshots">Screenshots</a></span></li>
<li><span class="wikilink"><a href="/bin/view/Project+ksh93%2Dintegration/source">Source</a></span></li>
</ul>
                    </div>
</div>
      </div>

  </div>
<div class="clearfloats"></div>
  </div></div><div id="footerglobal" class="layoutsection">
<div class="minwidth"></div>
<hr/>
        <div id="xwikiplatformversion">XWiki Enterprise 2.7.1.34853 - <a onclick="openURL('http://enterprise.xwiki.org/xwiki/bin/view/Main/Documentation', '_blank'); return false;" href="http://www.xwiki.org/xwiki/bin/view/Main/Documentation">Documentation</a></div>
<br/>
  
      <div id="footer">
    <p>
                <a href="https://markebrooks.github.io/bin/view/Main/tou/">Terms of Use</a>
                |
                <a href="http://www.oracle.com/html/privacy.html">Privacy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/trademark/">Trademarks</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/copyrights/">Copyright Policy</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site_guidelines/">Site Guidelines</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/site-map/">Site Map</a>
                |
                <a href="https://markebrooks.github.io/bin/view/Main/help/">Help</a>
                <br/>Your use of this web site or any of its content or software indicates your agreement to be bound by these Terms of Use.<br/>
                &copy; 2012, Oracle Corporation and/or its affiliates.<br/><img src="https://markebrooks.github.io:443/static/images/logo_oracle_footer.gif" alt="Oracle Logo"/>
            </p>
        </div>

  
</div>

</div></div></body>
</html>
